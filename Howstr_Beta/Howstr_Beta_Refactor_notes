ISSUES
- Howstr Alpha only handled one graph, Beta needs to handle many
-- sNowDoc isn't flexible enough
-- the display will send many queries to the backend, mapped to various windows
- use groups to manage the display images
- sMain[0][hide]=true
-- probably don't need that; I think it was for rTree
- sMain[4][coord]=500,10
-- probably don't need this tag anymore since layout is handled automatically
- sMain[doc][rec][tag]=data/pointer
-- can record the path & file of origin in metadata
-- but would be more straight forward to use those as keys
-- sMain[path][file][doc][rec][tag]=data/pointer
-- that would be the entire pointer; wouldn't require a lookup table or search
- in grapherrific, topoSort calls "get kahnSort"
-- kahnSort is a function, but doesn't return anything
-- "get" is putting the function kahnSort into the "it" variable
-- can kahnSort just be a command and not be called with "get"?
- tracking data>logic>display
-- consistent address is path/file/doc/rec/tag
-- so there are windows, and possibly "areas" within each window
-- map those to the data, affects queries and answers
-- each area makes its own independent query
-- logic answers each query and returns to area's address
-- ? update to one area should push changes to other areas
-- at the moment each query can be handled one at a time
-- in the future they can go into a list and a service will respond
- many documents, files, and paths
-- when they crosspoint each other, a query will ask for info in more than one
-- graph logic should have a thread for each query, bounded by its parameters/address
-- should push # of changes to requesting area, so area can prompt user to refresh
- preview
-- needs more graphics
-- create and delete preview graphics?
-- logic for Howstr action groups is more complicated
- consolidate data into fewer variables
- spread out logic
-- the logic related to different NotionAll relationships is important
-- but it's importance is spread out in a lot of different places
-- need to be able to draw on some central data/logic
-- which makes the important distinctions
- pre-process or process on-demand
-- some aspects of display depend on graph details
-- ex: preview logic depends on two nodes abutting or not
-- calc that data ahead of time for all possible nodes?
-- or allow preview logic to query graph logic?
- graph change request syntax
-- need to be able to package many related requests
-- also distinguish these pointers from existing pointers
array[0][act]=flow_btwn_diffType/span_detached_sameType/inject_btwn_diffType/flow_branch
array[a][type]=flow
array[a][backward]=#
array[a][forward]=#
array[#][something] (will replace step # details with new details)
array[#][hide]=true (will wide step #)
-- simple focus change request
array[from]=user
array[focus]=#
- basically there's no benefit to multiple different arrays
-- display info needs almost full graph data for preview & change requests
- changeRequest in grapherrific.livecode
-- must use [a] for first new element
- had to change some handlers to functions
-- now they return the rec of the step they created
-- newItem, newDilink
- delta & undo
-- undo works by negating all pointers attributed to a particular turn
-- so a turn, with a delta, can be undone/redone if pointers can be found
-- for now, a delta will hide anything that's overcome by events
-- then, the delta will create anything new it needs
-- need to be able to attribute all changes to one delta turn
-- that will require modifying newItem, newDilink, hideStep
- parameters
-- I used to pass all parameters in a long list, which does work
-- but it's not as flexible as putting them into an array
-- with an array, the handler can look for whatever it expects and ignore the rest
-- that way I don't have to update old calls to the handler
-- just use arrays (key:value pairs) whenever passing data
-- it is a bit longer syntax but is much more extensible
-- EX: newItem needs
--- x[turn]=turn's pointer
--- x[type]=state/change/etc
--- x[doc]=document
- need a set of variables that answer pre-selected NotionAll queries
-- EX: [nodeTypes]="state change" and [linkTypes]="flow dive rise"
-- so that instead of hard coding those keywords I can globally set them
- NOTE: it's appropriate to move the turn to the end of the list of rec+n
- if one or more ends of a link already exist, then add pointer to list
-- like if a node already has a [next] tag, an additional next goes there
-- don't create additional [next] tags
-- it would be helpful if the handler knew that instead of having to check
- ! nodes will have a different tag for each link
-- so when a link is created you get the link's step, it's 2 tags
-- and then a new tag for the node's step at either end
-- therefore if a node has 5 flow links, it will have 5 [next] tags
