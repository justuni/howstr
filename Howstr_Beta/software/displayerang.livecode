script "displayerang"
function tempNodeDetails @pShort,tDo
   put "function TempNodeDetails" into xX["write"];    devLog xX
   -- pShort = sMainShort
   put tDo["info"] into tNodeRec
   put tDo["doc"] into tDoc
   -- build a cr separated string to put into a list field
   -- in links&node, then this node's title, then out links&node
   put pShort[tDoc][tNodeRec]["title"] into tTitle -- may or may not actually have a title
   put "prev skim" into tInTags
   put "next trim" into tOutTags
   put 0 into tLineCount
   -- in links&node
   repeat for each word tTag in tInTags
      put pShort[tDoc][tNodeRec][tTag] into tLinks
      repeat for each line tLinkRec in tLinks
         put tLineCount + 1 into tLineCount
         put pShort[tDoc][tLinkRec]["weight"] into tLinkWeight
         if tLinkWeight is empty then put "1" into tLinkWeight
         put pShort[tDoc][tLinkRec][tTag] into tOtherNode
         put pShort[tDoc][tOtherNode]["title"] into tOtherTitle
         if tOtherTitle is empty then put tOtherNode into tOtherTitle
         put pShort[tDoc][tOtherNode]["type"] into tOtherType
         put tOtherNode into tList[tLineCount]["node"]
         put tLinkRec into tList[tLineCount]["link"]
         put tLinkWeight into tList[tLineCount]["weight"]
         put cr & symbolLookup(tOtherType) && tOtherTitle && "[" & tTag & "]" &&  tLinkWeight && "IN>" after tList["string"]
      end repeat
   end repeat
   -- this node's title
   put pShort[tDoc][tNodeRec]["title"] into tTitle -- may or may not actually have a title
   if tTitle is empty then put tNodeRec into tTitle
   put pShort[tDoc][tNodeRec]["type"] into tThisNodeType
   put tLineCount + 1 into tLineCount
   put tLineCount into tList["master"]
   put tNodeRec into tList[tLineCount]["rec"]
   put tTitle into tList[tLineCount]["title"]
   put cr & "[this node]" && symbolLookup(tThisNodeType) && tTitle after tList["string"]
   -- out links&node
   repeat for each word tTag in tOutTags
      put pShort[tDoc][tNodeRec][tTag] into tLinks
      repeat for each line tLinkRec in tLinks
         put tLineCount + 1 into tLineCount
         put pShort[tDoc][tLinkRec]["weight"] into tLinkWeight
         if tLinkWeight is empty then put "1" into tLinkWeight
         put pShort[tDoc][tLinkRec][tTag] into tOtherNode
         put pShort[tDoc][tOtherNode]["title"] into tOtherTitle
         if tOtherTitle is empty then put tOtherNode into tOtherTitle
         put pShort[tDoc][tOtherNode]["type"] into tOtherType
         put tOtherNode into tList[tLineCount]["node"]
         put tLinkRec into tList[tLineCount]["link"]
         put tLinkWeight into tList[tLineCount]["weight"]
         put cr & ">OUT" && tLinkWeight && "[" & tTag & "]" && symbolLookup(tOtherType) && tOtherTitle after tList["string"]
      end repeat
   end repeat
   filter tList["string"] without empty
   return tList
end tempNodeDetails

function stepString @pMain,pStuff
   put "function stepString" into xX["write"];    devLog xX
   put pStuff["rec"] into tEyeDee
   put pStuff["doc"] into tDaDoc
   if tDaDoc is empty or tEyeDee is empty then break
   --takes in a step record and returns a string (type & id/title)
   put isAnode(pMain,tDaDoc,tEyeDee) into tType
   --   if tType is false then return "not a node"
   if tType is false then 
      -- it's a link
      -- # type [x] to [z]
      put isAlink(pMain,tDaDoc,tEyeDee) into tLinkFacts
      put tDaDoc into tStuff["doc"]
      put tLinkFacts["X"] into tStuff["rec"]
      put stepString(pMain,tStuff) into tX
      put tLinkFacts["Z"] into tStuff["rec"]
      put stepString(pMain,tStuff) into tZ
      put tEyeDee && tLinkFacts["type"] && "[" & tX & "]" && "to" && "[" & tZ & "]" into tTitle
      if tTitle is empty then put "(link)" && tEyeDee into tTitle
      return tTitle
   else
      -- it's a node
      put tEyeDee into tStuff["rec"]
      put "title" into tStuff["tag"]
      put tDaDoc into tStuff["doc"]
      put getTagData(pMain,tStuff) into tTitle
      if tTitle is empty then put tEyeDee && "blank" into tTitle
      put symbolLookup(tType) && tTitle into tThisString
      return tThisString
   end if
end stepString

function symbolLookup tArg --a lookup table for display symbols
   put "function symbolLookup" into xX["write"];    devLog xX
   switch tArg
      case "state"
         return numtocodepoint(0x25A0) --box
      case "change"
         return numtocodepoint(0x25B2) --triangle
   end switch
   return "not found in symbolLookup function"
end symbolLookup

on tempConvertData pShort,@pData,pDoc
   put "on tempConvertData" into xX["write"];    devLog xX
   -- sMainShort to sGraphData
   -- sMainShort[doc][rec][next/prev]
   -- sGraphData[nodes/links][rec][next/prev/displayString]
   
   repeat for each key tRec in pShort[pDoc]
      if pShort[pDoc][tRec]["type"] is among the words of "state change" then
         -- node...probably !
         put pShort[pDoc][tRec] into pData["nodes"][tRec]
      else if tRec is not 0 then
         -- link...probably !
         put pShort[pDoc][tRec] into pData["links"][tRec]
      end if
   end repeat
   -- node neighbors
   -- this is important for preview and change logic
   -- link,node
   repeat for each key tRec in pData["nodes"]
      repeat for each word tDir in "next prev trim skim"
         --         repeat for each item tLink in pData["nodes"][tRec][tDir]
         repeat for each line tLink in pData["nodes"][tRec][tDir]
            if tDir is "next" or tDir is "prev" then
               put cr & tLink & "," & pData["links"][tLink][tDir] after pData["abutFlow"][tRec]
               filter pData["abutFlow"][tRec] without empty
            else if tDir is "trim" then
               put cr & tLink & "," & pData["links"][tLink][tDir] after pData["abutRise"][tRec]
               filter pData["abutRise"][tRec] without empty
            else if tDir is "skim" then
               put cr & tLink & "," & pData["links"][tLink][tDir] after pData["abutDive"][tRec]
               filter pData["abutDive"][tRec] without empty
            end if
         end repeat
      end repeat
   end repeat
   -- find the case node
   -- needed to request certain changes
   repeat for each key tRec in pData["nodes"]
      if "bulk" is among the keys of pData["nodes"][tRec] and "read" is among the keys of pData["nodes"][tRec] then
         put tRec into pData["case"]
      end if
   end repeat
   -- undo/redo
   put pShort[pDoc][0]["undo"] into pData["undo"]
   put pShort[pDoc][0]["redo"] into pData["redo"]
   -- metatdata
   put pShort[pDoc][0]["pointerTags"] into pData["pointerTags"]
   -- node display label
   repeat for each key tRec in pData["nodes"]
      put pShort[pDoc][tRec]["title"] into tForShow
      if tForShow is empty then
         put symbolLookup(pShort[pDoc][tRec]["type"]) && tRec into tForShow
      else
         put symbolLookup(pShort[pDoc][tRec]["type"]) & " " before tForShow
      end if
      put tForShow into pData["nodes"][tRec]["displayString"]
   end repeat
end tempConvertData

on middleOut pData,@pDraw,pFocus -- ! a hacky way to draw the provided graph, calls assignLayers
   -- ! as of 10JAN2016 middleOut only follows flow links, so it won't visit or follow dive/rise links
   put "on middleOut" into xX["write"];    devLog xX
   -- pData ! just sGraphData at the moment, maybe this should be an adjacency list ?
   -- setup variables --------------------------------------------------------------------------------
   put empty into pData["layers"]
   put empty into pData["visited"]
   -- recursively assign layers ------------------------------------------------------------------------
   -- pass pData by reference, and focus node, and initial layer
   -- add layer and visited info to pData
   assignLayers pData,pFocus,0
   -- remove duplicates in layers ------------------------------------------------------------------
   repeat for each key tLayer in pData["layers"]
      put pData["layers"][tLayer]into tOneLayer
      split tOneLayer by comma
      combine tOneLayer using comma
      if char -1 of tOneLayer is not "," then put "," after tOneLayer
      put tOneLayer into pData["layers"][tLayer]
   end repeat
   -- shuffle nodes so links point left-to-right ----------------------------------------------------
   -- when a pair of linked nodes are misaligned...
   --- if on the pos side (layers >0), shift end more pos
   --- if on the neg side (layers <0), shift start more neg
   --- making a link vertical is okay, but not backwards
   --- don't move the focused node out of layer 0
   put empty into tShuffles -- cr delimited list; node and direction shuffled; kill infinite loop
   put true into tAgain -- keep repeating until nothing changes
   repeat while tAgain is true
      put false into tAgain
      repeat for each item tLink in pData["visited"]["links"]
         put item 1 of pData["links"][tLink]["prev"] into tStart
         put item 1 of pData["links"][tLink]["next"] into tEnd
         put pData["nodes"][tStart]["layer"] into tStartLayer
         put pData["nodes"][tEnd]["layer"] into tEndLayer
         if not (tStartLayer < tEndLayer) then
            if tEnd is pFocus then
               -- shuffle start more negative
               put true into tAgain
               --               delete item itemOffset(tStart,pData["layers"][tStartLayer]) of pData["layers"][tStartLayer]
               set the wholeMatches to true
               put itemOffset(tStart,pData["layers"][tStartLayer]) into tNum
               delete item tNum of pData["layers"][tStartLayer]
               put tStart & "," after pData["layers"][tStartLayer -1]
               put tStartLayer -1 into pData["nodes"][tStart]["layer"]
               put cr & tStart & "-" after tShuffles
               filter tShuffles without empty
            else if tEnd & "-" is among the lines of tShuffles then
               -- have to catch a situation where a node just shuffles back and forth
               -- shuffle start more negative
               put true into tAgain
               delete item itemOffset(tStart,pData["layers"][tStartLayer]) of pData["layers"][tStartLayer]
               put tStart & "," after pData["layers"][tStartLayer -1]
               put tStartLayer -1 into pData["nodes"][tStart]["layer"]
               put cr & tStart & "-" after tShuffles
               filter tShuffles without empty
            else
               -- shuffle end more positive
               put true into tAgain
               delete item itemOffset(tEnd,pData["layers"][tEndLayer]) of pData["layers"][tEndLayer]
               put tEnd & "," after pData["layers"][tEndLayer +1]
               put tEndLayer +1 into pData["nodes"][tEnd]["layer"]
               put cr & tEnd & "+" after tShuffles
               filter tShuffles without empty
            end if
         end if -- is tStart < tEnd?
      end repeat -- tLink in sLinksVisited
   end repeat -- tAgain
   -- order in layer by node #, ascending ----------------------------------------------------------
   repeat for each key tLayer in pData["layers"]
      sort items of pData["layers"][tLayer] ascending numeric
      if char 1 of pData["layers"][tLayer] is "," then delete char 1 of pData["layers"][tLayer]
   end repeat
   -- ! deal with elements that are visible but weren't discovered by middleOut
   repeat for each word tKind in "nodes links"
      repeat for each line tRec in the keys of pData[tKind]
         if tRec is not among the items of pData["visited"][tKind] then
            put tRec into item (the number of items of pData["unvisited"][tKind])+1 of pData["unvisited"][tKind]
         end if
      end repeat
   end repeat
   put pData into pDraw
end middleOut

on assignLayers @pAll,pSeed,pTheLayer -- ! the recursive part of middleOut
   put "on assignLayers" into xX["write"];    devLog xX
   -- pAll = pData (just a copy of sGraphData at the moment); this adds display info to it
   -- pSeed = the node to find neighbors of
   -- pTheLayer = the layer pSeed was assigned before this function was called
   --- list all next & prev links
   --- format as links
   --- don't add if already on list of visited links
   --- add node to layer; prev -1; next +1
   --- call this function again on this node
   --- terminal case is when this node has no unvisited links
   if pSeed is not among the items of pAll["visited"]["nodes"] then
      put pSeed & "," after pAll["visited"]["nodes"]
      put pSeed & "," after pAll["layers"][pTheLayer]
      put pTheLayer into pAll["nodes"][pSeed]["layer"]
      repeat for each word tDir in "next prev"
         --         repeat for each item tLink in pAll["nodes"][pSeed][tDir]
         repeat for each line tLink in pAll["nodes"][pSeed][tDir]
            if tLink is not among the items of pAll["visited"]["links"] then
               put tLink & "," after pAll["visited"]["links"]
               filter pAll["visited"]["links"] without empty
               put item 1 of pAll["links"][tLink][tDir] into tNode
               switch tDir
                  case "next"
                     assignLayers pAll,tNode,(pTheLayer +1)
                     break
                  case "prev"
                     assignLayers pAll,tNode,(pTheLayer - 1)
                     break
               end switch
            end if
         end repeat
      end repeat 
   end if
end assignLayers

on displayManager pInfo,@pGUI,pSizes,pNow,@pHist -- ! creates/changes/deletes controls
   put "on displayManager" into xX["write"];    devLog xX
   -- sGraphDrawing,sGUIstuff,tSizes,sNowFocus,sMouseHistory
   --pSizes[width/height/layer/node]
   lock messages
   -- delete old node graphics; brute force but not much to draw at the moment   
   if pGUI is not empty then
      repeat for each word tKind in "nodes links"
         repeat for each key tNum in pGUI[tKind]
            put pGUI[tKind][tNum]["graphic"] into tID
            if exists(tID) then delete tID
         end repeat
      end repeat
   end if
   put pSizes["width"] into tWinWidth
   put pSizes["height"] into tWinHeight
   put tWinWidth/2 into tCenterH
   lock screen
   put empty into pGUI
   -- specify case node
   put pInfo["case"] into pGUI["case"]
   put pInfo["abutFlow"] into pGUI["abutFlow"]
   put pInfo["abutDive"] into pGUI["abutDive"]
   put pInfo["abutRise"] into pGUI["abutRise"]
   -- calculate node coordinates and draw graphic
   repeat for each key tLayer in pInfo["layers"]
      put ((pSizes["node"] + pSizes["layer"]) * tLayer) + tCenterH into tNodeH
      put the number of items of pInfo["layers"][tLayer] into tStack
      put tWinHeight/(tStack + 1) into tStackV
      put 1 into tCount
      repeat for each item tNode in pInfo["layers"][tLayer]
         -- start positioning from top of window
         put tStackV * tCount into tNodeV
         -- node coordinates
         put tNodeH into pGUI["nodes"][tNode]["horz"]
         put tNodeV into pGUI["nodes"][tNode]["vert"]
         put tNode into tStuff["node"]
         put tNodeH & "," & tNodeV into tStuff["coord"]
         put pSizes["node"] into tStuff["size"]
         put pInfo["nodes"][tNode]["type"] into tStuff["type"]
         -- node type
         put tStuff["type"] into pGUI["nodes"][tNode]["type"]
         -- node's display string
         put pInfo["nodes"][tNode]["displayString"] into pGUI["nodes"][tNode]["displayString"]
         put pInfo["nodes"][tNode]["displayString"] into tStuff["displayString"]
         -- node's graphic ID
         put makeNode(tStuff) into pGUI["nodes"][tNode]["graphic"]
         -- node's neighbors
         put pInfo["abutFlow"][tNode] into pGUI["nodes"][tNode]["abutFlow"]
         if tNode is among the keys of pInfo["abutDive"] then put pInfo["abutDive"][tNode] into pGUI["nodes"][tNode]["abutDive"]
         if tNode is among the keys of pInfo["abutRise"] then put pInfo["abutRise"][tNode] into pGUI["nodes"][tNode]["abutRise"]
         put tCount + 1 into tCount
      end repeat
   end repeat
   -- put miscellaneous nodes into the pool, or whatever ---------------------
   -- not the case node cuz technically the whole window is the case node
   put false into tMisc
   put 0 into tCountThis
   repeat for each item tNode in pInfo["unvisited"]["nodes"]
      if tNode is not among the items of pInfo["case"] then
         put true into tMisc
         -- node coordinates
         put (pSizes["node"]/2) + (tCountThis * (pSizes["node"] + pSizes["layer"])) into pGUI["nodes"][tNode]["horz"]
         put tWinHeight-(pSizes["node"]/2) into pGUI["nodes"][tNode]["vert"]
         -- build request
         put tNode into tStuff["node"]
         put pGUI["nodes"][tNode]["horz"] & "," & pGUI["nodes"][tNode]["vert"] into tStuff["coord"]
         put pSizes["node"] into tStuff["size"]
         put pInfo["nodes"][tNode]["type"] into tStuff["type"]
         -- node type
         put tStuff["type"] into pGUI["nodes"][tNode]["type"]
         -- node's display string
         put pInfo["nodes"][tNode]["displayString"] into pGUI["nodes"][tNode]["displayString"]
         put pInfo["nodes"][tNode]["displayString"] into tStuff["displayString"]
         -- node's graphic ID
         put makeNode(tStuff) into pGUI["nodes"][tNode]["graphic"]      
         put true into pGUI["nodes"][tNode]["misc"]
         put tCountThis + 1 into tCountThis
      end if
   end repeat
   -- draw flow links...crudly --------------------------
   repeat for each key tLink in pInfo["links"]
      if tLink is 0 then next repeat -- ! probably don't need this as of 11JAN2016
      -- if this link is attached to a misc node, don't draw it
      put false into tMoveOn
      repeat for each key tSomething in pInfo["links"][tLink]
         if tSomething is among the words of "next prev read skim bulk trim" then
            put pInfo["links"][tLink][tSomething] into tTag
            if pGUI["nodes"][tTag]["misc"] is true then 
               put true into tMoveOn
               exit repeat -- exit this small repeat test
            end if
         end if
      end repeat
      if tMoveOn is true then next repeat -- next tLink
      -- okay, so go ahead and draw the link tLink
      if pInfo["links"][tLInk]["type"] is not "dive" and pInfo["links"][tLInk]["type"] is not "rise" then -- FLOW
         put item 1 of pInfo["links"][tLink]["prev"] into tStart
         put item 1 of pInfo["links"][tLink]["next"] into tEnd
         put pSizes["node"] / 2 into tClean
         put (pGUI["nodes"][tStart]["horz"]+tClean) & "," & pGUI["nodes"][tStart]["vert"] into tStartCoord
         put (pGUI["nodes"][tEnd]["horz"]-tClean) & "," & pGUI["nodes"][tEnd]["vert"] into tEndCoord
         put tLink into tBox["link"]
         put tStartCoord & cr & tEndCoord into tBox["line"]
         put pSizes["link"] into tBox["size"]
         put pInfo["links"][tLink]["type"] into tBox["type"]
         put pInfo["links"][tLink]["weight"] into tWeight
         if tWeight is empty then
            put 1 into pGUI["links"][tLink]["weight"]
         else
            put tWeight into pGUI["links"][tLink]["weight"]
         end if
         put tBox["type"] into pGUI["links"][tLink]["type"]
         put makeLink(tBox) into pGUI["links"][tLink]["graphic"]
      else if pInfo["links"][tLInk]["type"] is "dive" then -- DIVE 
         -- what node diving into
         --- pInfo link>read=#
         --- pGUI node>#>graphic
         -- rect of that control
         -- points = L-10,top cr L,T+10
         put pInfo["links"][tLink]["read"] into tTheNode
         put pGUI["nodes"][tTheNode]["graphic"] into tTheNodeName
         put the rect of tTheNodeName into tTheNodeRect
         put item 1 of tTheNodeRect into tL
         put item 2 of tTheNodeRect into tT
         put (tL-10) & "," & tT & cr & tL & "," & (tT+10) into tStuff["line"]
         put tLink into tStuff["link"]
         put 2 into tStuff["size"]
         put makeScopeLink(tStuff) into pGUI["links"][tLink]["graphic"]
      else if pInfo["links"][tLInk]["type"] is "rise" then -- RISE
         -- what node rising out of
         --- pInfo link>trim=#
         --- pGUI node>#>graphic
         -- rect of that control 
         -- points = right,T+10 cr R+10,top
         put pInfo["links"][tLink]["bulk"] into tTheNode
         put pGUI["nodes"][tTheNode]["graphic"] into tTheNodeName
         put the rect of tTheNodeName into tTheNodeRect
         put item 3 of tTheNodeRect into tR
         put item 2 of tTheNodeRect into tT
         put tR  & "," & (tT+10) & cr & (tR+10) & "," & tT into tStuff["line"]
         put tLink into tStuff["link"]
         put 2 into tStuff["size"]
         put makeScopeLink(tStuff) into pGUI["links"][tLink]["graphic"]
      end if
   end repeat
   -- draw scope links...also crudly -------------------
   
   -- make sure the node graphics are on top
   repeat for each key tNode in pGUI["nodes"]
      set the layer of pGUI["nodes"][tNode]["graphic"] to top
   end repeat
   -- then make sure the preview graphics are on top of that
   set the layer of graphic "preFlow1" to top
   set the layer of graphic "preFlow2" to top
   set the layer of field "preState" to top
   set the layer of field "preChange" to top
   -- highlight focused node (since all nodes new, old highlighted one was deleted)
   put pGUI["nodes"][pNow]["graphic"] into tBlerg
   set the backgroundColor of tBlerg to orange
   -- undo/redo icons
   -- for quick mode, don't allow user to undo the graph smaller than the minimum action group
   -- ! 15DEC2015 hide can take graph down to 4 nodes with undo still being acceptable
   -- what I really want to prevent is undoing back through the initialization steps
   --   if the number of lines of the keys of pInfo["nodes"] is 4 then
   --      set the visible of widget "iconUndo" to false
   --   else
   --      set the visible of widget "iconUndo" to pInfo["undo"]
   --   end if
   set the visible of widget "iconUndo" to pInfo["undo"]
   set the visible of widget "iconRedo" to pInfo["redo"]
   -- empty out selection and hide hide button
   put empty into pHist["nodeSelected"]
   put empty into pHist["linkSelected"]
   set the visible of button "hideButt" to false
   -- set misc nodes navigation buttons
   set the visible of button "miscRightButt" to tMisc
   set the visible of button "miscLeftButt" to tMisc
   unlock screen
   unlock messages
   put "end displayManager --------------" into xX["write"];    devLog xX
end displayManager

function makeNode pDetails
   put "function makeNode" into xX["write"];    devLog xX
   --   breakpoint
   -- pDetails[node/coord/size/type/displayString]
   -- ! assume doc is 1
   put 1 into tDoc
   set the margins of the templateField to 3
   set the locked of the templateField to true
   set the lockText of the templateField to true
   set the dontwrap of the templateField to false
   set the height of the templateField to pDetails["size"]
   set the width of the templateField to pDetails["size"]
   set the name of the templateField to pDetails["node"] & "NodeGraphic"
   set the location of the templateField to pDetails["coord"]
   set the threeD of the templatefield to false
   set the showborder of the templatefield to false
   set the bordercolor of the templatefield to white
   set the backgroundcolor of the templatefield to "0,220,220"
   set the textSize of the templatefield to 14
   set the outerglow["color"] of the templatefield to "40,40,40"
   --   set the behavior of the templatefield to the long id of button "graphBehave"
   create field
   put it into tID
   set the cGraphKey of (tID) to pDetails["node"]
   set the htmltext of (tID) to pDetails["displayString"]   
   -- size the node to fit the displayString, within limits
   put the formattedHeight of word 1 to -1 of (tID) into tFormHigh
   put the height of (tID) into tHigh
   put 1 into tCounter
   repeat while tFormHigh > tHigh
      switch tCounter
         case 1
            set the width of (tID) to pDetails["size"] * 1.25
            break
         case 2
            set the height of (tID) to pDetails["size"] * 1.5
            break
         case 3
            set the textsize of (tID) to 12
            break
         case 4
            set the textsize of (tID) to 10
            break
         default
            exit repeat -- just finish
      end switch
      put tCounter + 1 into tCounter
      put the formattedHeight of word 1 to -1 of (tID) into tFormHigh
      put the height of (tID) into tHigh
   end repeat
   --   if the height of (tID) > pDetails["size"] then set the height of (tID) to the formattedHeight of word 1 to -1 of (tID)
   return tID
end makeNode

function makeLink pThis
   put "function makeLink" into xX["write"];    devLog xX
   -- pThis[link/line/type]
   set the style of the templateGraphic to "line"
   set the endArrow of the templateGraphic to true
   set the foregroundColor of the templategraphic to "0,220,220"
   set the points of the templateGraphic to pThis["line"]
   set the name of the templateGraphic to pThis["link"] & "LinkGraphic"
   set the filled of the templateGraphic to false
   set the linesize of the templateGraphic to pThis["size"]
   set the outerglow["color"] of the templateGraphic to "40,40,40"
   --   set the behavior of the templateGraphic to the long id of button "graphBehave"
   create graphic
   set the cGraphKey of it to pThis["link"]
   return it
end makeLink

function makeScopeLink pThis
   set the style of the templateGraphic to "line"
   set the endArrow of the templateGraphic to true
   set the foregroundColor of the templategraphic to "0,220,220"
   set the points of the templateGraphic to pThis["line"]
   set the name of the templateGraphic to pThis["link"] & "LinkGraphic"
   set the filled of the templateGraphic to false
   set the linesize of the templateGraphic to pThis["size"]
   set the outerglow["color"] of the templateGraphic to "40,40,40"
   --   set the behavior of the templateGraphic to the long id of button "graphBehave"
   create graphic
   set the cGraphKey of it to pThis["link"]
   return it
end makeScopeLink

function mouseTracker @pGUI,@pHist,@p1Down,@p1Enter,pFocus,pNode
   --   put "function mouseTracker" into xX["write"];    devLog xX
   -- sGUIstuff,sMouseHistory,s1Down,s1Enter,sNowFocus,sNodeSize
   -- this mostly replaces Livecode's built in mouse handlers because they couldn't reliably do what I wanted
   -- this gets called for almost all mouse messages and compares current status to prior status
   -- (1) research the state of the mouse
   -- (1a) record the location of the mouse and selections
   -- (1b) compare old mouse button states to new
   -- (1c) if an anchor, track new areas entered
   -- (2) build preview based on research
   -- tNow[1down]=true/false
   -- tNow[3down]=true/false
   -- tNow[inside]=empty/#
   -- tNow[moving]=X,Y
   -- tNow[fixed]=X,Y/empty
   -- tNow[nodeSelected]=#,#,# (cuz they're organized first by node/link in GUIstuff)
   -- tNow[linkSelected]=#,#,#
   -- tNow[tooltip]=true/false
   
   -- (1) state of controls
   put the hilite of button "tooltipSwitch" into tNow["tooltip"]
   put "false" into tNow["1down"]
   if mouse(1) is "down" then put "true" into tNow["1down"] -- for preview logic
   put "false" into tNow["3down"]
   if mouse(3) is "down" then put "true" into tNow["3down"] -- for selection logic
   -- (1a) location of mouse & selection indicators (since we're here)
   put empty into tNow["inside"]
   if pHist["3down"] is false and tNow["3down"] is true then -- reset selection when button down, otherwise retain
      put empty into tNow["nodeSelected"]
      put empty into tNow["linkSelected"]
      set the visible of button "hideButt" to false
   else
      put pHist["nodeSelected"] into tNow["nodeSelected"]
      put pHist["linkSelected"] into tNow["linkSelected"]
   end if
   repeat for each word tType in "nodes links"
      repeat for each key tNum in pGUI[tType]
         -- find out if the mouse is inside of a graph element
         -- within() doesn't depend on the rect, so how it treats negative space is more intuitive
         if within(pGUI[tType][tNum]["graphic"],the mouseloc) then
            put tNum into tNow["inside"]
         end if
         -- clear hilite; will be reapplied later if element still selected
         if tType is "nodes" and tNum is not among the items of pHist["nodeSelected"] then set the showborder of pGUI[tType][tNum]["graphic"] to false
         if tType is "links" and tNum is not among the items of pHist["linkSelected"] then  set the foregroundColor of pGUI[tType][tNum]["graphic"] to "0,220,220"
         -- selection box
         if tNow["3down"] and intersect(pGUI[tType][tNum]["graphic"],graphic "selectBox","pixels") then
            -- add any new selection to lists
            if tType is "nodes" and tNum is not among the items of tNow["nodeSelected"] and tNum is not pFocus then 
               --               put tNum & "," after tNow["nodeSelected"]
               put tNum into item (the number of items of tNow["nodeSelected"])+1 of tNow["nodeSelected"]
               set the visible of button "hideButt" to true
            end if
            if tType is "links" and tNum is not among the items of tNow["linkSelected"] then 
               --               put tNum & "," after tNow["linkSelected"]
               put tNum into item (the number of items of tNow["linkSelected"])+1 of tNow["linkSelected"]
               set the visible of button "hideButt" to true
            end if
         end if-- if 3down is true & intersection
      end repeat
   end repeat
   -- auto-select any links attached to a selected node
   repeat for each item tNode in tNow["nodeSelected"]
      --      put listOfLinks(tNode) into tLinks -- ! this is a pain with the current organization, but it's short and easy to replicate
      -- pGUI[nodes][#][abutFlow/Dive/Rise]=#,# cr #,# (link rec),(node rec)
      repeat for each word tKind in "abutFlow abutDive abutRise"
         repeat for each line tConnection in pGUI["nodes"][tNode][tKind]
            put item 1 of tConnection into tCon
            if tCon is not among the items of tNow["linkSelected"] then
               put tCon into item (the number of items of tNow["linkSelected"])+1 of tNow["linkSelected"]
            end if
         end repeat
      end repeat
   end repeat
   -- hilite selected elements
   repeat for each item tNum in tNow["nodeSelected"]
      set the showborder of pGUI["nodes"][tNum]["graphic"] to true
   end repeat
   repeat for each item tNum in tNow["linkSelected"]
      set the foregroundColor of pGUI["links"][tNum]["graphic"] to white
   end repeat
   put tNow["nodeSelected"] & cr & tNow["linkSelected"] into field "showMe" -- ! for development
   -- selection box calculation
   put the mouseLoc into tNow["moving"]
   put pHist["fixed"] into tNow["fixed"]
   
   
   -- (1b) compare old to new
   if pHist["1down"] is false and tNow["1down"] is true then
      -- button 1 just transitioned from up to down 
      put tNow["inside"] into p1Down -- becomes "anchor"
   end if
   if pHist["3down"] is false and tNow["3down"] is true then
      -- button 3 just transitioned from up to down
      put the mouseLoc into tNow["fixed"] -- becomes fixed point for selectBox
      set the layer of graphic "selectBox" to top
      set the visible of graphic "selectBox" to true
   end if
   if pHist["3down"] is true and tNow["3down"] is false then
      -- button 3 just transitioned from down to up
      put empty into tNow["fixed"] -- no more selectBox
      set the visible of graphic "selectBox" to false
   end if
   put pHist["fixed"] into tStuff["point1"]
   put tNow["moving"] into tStuff["point2"]
   -- ! there was an error where fixed would be empty the first time or something like that
   if tStuff["point1"] is not empty then set the rect of graphic "selectBox" to twoPointBox(tStuff)
   if tNow["3down"] is not true then set the rect of graphic "selectBox" to "0,0,0,0" -- otherwise it's still there messing with stuff like a ghost
   if tNow["tooltip"] is true and tNow["inside"] is a number then
      -- fill and resize the field
      if tNow["inside"] is among the keys of pGUI["nodes"] then
         put pGUI["nodes"][tNow["inside"]]["displayString"] into field "tooltipField"
      else if tNow["inside"] is among the keys of pGUI["links"] then
         put pGUI["links"][tNow["inside"]]["weight"] into field "tooltipField"
      end if
      set the height of field "tooltipField" to the formattedHeight of word 1 to -1 of field "tooltipField"
      set the layer of field "tooltipField" to top
      set the visible of field "tooltipField" to true
   else
      set the visible of field "tooltipField" to false
   end if
   
   -- (1c) if there's an anchor node, track new areas entered
   if p1Down is empty then
      -- either not inside a node, or mouse not down, or both
      put empty into p1Enter
   else if (pHist["inside"] is not empty) and (tNow["inside"] is empty) then
      -- just entered background
      put "background" into p1Enter
   else if pHist["inside"] is not tNow["inside"] then
      -- just entered a graph element
      put tNow["inside"] into p1Enter
   end if
   
   -- (2) build preview request
   -- defaults to "nothing"
   put "nothing" into tPreview
   if p1Down is among the keys of pGUI["nodes"] then
      -- anchor and target
      if p1Enter is among the keys of pGUI["nodes"] and p1Enter is not p1Down then 
         put p1Down & "," & p1Enter into tPreview
      else if p1Enter is p1Down then
         put p1Down & "," & "info" into tPreview
      end if
      -- link can't be target
      if p1Enter is among the keys of pGUI["links"] then put "nothing" into tPreview    
      if p1Enter is empty then 
         if p1Down is among the keys of pGUI["nodes"] then
            if p1Down is pFocus then
               put "nothing" into tPreview
            else
               put p1Down into tPreview
            end if
         else
            put "nothing" into tPreview
         end if
      end if
      if p1Enter is "background" and p1Down is among the keys of pGUI["nodes"] then
         put "nothing" into tPreview
         if item 1 of the mouseLoc < item 1 of the rect of pGUI["nodes"][p1Down]["graphic"] then put p1Down & ",left" into tPreview
         if item 1 of the mouseLoc > item 3 of the rect of pGUI["nodes"][p1Down]["graphic"] then put p1Down & ",right" into tPreview
      end if
   end if
   
   -- ! for development
   repeat for each key tKey in tNow
      put tKey & ":" && tNow[tKey] & cr after tBlerg
   end repeat
   put "p1Down:" && p1Down & cr after tBlerg
   put "p1Enter:" && p1Enter & cr after tBlerg
   put "preview:" && tPreview after tBlerg
   put tBlerg into field "viewMouse"
   
   put false into tCommit
   -- button 1 just transitioned from down to up while there's an anchor
   if p1Down is not empty and pHist["1down"] is true and tNow["1down"] is false then 
      -- if mouse(1) never returns "down" then all the above is skipped and s1Down&s1Enter stay empty
      -- the first time mouse(1) is down, 'inside' is put into s1Down (# if in a graph part, empty otherwise)
      -- as long as s1Down stays empty nothing happens, and s1Enter is emptied out just in case
      -- when mouse(1) first shows down, and a # is in 'inside', then s1Down gets it
      -- s1Enter starts checking if 'inside' changes, but stays empty
      -- when 'inside' changes, while s1Down is not empty, then the new # goes in s1Enter
      -- if the mouse never left the anchor place, then s1Enter stayed empty
      -- if the mouse returned to the anchor place, then s1Enter has its #   
      -- therefore
      -- if s1Enter is empty, the user clicked, so change focus
      -- if s1Enter is background or #, the mouse is previewing
      -- background: above/below node = nothing
      -- background: right = new out-link-node
      -- background: left = new node-link-in
      -- #: link = nothing
      -- #: node = new series of nodes & links
      -- info: = open node info
      put true into tCommit
      put tPreview & cr before field "viewCommitments"   -- ! for development
      put empty into p1Down
      put empty into p1Enter
   end if
   put tNow into pHist
   -- preview is a message to the frontend to preview a change, if appropriate
   -- previewAndChange() will return whatever the outcome of that logic is
   -- goes in: nothing OR # OR #,# OR #,left OR #,right OR #,info
   -- comes out: nothing OR a properly formatted change request array
   put previewAndChange(tPreview,pGUI,pNode) into tRequest
   if tRequest is not "nothing" and tCommit is true then 
      return tRequest
   else
      return "nothing"
   end if
end mouseTracker

function previewAndChange pToDo,pGUI,pNode -- returns "nothing" or array with change request
   put "function previewAndChange" into xX["write"];    devLog xX
   -- pToDo = nothing OR # OR #,# OR #,left OR #,right OR #,info
   -- pGUI = array of info necessary for display, preview and change
   -- pNode = display size of nodes in pixels   
   
   if pToDo is "nothing" then
      set the visible of graphic "preFlow1" to false
      set the visible of field "preState" to false
      set the visible of field "preChange" to false
      set the visible of graphic "preFlow2" to false
      set the visible of graphic "preFocus" to false
      set the visible of widget "preInfo" to false
      return "nothing"
   end if
   -- expand node to view/edit info
   if item 2 of pToDo is "info" then
      put pGUI["nodes"][item 1 of pToDo]["horz"] & "," & pGUI["nodes"][item 1 of pToDo]["vert"] into tSpot
      set the location of widget "preInfo" to tSpot
      --      set the layer of widget "preInfo" to bottom
      set the visible of widget "preInfo" to true
      put item 1 of pToDo into tWhatever["info"]
      
      set the visible of graphic "preFlow1" to false
      set the visible of field "preState" to false
      set the visible of field "preChange" to false
      set the visible of graphic "preFlow2" to false
      set the visible of graphic "preFocus" to false
      return tWhatever
   else
      set the visible of widget "preInfo" to false
   end if
   -- shift focus to another node
   if pToDo is a number then
      put pGUI["nodes"][pToDo]["horz"] & "," & pGUI["nodes"][pToDo]["vert"] into tSpot
      set the location of graphic "preFocus" to tSpot
      set the visible of graphic "preFocus" to true
      put pToDo into tWhatever["focus"]
      return tWhatever
   else
      set the visible of graphic "preFocus" to false
   end if
   ----------------------------------- research all conditions -------------------------
   -- tUno=# (always anchor)
   -- tDos=# left right (always target)
   -- tStartAtDos=true false
   -- adjacent=false or # (of link)
   -- unoType=state change
   -- dosType=state change
   -- sameType=true false
   put item 1 of pToDo into tUno
   put item 2 of pToDo into tDos
   -- link from uno-to-dos or dos-to-uno
   put false into tStartAtDos
   if tDos is "left" then
      put true into tStartAtDos
   else if tDos is a number then
      -- use existing drawing to figure out flow direction
      put the rect of pGUI["nodes"][tUno]["graphic"] into tUnoRect
      put the rect of pGUI["nodes"][tDos]["graphic"] into tDosRect
      if not (item 1 of tUnoRect < item 3 of tDosRect) then put true into tStartAtDos
   end if
   -- node types
   put pGUI["nodes"][tUno]["type"] into tUnoType
   put pGUI["nodes"][tDos]["type"] into tDosType
   if tUnoType is tDosType then
      put true into tSameType
   else
      put false into tSameType
   end if
   -- adjacency
   -- link,node
   put false into tAdjacent
   put false into tDownish
   put false into tUpish
   repeat for each line tLine in pGUI["nodes"][tUno]["abutFlow"]
      if tDos is item 2 of tLine then put item 1 of tLine into tAdjacent
   end repeat
   repeat for each line tLine in pGUI["nodes"][tUno]["abutDive"]
      if pGUI["case"] is item 2 of tLine then put item 1 of tLine into tDownish
   end repeat
   repeat for each line tLine in pGUI["nodes"][tUno]["abutRise"]
      if pGUI["case"] is item 2 of tLine then put item 1 of tLine into tUpish
   end repeat
   ------------------------------ end condition research -------------------------------
   ------------------------------ geometry help -----------------------------------
   put pNode / 2 into tHalfNode
   put the mouseLoc into tMoving
   put (item 2 of tMoving - pNode) into item 2 of tMoving
   if tDos is a number then
      -- two fixed nodes
      if tStartAtDos is false then
         put (pGUI["nodes"][tUno]["horz"] + tHalfNode) into tStartH
         put pGUI["nodes"][tUno]["vert"] into tStartV
         put (pGUI["nodes"][tDos]["horz"] - tHalfNode) into tEndH
         put pGUI["nodes"][tDos]["vert"] into tEndV
      else
         put (pGUI["nodes"][tDos]["horz"] + tHalfNode) into tStartH
         put pGUI["nodes"][tDos]["vert"] into tStartV
         put (pGUI["nodes"][tUno]["horz"] - tHalfNode) into tEndH
         put pGUI["nodes"][tUno]["vert"] into tEndV
      end if
   else if tStartAtDos is false then
      -- uno fixed, dos is "left" or "right", tStartAtDos has to be false if "right"
      put (pGUI["nodes"][tUno]["horz"] + tHalfNode) into tStartH
      put pGUI["nodes"][tUno]["vert"] into tStartV
      put (item 1 of tMoving - tHalfNode) into tEndH
      put item 2 of tMoving into tEndV
   else
      put (item 1 of tMoving + tHalfNode) into tStartH
      put item 2 of tMoving into tStartV
      put (pGUI["nodes"][tUno]["horz"] - tHalfNode) into tEndH
      put pGUI["nodes"][tUno]["vert"] into tEndV
   end if
   put tStartH & "," & tStartV into tStartCoord
   put tEndH & "," & tEndV into tEndCoord
   put tStartCoord & cr & tEndCoord into tLineCoord
   put lineMidpoint(tLineCoord) into tMidCoord -- mathamagics.livecode
   -- offset midpoint, normal to line, above midpoint vertical
   -- line will always be left-to-right, so offset just goes +H relative to midpoint
   put 0 & "," & pNode into tOffCoord
   put rotateCoord(tOffCoord,tLineCoord) into tOffCoord -- mathamagics.livecode
   put (item 1 of tMidCoord + item 1 of tOffCoord) into item 1 of tOffCoord
   put (item 2 of tMidCoord + item 2 of tOffCoord) into item 2 of tOffCoord
   -- room around offset midpoint for a preview node
   put (item 1 of tOffCoord - tHalfNode) & "," & (item 2 of tOffCoord) into tMidLeft
   put (item 1 of tOffCoord + tHalfNode) & "," & (item 2 of tOffCoord) into tMidRight
   -- location(s) of other node when previewing two
   -- ? not sure if I actually used these two
   put (item 1 of tOffCoord + pNode) & "," & (item 2 of tOffCoord) into tOffCoordRight
   put (item 1 of tOffCoord - pNode) & "," & (item 2 of tOffCoord) into tOffCoordLeft
   -- location when preview following the mouse
   put (item 1 of the mouseLoc) & "," & (item 2 of the mouseLoc - pNode) into tPlace
   put (item 1 of tPlace + tHalfNode) & "," & (item 2 of tPlace) into tStart
   put (pGUI["nodes"][tNode]["horz"] - tHalfNode) & "," & pGUI["nodes"][tNode]["vert"] into tEnd
   put tStart & cr & tEnd into tLine
   ------------------------------ end geometry help ------------------------------
   -- show a single flow between the nodes
   if tUno is a number and tDos is a number and tSameType is false and tAdjacent is false then
      set the points of graphic "preFlow1" to tLineCoord
      set the visible of graphic "preFlow1" to true
      set the visible of graphic "preFlow2" to false
      set the visible of field "preState" to false
      set the visible of field "preChange" to false
      -- format graph change request
      --      put "user" into tTemp["a"]["from"]
      -- ! don't have a return address for area yet, but will need that
      put"flow_btwn_diffType" into tTemp[0]["act"]
      put "flow" into tTemp["a"]["type"]
      if tStartAtDos is false then
         put tUno into tTemp["a"]["backward"]
         put tDos into tTemp["a"]["forward"]
      else
         put tDos into tTemp["a"]["backward"]
         put tUno into tTemp["a"]["forward"]
      end if 
      return tTemp
   end if
   -- show a single node, and two flows, between the nodes
   if tUno is a number and tDos is a number and tSameType is true then
      set the points of graphic "preFlow1" to (tStartCoord & cr & tMidLeft)
      set the points of graphic "preFlow2" to (tMidRight & cr & tEndCoord)
      set the visible of graphic "preFlow1" to true
      set the visible of graphic "preFlow2" to true
      if tUnoType is "state" then
         set the location of field "preChange" to tOffCoord
         set the visible of field "preChange" to true
         set the visible of field "preState" to false
      else
         set the location of field "preState" to tOffCoord
         set the visible of field "preChange" to false
         set the visible of field "preState" to true
      end if
      -- format graph change request
      --      put "user" into tTemp["a"]["from"]
      -- ! don't have a return address for area yet, but will need that
      /*
      x[a][type]=state/change
      x[b][type]=flow
      x[b][backward]=#/ltr
      x[b][forward]=#/ltr
      x[c][type]=flow
      x[c][backward]=#/ltr
      x[c][forward]=#/ltr
      */
      put "span_detached_sameType" into tTemp[0]["act"]
      if tUnoType is "state" then
         put "change" into tTemp["a"]["type"]
      else
         put "state" into tTemp["a"]["type"]
      end if
      --      put "user" into tTemp["b"]["from"]
      put "flow" into tTemp["b"]["type"]
      put "flow" into tTemp["c"]["type"]
      if tStartAtDos is false then
         put tUno into tTemp["b"]["backward"]
         put "a" into tTemp["b"]["forward"]
         put "a" into tTemp["c"]["backward"]
         put tDos into tTemp["c"]["forward"]
      else
         put tDos into tTemp["b"]["backward"]
         put "a" into tTemp["b"]["forward"]
         put "a" into tTemp["c"]["backward"]
         put tUno into tTemp["c"]["forward"]
      end if 
      return tTemp
   end if
   -- from one node to neighbor, so type is different
   -- must show state and change, in correct order
   -- must show flow, on correct side
   if tUno is a number and tDos is a number and not (tAdjacent is false) then ------------------------------------------------
      -- flow preview attached to uno (anchor)
      set the visible of graphic "preFlow1" to true
      set the visible of graphic "preFlow2" to false
      -- format graph change request
      -- state node [a], change node [b], three flows [c][d][e]
      -- hide existing flow [#]
      put "inject_btwn_diffType" into tTemp[0]["act"]
      put "state" into tTemp["a"]["type"]
      put "change" into tTemp["b"]["type"]
      put "flow" into tTemp["c"]["type"]
      put "flow" into tTemp["d"]["type"]
      put "flow" into tTemp["e"]["type"]
      put tAdjacent into tTemp["hide"]
      if tStartAtDos is false and tUnoType is "state" then
         set the points of graphic "preFlow1" to (tStartCoord & cr & tMidLeft)
         set the location of field "preChange" to tOffCoord
         set the location of field "preState" to ((item 1 of tOffCoord + pNode) & "," & item 2 of tOffCoord)
         set the visible of field "preChange" to true
         set the visible of field "preState" to true
         -- format graph change request
         -- uno > flow c > change b > flow d > state a > flow e > dos
         put tUno into tTemp["c"]["backward"]
         put "b" into tTemp["c"]["forward"]
         put "b" into tTemp["d"]["backward"]
         put "a" into tTemp["d"]["forward"]
         put "a" into tTemp["e"]["backward"]
         put tDos into tTemp["e"]["forward"]
      else if tStartAtDos is false and tUnoType is "change" then
         set the points of graphic "preFlow1" to (tStartCoord & cr & tMidLeft)
         set the location of field "preState" to tOffCoord
         set the location of field "preChange" to ((item 1 of tOffCoord + pNode) & "," & item 2 of tOffCoord)
         set the visible of field "preChange" to true
         set the visible of field "preState" to true
         -- format graph change request
         -- uno > flow c > state a > flow d > change b > flow e > dos
         put tUno into tTemp["c"]["backward"]
         put "a" into tTemp["c"]["forward"]
         put "a" into tTemp["d"]["backward"]
         put "b" into tTemp["d"]["forward"]
         put "b" into tTemp["e"]["backward"]
         put tDos into tTemp["e"]["forward"]
      else if tStartAtDos is true and tDosType is "state" then
         set the points of graphic "preFlow1" to (tMidRight & cr & tEndCoord)
         set the location of field "preState" to tOffCoord
         set the location of field "preChange" to ((item 1 of tOffCoord - pNode) & "," & item 2 of tOffCoord)
         set the visible of field "preChange" to true
         set the visible of field "preState" to true
         -- format graph change request
         -- dos > flow e > change b > flow d > state a > flow c > uno
         put tDos into tTemp["e"]["backward"]
         put "b" into tTemp["e"]["forward"]
         put "b" into tTemp["d"]["backward"]
         put "a" into tTemp["d"]["forward"]
         put "a" into tTemp["c"]["backward"]
         put tUno into tTemp["c"]["forward"]       
      else if tStartAtDos is true and tDosType is "change" then
         set the points of graphic "preFlow1" to (tMidRight & cr & tEndCoord)
         set the location of field "preChange" to tOffCoord
         set the location of field "preState" to ((item 1 of tOffCoord - pNode) & "," & item 2 of tOffCoord)
         set the visible of field "preChange" to true
         set the visible of field "preState" to true
         -- format graph change request
         -- dos > flow e > state a > flow d > change b > flow c > uno
         put tDos into tTemp["e"]["backward"]
         put "a" into tTemp["e"]["forward"]
         put "a" into tTemp["d"]["backward"]
         put "b" into tTemp["d"]["forward"]
         put "b" into tTemp["c"]["backward"]
         put tUno into tTemp["c"]["forward"]
      end if
      return tTemp
   end if
   -- show "left" or "right" node(s), as appropriate, and flow on correct side --------------------------------
   if tDos is "left" or tDos is "right" then
      -- need a flow [a] and a state [b]
      -- need a dive/rise [c]
      -- maybe a change [d] and another flow [e]
      -- maybe hide existing dive/rise [#]
      -- tUpish will have rise if "right"
      -- tDownish will have dive if "left"
      put "flow_branch" into tTemp[0]["act"]
      put "flow" into tTemp["a"]["type"]
      put "state" into tTemp["b"]["type"]
      if tDos is "right" and tUnoType is "change" then -- can't be #,# if script got this far
         set the points of graphic "preFlow1" to tLineCoord
         set the location of field "preState" to tMoving
         set the visible of field "preChange" to false
         set the visible of field "preState" to true
         set the visible of graphic "preFlow1" to true
         set the visible of graphic "preFlow2" to false
         -- format graph change request
         -- uno > flow a > state b > rise c > case
         put tUno into tTemp["a"]["backward"]
         put "b" into tTemp["a"]["forward"]
         put "rise" into tTemp["c"]["type"]
         put "b" into tTemp["c"]["backward"]
         put pGUI["case"] into tTemp["c"]["forward"]
      else if tDos is "right" and tUnoType is "state" then
         set the points of graphic "preFlow1" to tLineCoord
         set the location of field "preChange" to tMoving
         set the location of field "preState" to ((item 1 of tMoving + pNode) & "," & item 2 of tMoving)
         set the visible of field "preChange" to true
         set the visible of field "preState" to true
         set the visible of graphic "preFlow1" to true
         set the visible of graphic "preFlow2" to false
         -- format graph change request
         -- uno > flow a > change d > flow e > state b > rise c > case
         -- since this is a state, going right, it might already have a rise link
         put tUno into tTemp["a"]["backward"]
         put "d" into tTemp["a"]["forward"]
         put "change" into tTemp["d"]["type"]
         put "flow" into tTemp["e"]["type"]
         put "d" into tTemp["e"]["backward"]
         put "b" into tTemp["e"]["forward"]
         put "rise" into tTemp["c"]["type"]
         put "b" into tTemp["c"]["backward"]
         put pGUI["case"] into tTemp["c"]["forward"]
         if not (tUpish is false) then 
            put tUpish into tTemp["hide"]
         end if
         --         if tUpish is false then
         --            put "rise" into tTemp["c"]["type"]
         --            put "b" into tTemp["c"]["backward"]
         --            put pGUI["case"] into tTemp["c"]["forward"]
         --         else
         --            put "b" into tTemp[tUpish]["backward"]
         --            put pGUI["case"] into tTemp[tUpish]["forward"]
         --         end if
         
      else if tDos is "left" and tUnoType is "change" then
         set the points of graphic "preFlow1" to tLineCoord
         set the location of field "preState" to tMoving
         set the visible of field "preChange" to false
         set the visible of field "preState" to true
         set the visible of graphic "preFlow1" to true
         set the visible of graphic "preFlow2" to false
         -- format graph change request
         -- case > dive c > state b > flow a > uno
         put "dive" into tTemp["c"]["type"]
         put pGUI["case"] into tTemp["c"]["backward"]
         put "b" into tTemp["c"]["forward"]
         put "b" into tTemp["a"]["backward"]
         put tUno into tTemp["a"]["forward"]
      else if tDos is "left" and tUnoType is "state" then
         set the points of graphic "preFlow1" to tLineCoord
         set the location of field "preChange" to tMoving
         set the location of field "preState" to ((item 1 of tMoving - pNode) & "," & item 2 of tMoving)
         set the visible of field "preChange" to true
         set the visible of field "preState" to true
         set the visible of graphic "preFlow1" to true
         set the visible of graphic "preFlow2" to false
         -- format graph change request
         -- case > c > b > e > d > a > uno
         -- since this is a state, going left, it might already have a dive link
         --         if tDownish is false then
         --            put "dive" into tTemp["c"]["type"]
         --            put pGUI["case"] into tTemp["c"]["backward"]
         --            put "b" into tTemp["c"]["forward"]
         --         else
         --            put pGUI["case"] into tTemp[tDownish]["backward"]
         --            put "b" into tTemp[tDownish]["forward"]
         --         end if
         if not (tDownish is false) then 
            put tDownish into tTemp["hide"]
         end if
         put "dive" into tTemp["c"]["type"]
         put pGUI["case"] into tTemp["c"]["backward"]
         put "b" into tTemp["c"]["forward"]
         put "flow" into tTemp["e"]["type"]
         put "b" into tTemp["e"]["backward"]
         put "d" into tTemp["e"]["forward"]
         put "change" into tTemp["d"]["type"]
         put "d" into tTemp["a"]["backward"]
         put tUno into tTemp["a"]["forward"]
      end if
      return tTemp
   end if
end previewAndChange

on graphManager pDo -- ! will be more complicated when not just a test
   put "on graphManager" into xX["write"];    devLog xX
   -- makes any changes, then calls draw functions, which call display functions
   -- pDo empty OR #,# OR #,left OR #,right OR #
   -- make changes if passed in parameter pDo
   if pDo is empty then
      -- whatevs
   else if pDo is a number then
      -- #
      put pDo into sNowFocus
   else if item 2 of pDo is a number then
      -- #,#
      -- check for existing link between these two nodes
      -- if there is already a link, that will dictate which way to go
      put item 1 of pDo into tAnchor
      put item 2 of pDo into tTarget
      put empty into tWas
      repeat for each word tType in "next prev"
         repeat for each item tPointer in sGraphData["nodes"][tAnchor][tType]
            put item 1 of sGraphData["links"][tPointer][tType] into tTest
            if tTest is tTarget then 
               -- tAnchor has a pointer to a link with a pointer to tTarget
               -- delete link
               delete variable sGraphData["links"][tPointer]
               -- delete pointer to link in tAnchor
               delete item itemOffset(tPointer,sGraphData["nodes"][tAnchor][tType]) of sGraphData["nodes"][tAnchor][tType]
               -- delete pointer to link in tTarget
               if tType is "next" then delete item itemOffset(tPointer,sGraphData["nodes"][tTarget]["prev"]) of sGraphData["nodes"][tTarget]["prev"]
               if tType is "prev" then delete item itemOffset(tPointer,sGraphData["nodes"][tTarget]["next"]) of sGraphData["nodes"][tTarget]["next"]
               put tType into tWas
            end if
         end repeat
      end repeat
      -- link found and deleted means tWas has the direction for the new link(s) relative to tAnchor
      -- link not found means that the correct direction has to be discovered
      if tWas is empty then
         -- assume anchor-to-target, unless their layer order prevents that 
         -- ! layer order is a proxy for actually checking if the link creates a cycle
         -- ! doing it this way will have undesirable edge cases
         put sGraphDrawing["nodes"][tAnchor]["layer"] into tAnchorLay
         put sGraphDrawing["nodes"][tTarget]["layer"] into tTargetLay
         if tTargetLay < tAnchorLay then
            put tTarget into tStart
            put tAnchor into tEnd
         else
            put tTarget into tEnd
            put tAnchor into tStart
         end if
      else -- tWas not empty
         if tWas is "next" then
            put tAnchor into tStart
            put tTarget into tEnd
         else
            put tTarget into tStart
            put tAnchor into tEnd
         end if
      end if
      -- now we know that the link(s) should go from node tStart to node tEnd
      -- and that there's no existing link in the way
      -- need new link, new node, and new link
      put sGraphData["lastRec"] into tRec      
      put tStart & "," after sGraphData["links"][tRec+1]["prev"]
      put tRec+2 & "," after sGraphData["links"][tRec+1]["next"]
      
      put tRec+1 & "," after sGraphData["nodes"][tRec+2]["prev"]
      put tRec+3 & "," after sGraphData["nodes"][tRec+2]["next"]
      
      put tRec+2 & "," after sGraphData["links"][tRec+3]["prev"]
      put tEnd & "," after sGraphData["links"][tRec+3]["next"]
      
      put tRec+3 & "," after sGraphData["nodes"][tEnd]["prev"]
      put tRec+1 & "," after sGraphData["nodes"][tStart]["next"]      
      put tRec+3 into sGraphData["lastRec"] 
   else
      -- #,left/right
      put item 1 of pDo into tNode
      put item 2 of pDo into tDir
      if tDir is "left" then
         put sGraphData["lastRec"] into tRec
         put tRec+1 & "," after sGraphData["nodes"][tNode]["prev"]
         put tNode & "," after sGraphData["links"][tRec+1]["next"]
         put tRec+2 & "," after sGraphData["links"][tRec+1]["prev"]
         put tRec+1 & "," after sGraphData["nodes"][tRec+2]["next"]
         put tRec+2 into sGraphData["lastRec"]
      else if tDir is "right" then
         put sGraphData["lastRec"] into tRec
         put tRec+1 & "," after sGraphData["nodes"][tNode]["next"]
         put tNode & "," after sGraphData["links"][tRec+1]["prev"]
         put tRec+2 & "," after sGraphData["links"][tRec+1]["next"]
         put tRec+1 & "," after sGraphData["nodes"][tRec+2]["prev"]
         put tRec+2 into sGraphData["lastRec"]
      end if
   end if
   middleOut sGraphData
end graphManager

function writeInstructions @pMain,@pShort,pTopo,pNoVisit
   put "function writeInstructions" into xX["write"];    devLog xX
   repeat for each key tDoc in pTopo
      put empty into tInstructions
      put empty into tFootnotes -- array[tDoc]=1,2,3,n note rec in footnote order
      put empty into tIndent
      put empty into tScope
      repeat for each item tRec in pTopo[tDoc]
         put empty into tTheNotes
         -- use OPEN label if this is the first reference to a particular container node, and increase indent
         -- use CLOSE label if this is the second reference, and decrease indent
         if pShort[tDoc][tRec]["read"] is not empty and pShort[tDoc][tRec]["bulk"] is not empty then
            if tRec is among the items of tScope then
               -- container node, and second time listed
               put tDoc into tStuff["doc"]
               put tRec into tStuff["rec"]
               put cr & tIndent && "CLOSE" && stepString(pMain,tStuff) after tInstructions
               delete char -1 of tIndent
            else -- container node, first time listed
               put tDoc into tStuff["doc"]
               put tRec into tStuff["rec"]
               put cr & tIndent && itemOffset(tRec,pTopo[tDoc]) && "OPEN" && stepString(pMain,tStuff) after tInstructions
               put tRec & "," after tScope
               put "-" after tIndent
            end if -- tRec among tScope
         else -- not a container node
            put tDoc into tStuff["doc"]
            put tRec into tStuff["rec"]
            put cr & tIndent && itemOffset(tRec,pTopo[tDoc]) && stepString(pMain,tStuff) after tInstructions
         end if -- read and bulk not empty
         -- ! this logic isn't applicable since bond links arnen't used anymore
         -- build the footnote list
         --         if tRec is among the keys of sNoteList[tDoc] then
         --            -- this step has one or more notes
         --            repeat for each item tNote in sNoteList[tDoc][tRec]
         --               if tNote is among the items of tFootnotes[tDoc] then
         --                  -- this note, bonded to tRec, already has a footnote position
         --                  put itemOffset(tNote,tFootnotes[tDoc]) & "," after tTheNotes
         --               else
         --                  -- this note, bonded to tRec, does not yet have a footnote position
         --                  put tNote & "," after tFootnotes[tDoc]
         --                  put itemOffset(tNote,tFootnotes[tDoc]) & "," after tTheNotes
         --               end if
         --            end repeat
         --            if char -1 of tTheNotes is "," then delete char -1 in tTheNotes
         --            put " *" & tTheNotes & cr after tInstructions
         --         end if
      end repeat -- tRec in pTopo[tDoc]
      -- ! also not applicable anymore, since no more bond links
      --      put cr & "NOTES" after tInstructions
      --      repeat for each item tFoot in tFootnotes[tDoc]
      --         put cr & itemOffset(tFoot,tFootnotes[tDoc]) && stepString(tDoc,tFoot) after tInstructions
      --      end repeat -- tFoot in tFootnotes
      -------- orphans ------------------
      if pNoVisit[tDoc] is not empty then
         put empty into tRollCall
         repeat for each item tOrphan in pNoVisit[tDoc]
            if pShort[tDoc][tOrphan]["type"] is among the words of "state change" then
               put tDoc into tStuff["doc"]
               put tOrphan into tStuff["rec"]
               put cr & stepString(pMain,tStuff) after tRollCall
            end if
         end repeat
         if tRollCall is not empty then
            put cr & "ORPHANS" after tInstructions
            put tRollCall after tInstructions
         end if
      end if
   end repeat -- tDoc in pTopo
   filter tInstructions without empty
   --   put tInstructions into field "textInstr" stack "primary"
   --   if tInstructions is empty then put \
         --         "Network unclear. At least one node must have both dive and rise links." into field "textInstr" stack "primary"
   return tInstructions
end writeInstructions

function summarizeResources @pMain,@pSketch,@pResources,pDoc
   put "function summarizeResources" into xX["write"];    devLog xX
   -- sMain,sScopeSketch,sResources,sNowDoc
   -- for each key in sScopeSketch[sNowDoc]
   -- build summary string, put in tArray[blerg]
   -- for each key in sScopeSketch[sNowDoc]
   -- replace top with relevant summary string
   -- string
   -- OPEN whatever
   -- IN
   -- THRU
   -- OUT
   -- MISC
   -- second time
   -- repeat until all recs in tStrings visited
   -- start with "rec" 0
   -- replace a number alone on a line with it's string and some dashes based on counter
   -- next cycle will have new text from the string added, so replace numbers alone on lines
   
   --   build a string to summarize each case node
   put empty into tStrings
   repeat for each key tCase in pSketch[pDoc]
      if tCase = 0 then
         -- maybe just don't print anything
      else
         put pDoc into tStuff["doc"]
         put tCase into tStuff["rec"]
         put "OPEN" && stepString(pMain,tStuff) & cr into tStrings[tCase]
      end if
      put "IN-PUT" & cr after tStrings[tCase]
      repeat for each item tN in pSketch[pDoc][tCase]["in"]
         -- if this also has role top, just put its rec alone on a line
         if tN is among the keys of pSketch[pDoc] then
            put tN & cr after tStrings[tCase]
         else
            put pDoc into tStuff["doc"]
            put tN into tStuff["rec"]
            put pResources[pDoc][tN]["totDemand"] && "x" && stepString(pMain,tStuff) & cr after tStrings[tCase]
         end if
      end repeat
      put "THRU-PUT" & cr after tStrings[tCase]
      put empty into tData
      repeat for each item tH in pSketch[pDoc][tCase]["thru"]
         put pResources[pDoc][tH]["excess"] into tMuch
         if tMuch is not 0 and tMuch is not empty then 
            if tH is among the keys of pSketch[pDoc] then
               put tH & cr after tData
            else
               put pDoc into tStuff["doc"]
               put tH into tStuff["rec"]
               put tMuch && "x" && stepString(pMain,tStuff) & cr after tData
            end if
         end if
      end repeat
      if tData is empty then 
         put "supply=demand" & cr after tStrings[tCase]
      else
         put tData after tStrings[tCase]
      end if
      put "OUT-PUT" & cr after tStrings[tCase]
      repeat for each item tU in pSketch[pDoc][tCase]["out"]
         if tU is among the keys of pSketch[pDoc] then
            put tU & cr after tStrings[tCase]
         else
            put pDoc into tStuff["doc"]
            put tU into tStuff["rec"]
            put pResources[pDoc][tU]["totSupply"] && "x" && stepString(pMain,tStuff) & cr after tStrings[tCase]
         end if
      end repeat
      put "NOT-PUT" & cr after tStrings[tCase]
      repeat for each item tS in pSketch[pDoc][tCase]["solo"]
         if tS is among the keys of pSketch[pDoc] then
            put tS & cr after tStrings[tCase]
         else
            put pDoc into tStuff["doc"]
            put tS into tStuff["rec"]
            put pResources[pDoc][tS]["totSupply"] && "x" && stepString(pMain,tStuff) & cr after tStrings[tCase]
         end if
      end repeat
   end repeat -- tCase in pSketch[pDoc]
   -- build a bigger string with the case node summaries nested appropriately
   --   repeat for each key tKey in tStrings
   --      filter tStrings[tKey] without empty
   --   end repeat
   --   put tStrings[0] into tSummary -- 0 is a pseudo case to encase absolutely everything
   -- embed one string in another
   put " " into tIndent
   put the keys of pSketch[pDoc] into tAll
   replace cr with "," in tAll -- items instead of lines
   put tStrings[0] into tDisplay
   filter tDisplay without empty -- remove any trailing cr
   put tDisplay into tWorking
   put true into tAgain
   repeat while tAgain is true
      put false into tAgain
      put empty into tInserts
      put "-" before tIndent
      repeat with tJ = 1 to the number of lines of tWorking
         put line tJ of tWorking into tWorkIt
         replace " " with "" in tWorkIt
         replace "-" with "" in tWorkIt
         replace cr with "" in tWorkIt
         -- if tWorkIt has a rec then it should be just the clean rec now
         if tWorkIt is among the items of tAll then
            put tStrings[tWorkIt] into tInserts[tJ]["string"] -- so now array[line offset][string]=new string
            repeat with tJJ = 1 to the number of lines of tInserts[tJ]["string"]
               put tIndent before line tJJ of tInserts[tJ]["string"]
            end repeat
            put tWorkIt into tInserts[tJ]["rec"] -- so now array[line offset][rec]=num to replace
         end if
         if tJ = the number of lines of tWorking then
            -- the last line was just checked to see if it needed replacing
            put the keys of tInserts into tOrder
            sort tOrder numeric descending -- highest line offset to lowest
            repeat for each line tNext in tOrder
               put true into tAgain
               -- delete line
               -- insert new string before line
               delete line tNext of tWorking
               put tInserts[tNext]["string"] before line tNext of tWorking
            end repeat
         end if
      end repeat -- tJ
      put tWorking into tDisplay
   end repeat -- tAgain
   return tDisplay
end summarizeResources

on resizeStack pNewWidth, pNewHeight, pOldWidth, pOldHeight
   put "on resizeStack" into xX["write"];    devLog xX
   if the rect of this stack is the screenRect then
      set the visible of widget "iconMaximize" to false
      set the visible of widget "iconMediumsize" to true
   else
      set the visible of widget "iconMaximize" to true
      set the visible of widget "iconMediumsize" to false
   end if
   -- all of the layer information for all of the graph data in memory is calculated by middleOut
   -- so when the window resizes, displayManager updates the graphics based on what fits now
   refreshDisplay
end resizeStack
