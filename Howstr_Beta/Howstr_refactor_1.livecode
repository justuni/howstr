on menuPick pItemName
   -- ! at the moment, since only one doc can be in memory new is the same as close
   if pItemName is "New" then put "Close" into pItemName
   switch pItemName
      case "New"
         break
      case "Close"
         if field "savedField" stack "primary" is "unsaved" then
            answer "Close without saving?" with "Close" or "Cancel"
            switch it
               case "Close"
                  userClose
                  break
               case "Cancel"
                  exit menuPick
                  break
            end switch
         else
            userClose
         end if
         break
      case "Save"
         -- pass through to Save As if no filename
         if field "filepathField" stack "primary" is not empty then
            put field "filepathField" stack "primary" into tTheFile
            userSave tTheFile
            -- saved flag
            put "saved" into field "savedField" stack "primary"
            break
         end if
      case "Save As"
         -- get the file path for this stack
         put the effective filename of this stack into tPath
         set the itemDelimiter to slash
         -- if this is a standalone application running on a Mac, find the path to the .app file
         if the platform = "MacOS" and the environment = "standalone application" then
            repeat until last item of tPath contains ".app"
               delete last item of tPath
            end repeat
         end if
         -- if not on a Mac, remove the last item to get the path to the containing folder
         delete last item of tPath
         --Ask the user to choose a file
         ask file "Save As" with tPath
         --If the dialog is not cancelled put the path to the selected file into a variable
         if the result is not "cancel" then
            -- make sure it's the right kind of file
            -- ! this won't work if the user selects a file with a different extension
            if it ends with ".plat" then
               put it into tTheFile
            else if it contains "." then
               answer "filename contains a period"
               break
            else
               put it & ".plat" into tTheFile
            end if
            userSave tTheFile
         end if
         -- saved flag
         put "saved" into field "savedField" stack "primary"
         put tTheFile into field "filepathField" stack "primary"
         break
      case "Open"
         if field "savedField" stack "primary" is "unsaved" then
            answer "Close without saving?" with "Close" or "Cancel"
            switch it
               case "Close"
                  userClose
                  break
               case "Cancel"
                  exit menuPick
                  break
            end switch
         else
            userClose
         end if
         -- get the file path for this stack
         put the effective filename of this stack into tPath
         set the itemDelimiter to slash
         -- if this is a standalone application running on a Mac, find the path to the .app file
         if the platform = "MacOS" and the environment = "standalone application" then
            repeat until last item of tPath contains ".app"
               delete last item of tPath
            end repeat
         end if
         -- if not on a Mac, remove the last item to get the path to the containing folder
         delete last item of tPath
         --Ask the user to choose a file
         answer file "Select a file to open" with tPath
         if the result is not "Cancel" then
            if it ends with ".plat" or ".txt" then
               put it into tChosenFile
               userOpen tChosenFile
               -- filepath
               put tChosenFile into field "filepathField" stack "primary"
            else
               break
            end if
         end if
         -- this will overwrite the "unsaved" that the build handler flags
         -- since in this case there aren't any unsaved changes yet
         put "opened" into field "savedField" stack "primary"
         break
   end switch
end menuPick

ï»¿script "Howstr_refactor_1"
local sMain -- main[doc num][rec num][tag]data/pointers
local sMainShort -- mainShort[doc][visible rec][link or tag]link type & rec or tag:data (build in adjList)
local sNowDoc -- the document the user is currently seeing/editing
local sNowItem -- cr delimited list of records currently selected
local sExpanded -- comma-delimited list of expanded steps
local sThenItem -- cr delimited list of records previously selected
local sWasExpanded -- comma-delimited list of previously expanded steps
local sPointerTags -- space delimited list of platypus pointer categories
local sGraphics -- array of graphics, sGraphics[doc][rec]["longID"] and ["thePoints"]
local sDevEyes -- true if the "developer" radio button is checked, so show all info
local sTopoSort -- topological sort of the platypus file array[doc]=list of recs in order
local sNotVisited -- array[doc], use to track nodes in topoSort and kahnSort
local sNoteList -- array[doc][rec][notes]=list of notes; [rec][steps]=list of steps
local sResources -- array[doc][input/output][rec]=weight
local sVisited -- array[doc], used to track links traveled in resourceRollup
local sSomethingChanged -- true/false; used by supplyDemand to run gravitySort again
local sScope -- array[doc][0/1/2/3/n...][top/in/thru/out]=rec,rec,rec,etc...
local sScopeSketch -- array[doc][case][role]=rec,rec,rec... start at case 0, then each [top]

on preOpenStack
   -- controlling the defaultFolder; someone said to do this...so...
   set itemDelimiter to "/"
   set the defaultFolder to item 1 to -2 of (the effective filename of this stack)

   put "step myStep turn myTurn bond prev next skim read bulk trim" into sPointerTags
   put empty into sMain
   put 1 into sNowDoc
   put true into sMain[sNowDoc][0]["hide"]
   put 0 into sMain[sNowDoc][0][lastKey]
   put empty into sNowItem

   put "2,1" & cr & "3,1" & cr & "4,1" into sMain[sNowDoc][1]["step"]
   put "state" into sMain[sNowDoc][2]["type"]
   put "1,1" into sMain[sNowDoc][2]["myStep"]
   put "untitled project" into sMain[sNowDoc][3]["title"]
   put "1,1" into sMain[sNowDoc][3]["myStep"]
   put "500,10" into sMain[sNowDoc][4]["coord"]
   put "1,1" into sMain[sNowDoc][4]["myStep"]
   put 4 into sMain[sNowDoc][0][lastKey]

   -- setup the window -----------------------------------------------------
   --   set the minWidth of stack "primary" to 500
   --   set the minheight of stack "primary" to 500
   -- klaus said to set this once in the stack inspector

   -- initialize controls
   set the disabled of button "stateButt" stack "primary" to false
   set the disabled of button "changeButt" stack "primary" to false
   set the disabled of button "bondButt" stack "primary" to true
   set the disabled of button "flowButt" stack "primary" to true
   set the disabled of button "infoButt" stack "primary" to true
   set the disabled of button "fileButt" stack "primary" to true
   set the disabled of button "undoButt" stack "primary" to true
   set the disabled of button "redoButt" stack "primary" to true
   set the disabled of button "hideButt" stack "primary" to true
   set the disabled of button "diveButt" stack "primary" to true
   set the disabled of button "riseButt" stack "primary" to true
   put empty into field "filepathField" stack "primary"
   put "New" into field "savedField" stack "primary"
   put 100 into field "scaleField" stack "primary"
   put "search" into field "searchField" stack "primary"
   set the foregroundColor of field "searchField" stack "primary" to 200,200,200
   put the hilite of button "devRadio" stack "primary" into sDevEyes

   -- erase any leftover graphics ------------------------------------------
   -- this will erase everything in the group except floorRect
   put 0 into tControl
   repeat for the number of controls of group "graphicNetwork" of stack "primary"
      add one to tControl
      put the name of control tControl of group "graphicNetwork" of stack "primary" & cr after tList
   end repeat
   repeat for each line tLine in tList
      if "id" is among the words of tLine then delete tLine
   end repeat

   -- make sure the text instructions are empty ------------------------
   put empty into field "textInstr" stack "primary"

   -- setup the display controls -------------------
   -- floorRect is like a canvas
   -- the graphicNetwork group rect is like a window onto the canvas
   set the height of graphic "floorRect" group "graphicNetwork" stack "primary" to 1000
   set the width of graphic "floorRect" group "graphicNetwork" stack "primary" to 1000
   set the topLeft of graphic "floorRect" group "graphicNetwork" stack "primary" to netToWinCoord("0,0")
   put 262 into tLeft
   put 70 into tTop
   put the width of this stack - 2 into tRight
   put the height of this stack -2 into tBottom
   set the rect of group "graphicNetwork" stack "primary" to tLeft,tTop,tRight,tBottom
   set the rect of field "textInstr" stack "primary" to tLeft,tTop,tRight,tBottom
   set the rect of field "resourceField" stack "primary" to tLeft,tTop,tRight,tBottom

   -- rTree ----------------------------------------------------------------------
   set the editNodeOnDoubleClick of group "treeList" stack "primary" to false
   set the expandOnHilite of group "treeList" stack "primary" to false
   set the newNodeOnReturn of group "treeList" stack "primary" to false
   set the useContextMenu of group "treeList" stack "primary" to false

   render
end preOpenStack

on resizeStack cardWidth, cardHeight
   lock screen
   put cardWidth,cardHeight into tWindow
   put 2,70,260,(cardHeight-2) into tRect
   set the rect of group "treeList" of stack "primary" to tRect
   put 262,70,(cardWidth-2),(cardHeight-2) into tRect
   set the rect of group "graphicNetwork" of stack "primary" to tRect
   set the rect of field "textInstr" of stack "primary" to tRect
   set the rect of field "resourceField" of stack "primary" to tRect
   put the rect of field "filepathField" stack "primary" into tBlerg
   put cardWidth-2 into item 3 of tBlerg
   set the rect of field "filepathField" stack "primary" to tBlerg
   unlock screen
end resizeStack

function relativePath fStartFolder,fDestinationFolder
   -- ! I grabbed this whole function off the internet after seeing it referred to like a built-in function
   -- ! startFolder is most likely the defaultFolder, or the folder where the app is running
   -- ! destinationFolder is the user's choice

   -- Computes the path difference from position fStartFolder to fDestinationFolder in the file tree
   -- We are at fStartFolder, how to get to fDestinationFolder?  This relative path can be of the
   -- form "../../folder/folder" if we have to go up to a common parent first.
   -- Both positions are given as paths without file names e.g.  "folder/folder/...folder/"
   -- and it is assumed that at least the first folder is common
   -- (but it is not necessarily the root of the file system).
   -- The algorithm tries to find the first point at which the paths differ.
   -- During the comparison we may reach the end of one of the paths, i.e. the shorter path
   -- is completely contained in the longer one.  If the destination is longer, then we just use the
   -- remaining part of the destination, since it is inside the start folder.  An example is:
   --     start:          a/b/c/
   --     destination:    a/b/c/d/e/f/
   --     relative path:  d/e/f/
   --
   -- If the start is longer, then it is inside the destination and all we need to do is go up the
   -- tree to that point.  An example is:
   --     start:          a/b/c/d/e/f/
   --     destination:    a/b/c/
   --     relative path:  ../../../
   --
   -- In the remaining case a difference is found somewhere before reaching the end of either path.
   -- Then first one has to go back up from the start folder to this common point and then down
   -- to the destination.  An example is:
   --     start:          a/x/y/
   --     destination:    a/b/c/d/e/f/
   --     relative path:  ../../b/c/d/e/f/

   local lRelativePath      -- where we prepare the result
   local nStartItems        -- the number of folders in the start folder path
   local nDestinationItems  -- the number of folders in the destination folder path
   local lComparing         -- the index of the item in both paths that is being compared

   set the itemdelimiter to "/"
   put the number of items of fStartFolder into nStartItems
   put the number of items of fDestinationFolder into nDestinationItems
   put 0 into lComparing
   put empty into lRelativePath
   repeat
      add 1 to lComparing
      if lComparing > nStartItems then
         -- everything up to here was the same and the destination is longer:
         -- the relative part is just the rest of the destination path:
         repeat while lComparing <= nDestinationItems
            put (item lComparing of fDestinationFolder)&"/" after lRelativePath
            add 1 to lComparing
         end repeat
         exit repeat  -- we have finished.
      else
         if lComparing > nDestinationItems then
            -- everything up to here was the same and the destination is shorter,
            -- we just need to go up the tree a little because we started inside the destination
            repeat while lComparing <= nStartItems
               put "../" after lRelativePath
               add 1 to lComparing
            end repeat
            exit repeat  -- we have finished.
         else
            if (item lComparing of fStartFolder) is not (item lComparing of fDestinationFolder) then
               -- the paths are different at this point.
               -- first go up the tree from inside the start folder up to this common point:
               repeat with j=0 to nStartItems-lComparing
                  put "../" after lRelativePath
               end repeat
               -- now go down the destination path:
               repeat while lComparing <= nDestinationItems
                  put (item lComparing of fDestinationFolder)&"/" after lRelativePath
                  add 1 to lComparing
               end repeat
               exit repeat  -- we have finished.
            end if
         end if
      end if
   end repeat
   return lRelativePath
end relativePath

command userNew
   -- ! should be the next available key (if 1 is taken, then 2; etc)
   -- ! for now only one doc in memory
   -- ! so new is being treated the same as close in the menuPick script in the File button
end userNew

command userOpen pFile
   -- pFile is the filepath of the document to open
   put URL ("file:" & pFile) into tJason
   --   put arrayFromJson(tArray) into sMain[sNowDoc]
   --   dispatch "myCommand" to card "myCard" with "Hello World", tArray, tCSV
   dispatch "cmdArrayFromJson" to stack "easyJSON" with tJason
   put the result into sMain[sNowDoc]
   render
end userOpen

command userSave pFile
   -- pFile is the filepath of the document to save (or save over)
   put sMain[sNowDoc] into tArray
   --   put the keys of tArray into tKeys
   --   sort tKeys numeric ascending
   --   repeat for each line tRec in tKeys
   --   end repeat
   --   put jsonFromArray(tArray) into URL ("file:" & pFile)
   dispatch "cmdJsonFromArray" to stack "easyJSON" with tArray
   put the result into URL ("file:" & pFile)
end userSave

command userClose
   -- delete graphic objects
   put the keys of sGraphics[sNowDoc] into tKeys
   repeat for each line tRec in tKeys
      if exists(sGraphics[sNowDoc][tRec]["longID"]) then
         -- delete the node graphic
         delete sGraphics[sNowDoc][tRec]["longID"]
      end if
   end repeat

   put empty into sMain[sNowDoc]
   put empty into sGraphics[sNowDoc]
   put empty into sExpanded
   put empty into sNowItem
   put empty into sThenItem
   put "New" into field "savedField" stack "primary"
   put empty into field "filepathField" stack "primary"
   -- sNowDoc won't change from 1

   -- ! this is first done in the preOpenStack handler
   put "step myStep turn myTurn bond prev next skim read bulk trim" \
         into sPointerTags
   put empty into sMain
   put 1 into sNowDoc
   put true into sMain[sNowDoc][0]["hide"]
   put 0 into sMain[sNowDoc][0][lastKey]
   put empty into sNowItem

   put "2,1" & cr & "3,1" & cr & "4,1" into sMain[sNowDoc][1]["step"]
   put "state" into sMain[sNowDoc][2]["type"]
   put "1,1" into sMain[sNowDoc][2]["myStep"]
   put "untitled project" into sMain[sNowDoc][3]["title"]
   put "1,1" into sMain[sNowDoc][3]["myStep"]
   put "500,10" into sMain[sNowDoc][4]["coord"]
   put "1,1" into sMain[sNowDoc][4]["myStep"]
   put 4 into sMain[sNowDoc][0][lastKey]

   -- erase any leftover graphics ------------------------------------------
   -- this will erase everything in the group except floorRect
   put 0 into tControl
   repeat for the number of controls of group "graphicNetwork" of stack "primary"
      add one to tControl
      put the name of control tControl of group "graphicNetwork" of stack "primary" & cr after tList
   end repeat
   repeat for each line tLine in tList
      if "id" is among the words of tLine then delete tLine
   end repeat

   -- ! close one of multiple open docs
   render
end userClose

command userGraphNetSel pGraphHilite
   -- listening for selections made in the graphic network
   -- pGraphHilite should just be one rec for now
   -- it'll overwrite what was put into sNowItem by rTree
   put sNowItem into sThenItem
   put pGraphHilite into sNowItem
   if sNowItem = sThenItem then break
   UIcheck
end userGraphNetSel

command userSelection pSelectData
   -- array[hilited] is a cr-delimited list of record numbers of each hilited
   -- array[open] is a comma-delimited list of rec keys of each expanded step
   if char -1 of pSelectData["hilited"] is "," then delete char -1 of pSelectData["hilited"]
   put sNowItem into sThenItem
   put pSelectData["hilited"] into sNowItem
   if "open" is among the keys of pSelectData then put pSelectData["open"] into sExpanded
   if sNowItem = sThenItem and sExpanded = sWasExpanded then break
   -- needs to sync all places that display steps
   put sNowItem into tHilite["now"]
   put sThenItem into tHilite["then"]
   put sGraphics[sNowDoc] into tHilite["ids"]
   dispatch "syncHilite" to group "graphicNetwork" stack "primary" with tHilite
   -- how to sync rTree
   -- can't use click command to simulate mouse because the node might not be on screen
   dispatch "syncHilite" to group "treeList" stack "primary" with tHilite
   UIcheck
end userSelection

command UIcheck
   -- toggle bondButt/flowButt and diveButt/riseButt availability
   -- ! come back to this when rTree isn't displaying everything
   -- state & change are always available (can always drop in a new node)
   -- bond & flow and dive & rise are normally disabled (only exist between two nodes)
   -- go through hilited list
   set the disabled of button "bondButt" stack "primary" to true
   set the disabled of button "flowButt" stack "primary" to true
   set the disabled of button "diveButt" stack "primary" to true
   set the disabled of button "riseButt" stack "primary" to true
   ---------------------------- only two selections
   --   if the number of lines in pHilited is 2 then
   --      put line 1 of pHilited into tX
   --      put line 2 of pHilited into tZ
   if the number of lines in sNowItem is 2 then
      put line 1 of sNowItem into tX
      put line 2 of sNowItem into tZ
      ---------------------------- both selections must be nodes
      if (isAnode(sNowDoc,tX) is not false) and (isAnode(sNowDoc,tZ) is not false) then
         -------------------------- nodes cannot already be linked
         if areLinked(tX,tZ) is true then
            break
         else
            set the disabled of button "bondButt" stack "primary" to false
            set the disabled of button "flowButt" stack "primary" to false
            set the disabled of button "diveButt" stack "primary" to false
            set the disabled of button "riseButt" stack "primary" to false
         end if
      end if
   end if

   -- toggle availability
   set the disabled of button "infoButt" stack "primary" to true
   set the disabled of button "fileButt" stack "primary" to true
   set the disabled of button "hideButt" stack "primary" to true
   --   if the number of lines of pHilited is 1 then
   if the number of lines of sNowItem is 1 then
      -- infoButt
      --      if "step" is among the keys of sMain[sNowDoc][pHilited] then
      if "step" is among the keys of sMain[sNowDoc][sNowItem] then
         set the disabled of button "infoButt" stack "primary" to false
         set the disabled of button "fileButt" stack "primary" to false
         -- hideButt ! user could hide multiple items at a time, but that would be harder to figure out
         -- toggle hideButt availability
         -- has either 'step' or 'myStep' in its keys (therefore is an item)
         -- if node/link, step must have at least one active pointer
         -- if tag, myStep must have at least one active pointer
         --         if clearNegPairs(sMain[sNowDoc][pHilited]["step"]) is not empty then set the disabled of button "hideButt" stack "primary" to false
         if clearNegPairs(sMain[sNowDoc][sNowItem]["step"]) is not empty then set the disabled of button "hideButt" stack "primary" to false
      end if -- is a step
   end if -- only one selected
   --   if "myStep" is among the keys of sMain[sNowDoc][pHilited] then
   if "myStep" is among the keys of sMain[sNowDoc][sNowItem] then
      -- hideButt
      --      if clearNegPairs(sMain[sNowDoc][pHilited]["myStep"]) is not empty then set the disabled of button "hideButt" stack "primary" to false
      if clearNegPairs(sMain[sNowDoc][sNowItem]["myStep"]) is not empty then set the disabled of button "hideButt" stack "primary" to false
   end if -- is a tag

   -- undoButt/redoButt don't depend on the user's selection; see render
end UIcheck

function isAnode pDocKey,pRecKey -- takes a rec (in sNowDoc); returns false or node facts
   -- pRecKey: a single record number
   -- pDocKey: a single doc number
   if "step" is not among the keys of sMain[pDocKey][pRecKey] then return false
   put false into tNode
   put clearNegPairs(sMain[pDocKey][pRecKey]["step"]) into tPointers
   repeat for each line tPtr in tPointers
      put item 1 of tPtr into tPtr
      if sMain[pDocKey][tPtr]["type"] is "state" then put "state" into tNode
      if sMain[pDocKey][tPtr]["type"] is "change" then put "change" into tNode
   end repeat
   return tNode
end isAnode

function isAlink pDocKey,pRecKey -- takes a rec, returns false or link facts
   -- pRecKey: a single record number
   -- pDocKey: a single doc number
   if "step" is not among the keys of sMain[pDocKey][pRecKey] then return false
   put "bond flow dive rise" into tLinkTypes
   put false into tNode
   put clearNegPairs(sMain[pDocKey][pRecKey]["step"]) into tPointers
   -- find link type
   repeat for each line tPtr in tPointers
      put item 1 of tPtr into tPtr
      if sMain[pDocKey][tPtr]["type"] is among the words of tLinkTypes then
         put sMain[pDocKey][tPtr]["type"] into tNode["type"]
         exit repeat
      end if
   end repeat
   -- find the right tag
   -- start step (node) is X, link step is Y, end step (node) is Z
   -- bond is easy
   if tNode["type"] is "bond" then
      repeat for each line tPtr in tPointers
         put item 1 of tPtr into tPtr
         if tNode["type"] is among the keys of sMain[pDocKey][tPtr] then
            put tPtr into tNode["Y"]
            put item 1 of line 1 of sMain[pDocKey][tPtr][tNode["type"]] into tAlmost
            put item 1 of sMain[pDocKey][tAlmost]["myStep"] into tNode["X"]
            put item 1 of line 2 of sMain[pDocKey][tPtr][tNode["type"]] into tAlmost
            put item 1 of sMain[pDocKey][tAlmost]["myStep"] into tNode["Z"]
            -- Xcoord
            -- Zcoord
         end if
      end repeat
   end if
   -- directed links are more complicated
   switch tNode["type"]
      case "flow"
         repeat for each line tPtr in tPointers
            put item 1 of tPtr into tPtr
            if "prev" is among the keys of sMain[pDocKey][tPtr] then
               put item 1 of sMain[pDocKey][tPtr]["prev"] into tAlmost
               put item 1 of sMain[pDocKey][tAlmost]["myStep"] into tNode["X"]
            end if
            if "next" is among the keys of sMain[pDocKey][tPtr] then
               put item 1 of sMain[pDocKey][tPtr]["next"] into tAlmost
               put item 1 of sMain[pDocKey][tAlmost]["myStep"] into tNode["Z"]
            end if
         end repeat
         break
      case "dive"
         repeat for each line tPtr in tPointers
            put item 1 of tPtr into tPtr
            if "skim" is among the keys of sMain[pDocKey][tPtr] then
               put item 1 of sMain[pDocKey][tPtr]["skim"] into tAlmost
               put item 1 of sMain[pDocKey][tAlmost]["myStep"] into tNode["X"]
            end if
            if "read" is among the keys of sMain[pDocKey][tPtr] then
               put item 1 of sMain[pDocKey][tPtr]["read"] into tAlmost
               put item 1 of sMain[pDocKey][tAlmost]["myStep"] into tNode["Z"]
            end if
         end repeat
         break
      case "rise"
         repeat for each line tPtr in tPointers
            put item 1 of tPtr into tPtr
            if "bulk" is among the keys of sMain[pDocKey][tPtr] then
               put item 1 of sMain[pDocKey][tPtr]["bulk"] into tAlmost
               put item 1 of sMain[pDocKey][tAlmost]["myStep"] into tNode["X"]
            end if
            if "trim" is among the keys of sMain[pDocKey][tPtr] then
               put item 1 of sMain[pDocKey][tPtr]["trim"] into tAlmost
               put item 1 of sMain[pDocKey][tAlmost]["myStep"] into tNode["Z"]
            end if
         end repeat
         break
   end switch
   -- tNode is either false
   -- or it's an array with type, X, Y, Z
   return tNode
end isAlink

function areLinked pX,pZ
   -- pX & pZ are each a single record number
   -- if there is already a link connecting them, return true
   -- otherwise return false
   put false into tLink
   put listOfLinks(pX) into pXlinks
   put listOfLinks(pZ) into pZlinks
   repeat for each item tTest in pXlinks
      if pXlinks is among the items of pZlinks then
         put true into tLink
         exit repeat
      end if
   end repeat
   return tLink
end areLinked

function clearNegPairs pRecKey -- takes a list of pointers; returns list of non-negated pointers
   -- ? why did I call this pRecKey if it's not a record key, it's a list of pointers...whatever
   repeat for each line tEvilTwin in pRecKey
      if char 1 of item 1 of tEvilTwin is "-" then
         put tEvilTwin into tGoodTwin
         put item 1 of tEvilTwin into tEvilTwin
         delete char 1 of tGoodTwin
         put item 1 of tGoodTwin into tGoodTwin
         delete line lineOffset(tEvilTwin,pRecKey) of pRecKey
         delete line lineOffset(tGoodTwin,pRecKey) of pRecKey
      end if
   end repeat
   return pRecKey
end clearNegPairs

command userState pRec
   -- if pRec is empty the user just wants a new state node
   newItem("state")
   -- if something is in pRec then the user wants it to be a state node

   put "Unsaved" into field "savedField" stack "primary"
   render
end userState

command userChange pRec
   -- if pRec is empty the user just wants a new change node
   newItem("change")
   -- if something is in pRec then the user wants it to be a change node

   put "Unsaved" into field "savedField" stack "primary"
   render
end userChange

command newItem pType
   -- pType: ! at the moment just state/change
   -- the previous handler checked to be sure this request is appropriate
   -- since the item is brand new it's a simple process
   -- new turn
   put sMain[sNowDoc][0][lastKey] into tRec
   put tRec+2 & "," & tRec+1 & cr & tRec+3 & "," & tRec+1 & cr & tRec+4 & "," & tRec+1 into sMain[sNowDoc][tRec+1]["turn"]
   put "newItem" into sMain[sNowDoc][tRec+1]["act"]
   -- new step
   put tRec+3 & "," & tRec+1 & cr & tRec+4 & "," & tRec+1 into sMain[sNowDoc][tRec+2]["step"]
   put tRec+1 & "," & tRec+1 into sMain[sNowDoc][tRec+2]["myTurn"]
   -- new type tag
   put pType into sMain[sNowDoc][tRec+3]["type"]
   put tRec+1 & "," & tRec+1 into sMain[sNowDoc][tRec+3]["myTurn"]
   put tRec+2 & "," & tRec+1 into sMain[sNowDoc][tRec+3]["myStep"]
   -- new coord tag (with default coordinates)
   --   put the loc of graphic "floorRect" of group "graphicNetwork" of stack "primary" into tDefaultXY
   put the loc of group "graphicNetwork" of stack "primary" into tDefaultXY
   put winToNetCoord(tDefaultXY) into sMain[sNowDoc][tRec+4]["coord"]
   put tRec+1 & "," & tRec+1 into sMain[sNowDoc][tRec+4]["myTurn"]
   put tRec+2 & "," & tRec+1 into sMain[sNowDoc][tRec+4]["myStep"]
   -- update highest key
   put tRec+4 into sMain[sNowDoc][0][lastKey]

   -- render happens in userChange/userState
end newItem

command userBond pRecs
   -- pRecs: X rec & cr & Z rec
   put line 1 of pRecs into tXstep
   put line 2 of pRecs into tZstep
   put sMain[sNowDoc][0][lastKey] into tRec
   -- as in step X is bonded to step Z thru step Y
   -- +1 turn
   -- +2 Y step
   -- +3 Y type:bond
   -- +4 Y, bond: Xptr, Zptr
   -- +5 X's bond, bond: Yptr
   -- +6 Z's bond, bond: Yptr
   -- pointers link the locations where they're recorded
   -- so Yrec's bond tag has its own rec, which is what X&Z's bond tags point to, and vice versa
   -- ptr 2 thru 6
   put tRec+2 & "," & tRec+1 & cr & tRec+3 & "," & tRec+1 & cr & tRec+4 & "," & tRec+1 & cr \
         & tRec+5 & "," & tRec+1 & cr & tRec+6 & "," & tRec+1 into sMain[sNowDoc][tRec+1]["turn"]
   put "newBond" into sMain[sNowDoc][tRec+1]["act"]

   put tRec+2 into tYstep
   put tRec+3 & "," & tRec+1 & cr & tRec+4 & "," & tRec+1 into sMain[sNowDoc][tYstep]["step"]
   put tRec+1 & "," & tRec+1 into sMain[sNowDoc][tYstep]["myTurn"]

   put "bond" into sMain[sNowDoc][tRec+3]["type"]
   put tRec+1 & "," & tRec+1 into sMain[sNowDoc][tRec+3]["myTurn"]
   put tYstep & "," & tRec+1 into sMain[sNowDoc][tRec+3]["myStep"]

   put tRec+4 into tYbond
   put tRec+5 into tXbond
   put tRec+6 into tZbond
   put tXbond & "," & tRec+1 & cr & tZbond & "," & tRec+1 into sMain[sNowDoc][tYbond]["bond"]
   put tRec+1 & "," & tRec+1 into sMain[sNowDoc][tYbond]["myTurn"]
   put tYstep & "," & tRec+1 into sMain[sNowDoc][tYbond]["myStep"]
   -- this one was already done earlier

   put tYbond & "," & tRec+1 into sMain[sNowDoc][tXbond]["bond"]
   put tRec+1 & "," & tRec+1 into sMain[sNowDoc][tXbond]["myTurn"]
   put tXstep & "," & tRec+1 into sMain[sNowDoc][tXbond]["myStep"]
   put cr & tXbond & "," & tRec+1 after sMain[sNowDoc][tXstep]["step"]

   put tYbond & "," & tRec+1 into sMain[sNowDoc][tZbond]["bond"]
   put tRec+1 & "," & tRec+1 into sMain[sNowDoc][tZbond]["myTurn"]
   put tZstep & "," & tRec+1 into sMain[sNowDoc][tZbond]["myStep"]
   put cr & tZbond & "," & tRec+1 after sMain[sNowDoc][tZstep]["step"]

   put tRec+6 into sMain[sNowDoc][0][lastKey]

   put "Unsaved" into field "savedField" stack "primary"
   render
end userBond

command userFlow pRecs
   -- pRecs: X rec & cr & Z rec
   put line 1 of pRecs into tXstep
   put line 2 of pRecs into tZstep
   put "newFlow" into theAct
   put "flow" into theType
   put "next" into theForward
   put "prev" into theBackward
   newDilink tXstep,tZstep,theAct,theType,theForward,theBackward

   put "Unsaved" into field "savedField" stack "primary"
   render
end userFlow

command userDive pRecs
   -- pRecs: X rec & cr & Z rec
   put line 1 of pRecs into tXstep
   put line 2 of pRecs into tZstep
   put "newDive" into theAct
   put "dive" into theType
   put "read" into theForward
   put "skim" into theBackward
   newDilink tXstep,tZstep,theAct,theType,theForward,theBackward

   put "Unsaved" into field "savedField" stack "primary"
   render
end userDive

command userRise pRecs
   -- pRecs: X rec & cr & Z rec
   put line 1 of pRecs into tXstep
   put line 2 of pRecs into tZstep
   put "newRise" into theAct
   put "rise" into theType
   put "trim" into theForward
   put "bulk" into theBackward
   newDilink tXstep,tZstep,theAct,theType,theForward,theBackward

   put "Unsaved" into field "savedField" stack "primary"
   render
end userRise

command newDilink pXstep,pZstep,pAct,pType,pForward,pBackward
   -- for flow: x,z,newFlow,flow,next,prev
   -- for dive: x,z,newDive,dive,read,skim
   -- for rise: x,z,newRise,rise,trim,bulk
   put sMain[sNowDoc][0][lastKey] into tRec
   -- as in step X is flowed to step Z thru step Y
   -- X forward <-> Y backward/Y forward <-> Z backward
   -- +1 turn
   put tRec+1 into tTurn
   -- +2 Y step
   put tRec+2 into tYstep
   -- +3 Y type: pType
   put tRec+3 into tYtype
   -- +4 Y pBackward to X pForward
   put tRec+4 into tYback
   -- +5 Y pForward to Z pBackward
   put tRec+5 into tYfor
   -- +6 X pForward to Y pBackward
   put tRec+6 into tXfor
   -- +7 Z pBackward to Y pForward
   put tRec+7 into tZback
   put tRec+7 into sMain[sNowDoc][0][lastKey]

   -- turn
   put tYstep & "," & tTurn & cr & tYtype & "," & tTurn & cr & tYback & "," & tTurn & cr \
         & tYfor & "," & tTurn & cr & tXfor & "," & tTurn & cr & tZback & "," & tTurn into sMain[sNowDoc][tTurn]["turn"]
   put pAct into sMain[sNowDoc][tTurn]["act"]

   -- Y step
   put tYtype & "," & tTurn & cr & tYback & "," & tTurn & cr & tYfor & "," & tTurn into sMain[sNowDoc][tYstep]["step"]
   put tTurn & "," & tTurn into sMain[sNowDoc][tYstep]["myTurn"]

   -- Y type
   put pType into sMain[sNowDoc][tYtype]["type"]
   put tTurn & "," & tTurn into sMain[sNowDoc][tYtype]["myTurn"]
   put tYstep & "," & tTurn into sMain[sNowDoc][tYtype]["myStep"]

   -- pointers
   put tXfor & "," & tTurn into sMain[sNowDoc][tYback][pBackward]
   put tTurn & "," & tTurn into sMain[sNowDoc][tYback]["myTurn"]
   put tYstep & "," & tTurn into sMain[sNowDoc][tYback]["myStep"]
   -- this one was done when tYstep was created

   put tZback & "," & tTurn into sMain[sNowDoc][tYfor][pForward]
   put tTurn & "," & tTurn into sMain[sNowDoc][tYfor]["myTurn"]
   put tYstep & "," & tTurn into sMain[sNowDoc][tYfor]["myStep"]
   -- this one was done when tYstep was created

   put tYback & "," & tTurn into sMain[sNowDoc][tXfor][pForward]
   put tTurn & "," & tTurn into sMain[sNowDoc][tXfor]["myTurn"]
   put pXstep & "," & tTurn into sMain[sNowDoc][tXfor]["myStep"]
   put cr & tXfor & "," & tTurn after sMain[sNowDoc][pXstep]["step"]

   put tYfor & "," & tTurn into sMain[sNowDoc][tZback][pBackward]
   put tTurn & "," & tTurn into sMain[sNowDoc][tZback]["myTurn"]
   put pZstep & "," & tTurn into sMain[sNowDoc][tZback]["myStep"]
   put cr & tZback & "," & tTurn after sMain[sNowDoc][pZstep]["step"]

   -- render happens in the calling handler
end newDilink

command userInfo
   ask "info,data (EX: title,the quick brown fox)"
   if it is empty then exit userInfo
   put item 1 of it into tTag
   put item 2 to -1 of it into tData
   put getTagKey(sNowItem,tTag,sNowDoc) into tNowRec
   put getTagData(sNowItem,tTag,sNowDoc) into tNowData
   -- create new record for turn and tag
   put sMain[sNowDoc][0][lastKey] into tRec

   put tRec+2 & "," & tRec+1 into sMain[sNowDoc][tRec+1]["turn"]
   put "newInfo" into sMain[sNowDoc][tRec+1]["act"]

   put tData into sMain[sNowDoc][tRec+2][tTag]
   put tRec+1 & "," & tRec+1 into sMain[sNowDoc][tRec+2]["myTurn"]
   put sNowItem & "," & tRec+1 into sMain[sNowDoc][tRec+2]["myStep"]
   put cr & tRec+2 & "," & tRec+1 after sMain[sNowDoc][sNowItem]["step"]

   put tRec+2 into sMain[sNowDoc][0][lastKey]
   -- negate old tag if it existed
   if tNowData is not empty then
      -- tag exists already
      -- negate pointer for old tag record
      put cr & "-" & sNowItem & "," & tRec+1 after sMain[sNowDoc][tNowRec]["myStep"]
      put cr & "-" & tNowRec & "," & tRec+1 after sMain[sNowDoc][sNowItem]["step"]
   end if
   put "Unsaved" into field "savedField" stack "primary"
   render
end userInfo

command userFile
   -- ! at the moment this just stores whatever they picked and tries to display a preview
   -- ! it should be easy to break

   put false into tShow
   answer file "attach this file to" && stepString(sNowDoc,sNowItem)
   if it is empty then exit userFile
   put it into tPath
   put it into tName
   set the itemdelimiter to "/"
   put the seconds & "-" & the last item of tName into tName
   --   replace defaultFolder with "" in tName
   --   if char 1 of tName is "/" then delete char 1 of tName
   --   answer tName && relativePath(defaultFolder,tPath)
   -- livecode supports:
   -- image: gif, jpg, png, bmp, xwd, xbm, xpm, pbm, pgm, ppm, pict, eps
   -- audio: wav, aiff, au, midi, snd, mp3, aac
   -- video: quicktime, avi, mpeg, mp4
   answer tName
   if (char -3 to -1 of tName) is among the words of "gif jpg png bmp xwd xbm xpm pbm pgm ppm ict eps" then put true into tShow
   -- create a new tag
   -- data is the relative filepath

end userFile

command userUndo
   -- count backwards from highest record
   -- locate first positive turn
   -- search entire array and negate any pointer attributed to that turn
   put the keys of sMain[sNowDoc] into tDocument
   sort tDocument numeric descending
   repeat for each line tToUndo in tDocument
      -- lack of a turn tag looks the same as a negated turn tag
      if clearNegPairs(sMain[sNowDoc][tToUndo]["turn"]) is not empty then
         if sMain[sNowDoc][tToUndo]["act"] is not "userUndo" then
            -- this is the youngest positive turn
            put tToUndo into tUndoThisRec
            exit repeat
         end if
      end if
   end repeat

   -- create the turn & undo tag records
   put sMain[sNowDoc][0][lastKey] into tRec

   put tRec+2 & "," & tRec+1 into sMain[sNowDoc][tRec+1]["turn"]
   put "userUndo" into sMain[sNowDoc][tRec+1]["act"]

   put tUndoThisRec & "," & tRec+1 into sMain[sNowDoc][tRec+2]["undo"]
   put tRec+1 & "," & tRec+1 into sMain[sNowDoc][tRec+2]["myTurn"]

   put tRec+1 into tTurn
   put tRec+2 into sMain[sNowDoc][0][lastKey]

   -- search everything, reverse appropriate pointers
   repeat for each key tRecord in sMain[sNowDoc]
      repeat for each key tTag in sMain[sNowDoc][tRecord]
         if tTag is among the words of sPointerTags then
            repeat for each line tPointer in sMain[sNowDoc][tRecord][tTag]
               if item 2 of tPointer is tUndoThisRec then
                  -- this pointer is attributed to the rec that needs to be undone; reverse it
                  put item 1 of tPointer into tTarget
                  if char 1 of tTarget is "-" then
                     -- negative, then append positive
                     delete char 1 of tTarget
                     put cr & tTarget & "," & tTurn after sMain[sNowDoc][tRecord][tTag]
                  else
                     -- positive, then append negative
                     put cr & "-" & tTarget & "," & tTurn after sMain[sNowDoc][tRecord][tTag]
                  end if
               end if
            end repeat
         end if
      end repeat
   end repeat
   put "Unsaved" into field "savedField" stack "primary"
   render
end userUndo

command userRedo
   -- count backwards from highest record
   -- locate first positive undo turn
   -- search entire array and negate any pointer attributed to that turn
   put the keys of sMain[sNowDoc] into tDocument
   sort tDocument numeric descending
   repeat for each line tToRedo in tDocument
      -- lack of a turn tag looks the same as a negated turn tag
      if clearNegPairs(sMain[sNowDoc][tToRedo]["turn"]) is not empty then
         if sMain[sNowDoc][tToRedo]["act"] is "userUndo" then
            -- this is the youngest positive undo turn
            put tToRedo into tRedoThisRec
            exit repeat
         end if
      end if
   end repeat

   -- create the turn & redo tag records
   put sMain[sNowDoc][0][lastKey] into tRec

   put tRec+2 & "," & tRec+1 into sMain[sNowDoc][tRec+1]["turn"]
   put "userRedo" into sMain[sNowDoc][tRec+1]["act"]

   put tRedoThisRec & "," & tRec+1 into sMain[sNowDoc][tRec+2]["redo"]
   put tRec+1 & "," & tRec+1 into sMain[sNowDoc][tRec+2]["myTurn"]

   put tRec+1 into tTurn
   put tRec+2 into sMain[sNowDoc][0][lastKey]

   -- search everything, reverse appropriate pointers
   repeat for each key tRecord in sMain[sNowDoc]
      repeat for each key tTag in sMain[sNowDoc][tRecord]
         if tTag is among the words of sPointerTags then
            repeat for each line tPointer in sMain[sNowDoc][tRecord][tTag]
               if item 2 of tPointer is tRedoThisRec then
                  -- this pointer is attributed to the rec that needs to be redone; reverse it
                  put item 1 of tPointer into tTarget
                  if char 1 of tTarget is "-" then
                     -- negative, then append positive
                     delete char 1 of tTarget
                     put cr & tTarget & "," & tTurn after sMain[sNowDoc][tRecord][tTag]
                  else
                     -- positive, then append negative
                     put cr & "-" & tTarget & "," & tTurn after sMain[sNowDoc][tRecord][tTag]
                  end if
               end if
            end repeat
         end if
      end repeat
   end repeat
   put "Unsaved" into field "savedField" stack "primary"
   render
end userRedo

command userHide
   -- ! assumes the current selection (sNowItem) is the target
   -- to hide a tag, follow myStep and negate the pointer to the tag
   -- to hide a step, negate all of its active pointers
   -- a tag will not be displayed if no step points to it
   -- a step will not be displayed if it has no active pointers

   -- turn
   -- negate pointers
   put sMain[sNowDoc][0][lastKey] into tRec

   put tRec+2 & "," & tRec+1 into sMain[sNowDoc][tRec+1]["turn"]
   put "userHide" & "," & sNowItem into sMain[sNowDoc][tRec+1]["act"]

   put sNowItem & "," & tRec+1 into sMain[sNowDoc][tRec+2]["hide"]
   put tRec+1 & "," & tRec+1 into sMain[sNowDoc][tRec+2]["myTurn"]

   put tRec+2 into sMain[sNowDoc][0][lastKey]

   -- if thing being hidden is a tag
   if "myStep" is among the keys of sMain[sNowDoc][sNowItem] then
      -- negate step pointer in myStep
      repeat for each line tPtr in sMain[sNowDoc][sNowItem]["myStep"]
         put item 1 of tPtr into tTarget
         if char 1 of tTarget is not "-" then
            put cr & "-" & tTarget & "," & tRec+1 after sMain[sNowDoc][sNowItem]["myStep"]
            -- negate tag pointer in step
            put cr & "-" & sNowItem & "," & tRec+1 after sMain[sNowDoc][tTarget]["step"]
         end if
      end repeat
   end if

   -- if thing being hidden isn't a tag, it must be a step
   if isAnode(sNowDoc,sNowItem) is false then
      -- if thing being hidden is a link
      hideStep(sNowItem,tRec+1)
   else
      -- if thing being hidden is a node (will take its links with it)
      -- links first
      put listOfLinks(sNowItem) into tLinks
      repeat for each item tLink in tLinks
         hideStep(tLink,tRec+1)
      end repeat
      -- then the node itself
      hideStep(sNowItem,tRec+1)
   end if
   put "Unsaved" into field "savedField" stack "primary"
   render
end userHide

function listOfLinks pNode
   -- pNode = record key of a node
   -- returns a comma delimited list of the record keys of all the links attached to pNode
   -- find the recs of the links attached to this node
   put clearNegPairs(sMain[sNowDoc][pNode]["step"]) into tRecPtrs
   put empty into tY -- will be list of link step records, if any links attached to this node
   repeat for each line tPtr in tRecPtrs
      repeat for each key tAkey in sMain[sNowDoc][item 1 of tPtr]
         if tAkey is among the words of "bond next prev read skim trim bulk" then
            repeat for each line tOtherPtr in sMain[sNowDoc][item 1 of tPtr][tAkey]
               put item 1 of sMain[sNowDoc][item 1 of tOtherPtr]["myStep"] & "," after tY
            end repeat
         end if
      end repeat
   end repeat
   return tY
end listOfLinks

command hideStep pHideRec,pTurnRec
   -- pHideRec = the key of the rec to hide; negate it and pointers to it
   -- pTurnRec = the key of the rec responsible for hiding pHideRec
   if the number of items of pHideRec is 2 then
      put item 2 of pHideRec into pTurnRec
      put item 1 of pHideRec into pHideRec
   end if
   -- this works on nodes and links
   -- ! but, call it on the links first, then on the node
   -- negate these groups of pointers
   -- stepA<tPtrA>myStepA
   --                        linkA<tPtrAB>linkB
   --                                               myStepB<tPtrB>stepB
   put "bond prev next skim read bulk trim" into tLinkTags
   put clearNegPairs(sMain[sNowDoc][pHideRec]["step"]) into tStepA
   repeat for each line tPtrA in tStepA
      put item 1 of tPtrA into tPtrA
      put cr & "-" & tPtrA & "," & pTurnRec after sMain[sNowDoc][pHideRec]["step"]
      put cr & "-" & pHideRec & "," & pTurnRec after sMain[sNowDoc][tPtrA]["myStep"]
      repeat for each key tLinkA in sMain[sNowDoc][tPtrA]
         if tLinkA is among the words of tLinkTags then
            put clearNegPairs(sMain[sNowDoc][tPtrA][tLinkA]) into tLink
            repeat for each line tPtrAB in tLink
               put item 1 of tPtrAB into tPtrAB
               put cr & "-" & tPtrAB & "," & pTurnRec after sMain[sNowDoc][tPtrA][tLinkA]
               if tLinkA is "bond" then put "bond" into tLinkAmirror
               if tLinkA is "next" then put "prev" into tLinkAmirror
               if tLinkA is "prev" then put "next" into tLinkAmirror
               if tLinkA is "read" then put "skim" into tLinkAmirror
               if tLinkA is "skim" then put "read" into tLinkAmirror
               if tLinkA is "trim" then put "bulk" into tLinkAmirror
               if tLinkA is "bulk" then put "trim" into tLinkAmirror
               put cr & "-" & tPtrA & "," & pTurnRec after sMain[sNowDoc][tPtrAB][tLinkAmirror]
               put clearNegPairs(sMain[sNowDoc][tPtrAB]["myStep"]) into tPtrB
               repeat for each line tStepB in tPtrB
                  put item 1 of tStepB into tStepB
                  put cr & "-" & tPtrAB & "," & pTurnRec after sMain[sNowDoc][tStepB]["step"]
                  put cr & "-" & tStepB & "," & pTurnRec after sMain[sNowDoc][tPtrAB]["myStep"]
               end repeat
            end repeat
         end if
      end repeat
   end repeat
   put "Unsaved" into field "savedField" stack "primary"
end hideStep

function getTagData pRec,pTag,pDoc
   -- ! only works for steps at the moment
   -- assumes active doc
   -- pRec is a key
   -- pTag is a string
   -- will return whatever is in that tag, if it's pointed with that rec
   put empty into tData
   put clearNegPairs(sMain[pDoc][pRec]["step"]) into tPointers
   repeat for each line tPtr in tPointers
      put item 1 of tPtr into tPtr -- throw out the turn's key
      if pTag is among the keys of sMain[pDoc][tPtr] then
         put sMain[pDoc][tPtr][pTag] into tData
      end if
   end repeat
   return tData
end getTagData

function getTagKey pRec,pTag,pDoc
   -- ! only works for steps at the moment
   -- assumes active doc
   -- pRec is a key
   -- pTag is a string
   -- will return the tag's record key, if it exists
   put empty into tKey
   put clearNegPairs(sMain[pDoc][pRec]["step"]) into tPointers
   repeat for each line tPtr in tPointers
      put item 1 of tPtr into tPtr -- throw out the turn's key
      if pTag is among the keys of sMain[pDoc][tPtr] then
         put tPtr into tKey
      end if
   end repeat
   return tKey
end getTagKey

command  adjList
   -- makes a simpler adjacency list
   -- takes in sMain[doc][rec][etc]
   -- returns a simple array of only visible nodes and links for sMainShort
   -- doesn't sort anything
   -- if a node
   -- array[doc][rec][next/prev/read/skim/bulk/trim]=rec & cr
   -- array[doc][rec][type]=state/change/bond/flow/dive/rise
   -- array[doc][rec][info]=tag,data & cr
   put empty into sMainShort
   repeat for each key tDoc in sMain
      repeat for each key tRec in sMain[tDoc]
         if tRec is 0 then next repeat
         -- only visible steps
         put isAnode(tDoc,tRec) into tNode
         if tNode is false then
            put isAlink(tDoc,tRec) into tLink
            if tLink is not false then
               ------------- link type -------------------
               put tLink["type"] into sMainShort[tDoc][tRec]["type"]
               put true into tStep
            end if
         else
            ------------- node type -------------------
            put tNode into sMainShort[tDoc][tRec]["type"]
            put true into tStep
         end if
         -------- this is the same for nodes and links --------------
         if tStep is true then
            ---------------- links & info  ---------------------
            put clearNegPairs(sMain[tDoc][tRec]["step"]) into tPointers
            repeat for each line tPtr in tPointers
               put item 1 of tPtr into tPtr
               repeat for each key tAkey in sMain[tDoc][tPtr]
                  if tAkey is among the words of "bond next prev read skim trim bulk" then
                     ------------------- links -------------------
                     repeat for each line tOtherPtr in sMain[tDoc][tPtr][tAkey]
                        put item 1 of tOtherPtr into tOtherPtr
                        put item 1 of sMain[tDoc][tOtherPtr]["myStep"] & cr after sMainShort[tDoc][tRec][tAkey]
                     end repeat
                  else
                     if tAkey is among the words of "weight material whole duration series" then
                        put sMain[tDoc][tPtr][tAkey] into sMainShort[tDoc][tRec][tAkey]
                     end if
                     -- ! info will still list all the previous tag:data pairs as part of the string
                     if tAkey is not among the words of "coord turn act myTurn myStep type" then
                        ----------------- info --------------------
                        put tAkey & ":" & sMain[tDoc][tPtr][tAkey] & cr after sMainShort[tDoc][tRec]["info"]
                     end if
                  end if
               end repeat
            end repeat
         end if
      end repeat
   end repeat
end adjList

command kahnSortOld
   -- ! not recursive, but should be
   -- ! after all nodes resulting from A&B visited, stick unvisited at end of sort
   -- ! get rid of the if planA not empty, that will handle all existing nodes
   put empty into sTopoSort -- will contain the sorted nodes
   put empty into tPlanA -- scope nodes outside of flow
   put empty into tPlanB -- unscoped nodes at beginning of flow
   ---------------- list of seed nodes ----------------------
   repeat for each key tDoc in sMainShort
      put the keys of sMainShort[tDoc] into tNotVisited
      replace cr with "," in tNotVisited
      repeat for each key tRec in sMainShort[tDoc]
         if sMainShort[tDoc][tRec]["type"] is "state" or sMainShort[tDoc][tRec]["type"] is "change" then
            put the keys of sMainShort[tDoc][tRec] into tTheKeys
            put false into tPrev
            put false into tNext
            put false into tRead
            put false into tBulk
            put false into tSkim
            if "prev" is among the lines of tTheKeys then put true into tPrev
            if "next" is among the lines of tTheKeys then put true into tNext
            if "read" is among the lines of tTheKeys then put true into tRead
            if "bulk" is among the lines of tTheKeys then put true into tBulk
            if "skim" is among the lines of tTheKeys then put true into tSkim
            if tRead and tBulk and not tNext and not tPrev then put tRec & "," after tPlanA
            if tNext and not tPrev and not tSkim and not tBulk then put tRec & "," after tPlanB
         end if
      end repeat
      -------------- sort, still in tDoc -----------------------
      put tPlanB after tPlanA
      if tPlanA is not empty then -- else handles when nothing satisfies planA or planB
      -- at least one node has links indicating it's part of scope or flow
      repeat while tPlanA is not empty
         put item 1 of tPlanA into tNode
         delete item 1 of tPlanA
         replace cr with "" in tNode
         if tNode is among the items of tNotVisited then
            put tNode & "," after sTopoSort[tDoc]
            ------------------ spelunking ---------------
            set the wholeMatches to true
            delete item itemOffset(tNode,tNotVisited) in tNotVisited
            set the wholeMatches to false
            -- follow a link (Y) out of tNode (X), preference: scope, flow, bond
            -- remove link (Y) from notVisitied list
            -- if the node (Z) has no unvisited in-links of same type
            -- then add node (Z) to planA
            -- follow scope when available ----------------------------------------------
            if sMainShort[tDoc][tNode]["read"] is not empty and sMainShort[tDoc][tNode]["bulk"] is not empty then
               repeat for each line tLink in sMainShort[tDoc][tNode]["read"]
                  replace cr with "" in tLink
                  set the wholeMatches to true
                  delete item itemOffset(tLink,tNotVisited) in tNotVisited
                  set the wholeMatches to false
                  put sMainShort[tDoc][tLink]["read"] into tNodeZ
                  replace cr with "" in tNodeZ
                  put true into tLast
                  repeat for each line tSameType in sMainShort[tDoc][tNodeZ]["skim"]
                     replace cr with "" in tSameType
                     if tSameType is among the items of tNotVisited then
                        put false into tLast
                        exit repeat
                     end if
                  end repeat
                  if tLast is true then
                     -- adds to front of list instead of end of list
                     put tNodeZ & "," before tPlanA
                     replace return with "" in tPlanA
                     replace ",," with "," in tPlanA
                  end if
               end repeat
            end if
            -- follow flow next ------------------------------------------------------------
            repeat for each line tLink in sMainShort[tDoc][tNode]["next"]
               replace cr with "" in tLink
               set the wholeMatches to true
               delete item itemOffset(tLink,tNotVisited) in tNotVisited
               set the wholeMatches to false
               put sMainShort[tDoc][tLink]["next"] into tNodeZ
               replace cr with "" in tNodeZ
               put true into tLast
               repeat for each line tSameType in sMainShort[tDoc][tNodeZ]["prev"]
                  replace cr with "" in tSameType
                  if tSameType is among the items of tNotVisited then
                     put false into tLast
                     exit repeat
                  end if
               end repeat
               if tLast is true then
                  -- adds to end of list
                  put tNodeZ & "," after tPlanA
                  replace return with "" in tPlanA
                  replace ",," with "," in tPlanA
               end if
            end repeat
         end if
      end repeat
   else
      -- both plans are empty, no scope or flow links yet, just sort the nodes ascending
      put the keys of sMainShort[tDoc] into tKeys
      sort lines of tKeys numeric ascending
      repeat for each line tNode in tKeys
         if tNode is among the items of tNotVisited then
            if sMainShort[tDoc][tNode]["type"] is "state" or sMainShort[tDoc][tNode]["type"] is "change" then
               put tNode & "," after sTopoSort[tDoc]
               set the wholeMatches to true
               delete item itemOffset(tNode,tNotVisited) in tNotVisited
               set the wholeMatches to false
            end if
         end if
      end repeat
   end if
end repeat
end kahnSortOld

command topoSort
   put empty into sTopoSort -- will contain the sorted nodes
   put empty into tPlanA -- scope nodes outside of flow
   put empty into tPlanB -- unscoped nodes at beginning of flow
   put empty into sNoteList
   ---------------- list of seed nodes ----------------------
   repeat for each key tDoc in sMainShort
      put the keys of sMainShort[tDoc] into sNotVisited[tDoc]
      replace cr with "," in sNotVisited[tDoc]
      repeat for each key tRec in sMainShort[tDoc]
         if sMainShort[tDoc][tRec]["type"] is "state" or sMainShort[tDoc][tRec]["type"] is "change" then
            put the keys of sMainShort[tDoc][tRec] into tTheKeys
            put false into tPrev
            put false into tNext
            put false into tRead
            put false into tBulk
            put false into tSkim
            if "prev" is among the lines of tTheKeys then put true into tPrev
            if "next" is among the lines of tTheKeys then put true into tNext
            if "read" is among the lines of tTheKeys then put true into tRead
            if "bulk" is among the lines of tTheKeys then put true into tBulk
            if "skim" is among the lines of tTheKeys then put true into tSkim
            if tRead and tBulk and not tNext and not tPrev then put tRec & "," after tPlanA
            if tNext and not tPrev and not tSkim and not tBulk then put tRec & "," after tPlanB
         end if
      end repeat -- tRec
      put tPlanA after tNextList
      put tPlanB after tNextList
      get kahnSort(tDoc,tNextList)
   end repeat -- tDoc
end topoSort

function kahnSort pDoc,pSeedList
   -- pDoc = document number
   -- pSeedList = ordered comma delimited list of records in pDoc
   -- doesn't return anything
   -- just walks network, edits sTopoSort, and terminates
   put empty into tNextList
   replace cr with "" in pSeedList
   repeat for each item tStep in pSeedList
      delete item 1 of pSeedList
      if tStep is among the items of sNotVisited[pDoc] then
         -- this node has not been visited
         -- in the order scope, then flow ( ! bond handled elsewhere at the moment)
         -- follow each link (Y) out of tStep (X)
         -- remove link (Y) from notVisited
         -- if node (Z) has no unvisited in-links of same type
         -- then add node(Z) to nextList
         -- pass pDoc and nextList to kahnSort
         ------------ move node from notVisited to topoSort -------------------------------
         put tStep & "," after sTopoSort[pDoc]
         set the wholeMatches to true
         delete item itemOffset(tStep,sNotVisited[pDoc]) in sNotVisited[pDoc]
         set the wholeMatches to false
         ------------ scope link(s) --------------------------------------------------------------
         -- both read and bulk links means this node contains other nodes --------------
         if sMainShort[pDoc][tStep]["read"] is not empty and sMainShort[pDoc][tStep]["bulk"] is not empty then
            repeat for each line tLink in sMainShort[pDoc][tStep]["read"]
               replace cr with "" in tLink
               set the wholeMatches to true
               delete item itemOffset(tLink,sNotVisited[pDoc]) in sNotVisited[pDoc]
               set the wholeMatches to false
               put sMainShort[pDoc][tLink]["read"] into tNodeZ
               replace cr with "" in tNodeZ
               put true into tLast
               repeat for each line tSameType in sMainShort[pDoc][tNodeZ]["skim"]
                  replace cr with "" in tSameType
                  if tSameType is among the items of sNotVisited[pDoc] then
                     put false into tLast
                     exit repeat
                  end if
               end repeat -- tSameType in tNodeZ
               if tLast is true then
                  put tNodeZ & "," after tNextList
               end if
            end repeat -- tLink in tStep, "read"
         end if -- both read and bulk links
         -- trim is forwards along a rise link, back towards the container node --------
         -- visit the returning rise links and, if the last rise link is visited add the container node again
         -- ! thus the container node will show up twice in the topolotical sort
         repeat for each line tLink in sMainShort[pDoc][tStep]["trim"]
            replace cr with "" in tLink
            set the wholeMatches to true
            delete item itemOffset(tLink,sNotVisited[pDoc]) in sNotVisited[pDoc]
            set the wholeMatches to false
            put sMainShort[pDoc][tLink]["trim"] into tNodeZ
            replace cr with "" in tNodeZ
            put true into tLast
            repeat for each line tSameType in sMainShort[pDoc][tNodeZ]["bulk"]
               replace cr with "" in tSameType
               if tSameType is among the items of sNotVisited[pDoc] then
                  put false into tLast
                  exit repeat
               end if
            end repeat -- tSameType in tNodeZ
            if tLast is true then
               put tNodeZ & "," after tNextList
               -- ! the container node has already been visited, so it's not in sNotVisited
               -- ? maybe don't mark it visited until it's arrived at through the last rise link
               put tNodeZ & "," after sTopoSort[pDoc]
            end if
         end repeat -- tLink in tStep, "trim"
         ------------- flow link(s) ----------------------------------------------------------------
         -- node only needs to have a next link to travel ------------------------------------
         repeat for each line tLink in sMainShort[pDoc][tStep]["next"]
            replace cr with "" in tLink
            set the wholeMatches to true
            delete item itemOffset(tLink,sNotVisited[pDoc]) in sNotVisited[pDoc]
            set the wholeMatches to false
            put sMainShort[pDoc][tLink]["next"] into tNodeZ
            replace cr with "" in tNodeZ
            put true into tLast
            repeat for each line tSameType in sMainShort[pDoc][tNodeZ]["prev"]
               replace cr with "" in tSameType
               if tSameType is among the items of sNotVisited[pDoc] then
                  put false into tLast
                  exit repeat
               end if
            end repeat -- tSameType in tNodeZ
            if tLast is true then
               put tNodeZ & "," after tNextList
            end if
         end repeat -- tLink in tStep, "next"
         ----------- bond link(s) --------------------------------------------------------------
         -- bond links are weird; they're treated as notes at the moment -------------
         -- bond links aren't followed, just recorded --------------------------------------
         -- so each nodeZ is a "note" attached to a step (state or change) -------------
         repeat for each line tLink in sMainShort[pDoc][tStep]["bond"]
            replace cr with "" in tLink
            set the wholeMatches to true
            delete item itemOffset(tLink,sNotVisited[pDoc]) in sNotVisited[pDoc]
            put sMainShort[pDoc][tLink]["bond"] into tNodeZ
            replace cr with "," in tNodeZ
            delete item itemOffset(tStep,tNodeZ) in tNodeZ
            replace "," with "" in tNodeZ
            delete item itemOffset(tNodeZ,sNotVisited[pDoc]) in sNotVisited[pDoc]
            set the wholeMatches to false
            -- tNodeZ is a note attached to tStep
            put tStep & "," after sNoteList[pDoc][tNodeZ]
            put tNodeZ & "," after sNoteList [pDoc][tStep]
            -- later, the only recs that will get called will be the scope/flow nodes
            -- they'll find the list of bonded nodes
         end repeat -- tLink in tStep, "bond"
      end if -- tStep is in sNotVisited[pDoc]
      if tNextList is not empty then get kahnSort(pDoc,tNextList)
   end repeat -- each tStep in pSeedList
end kahnSort

function tagBoolean pDoc,pRec
   put the keys of sMainShort[pDoc][pRec] into tTheKeys
   put false into tTag["prev"]
   put false into tTag["next"]
   put false into tTag["read"]
   put false into tTag["bulk"]
   put false into tTag["skim"]
   put false into tTag["trim"]
   if "prev" is among the lines of tTheKeys then put true into tTag["prev"]
   if "next" is among the lines of tTheKeys then put true into tTag["next"]
   if "read" is among the lines of tTheKeys then put true into tTag["read"]
   if "bulk" is among the lines of tTheKeys then put true into tTag["bulk"]
   if "skim" is among the lines of tTheKeys then put true into tTag["skim"]
   if "trim" is among the lines of tTheKeys then put true into tTag["trim"]
   return tTag
end tagBoolean

command supplyDemand
   -- list of seed nodes
   repeat for each key tDoc in sMainShort
      put empty into tScope
      put empty into tRawStart
      put empty into tRawEnd
      put empty into tOrphan
      put empty into sScopeSketch[tDoc]
      --      put empty into sScopeSketch
      -- ? maybe don't need to do this right here since it happens in gravitySort
      repeat for each key tRec in sResources[tDoc]
         put empty into sResources[tDoc][tRec]["scopeRef"]
      end repeat
      repeat for each key tRec in sMainShort[tDoc]
         if sMainShort[tDoc][tRec]["type"] is "state" or sMainShort[tDoc][tRec]["type"] is "change" then
            put tagBoolean(tDoc,tRec) into tTags
            -- raw node, no flow, no case
            -- this combination will first catch project containers at the highest level
            -- it will then catch flows that aren't contained
            -- nodes all by themselves aren't even bothered with
            --            if tTags["read"] and tTags["bulk"] and not tTags["next"] and not tTags["prev"] then \
                  --                  put tRec & "," after tScope -- case node with no flow
            --            if tTags["next"] and not tTags["prev"] and not tTags["skim"] and not tTags["trim"] then \
                  --                  put tRec & "," after tRawStart -- in flow no scope
            --            if not tTags["next"] and tTags["prev"] and not tTags["skim"] and not tTags["trim"] then \
                  --                  put tRec & "," after tRawEnd -- out flow no scope
            -- the baseline scope is stuff that's not encased, level 0
            -- ignore anything on level 0 that's mid-flow
            if not (tTags["skim"] or tTags["trim"] or (tTags["prev"] and tTags["next"])) then
               if not tTags["prev"] then put tRec & "," after tSupplySide
               if not tTags["next"] then put tRec & "," after tDemandSide
               put tRec & "," after tSpelunk
               switch
                  case not tTags["next"] and not tTags["prev"] -- solo
                     put "0,solo" into sResources[tDoc][tRec]["scopeRef"]
                     put tRec & "," after sScopeSketch[tDoc][0]["solo"]
                     break
                  case tTags["next"] and not tTags["prev"] -- in
                     put "0,in" into sResources[tDoc][tRec]["scopeRef"]
                     put tRec & "," after sScopeSketch[tDoc][0]["in"]
                     break
                  case tTags["next"] and tTags["prev"] and not tTags["skim"] and not tTags["trim"] -- thru
                     -- can't be thru at the moment, but whatevs
                     put "0,thru" into sResources[tDoc][tRec]["scopeRef"]
                     put tRec & "," after sScopeSketch[tDoc][0]["thru"]
                     break
                  case tTags["prev"] and not tTags["next"] -- out
                     put "0,out" into sResources[tDoc][tRec]["scopeRef"]
                     put tRec & "," after sScopeSketch[tDoc][0]["out"]
                     break
               end switch
               if tTags["bulk"] or tTags["read"] then -- top
                  put cr & "0,top" after sResources[tDoc][tRec]["scopeRef"]
                  put tRec & "," after sScopeSketch[tDoc][0]["top"]
               end if
            end if -- not skim or trim or prev&next
         end if -- state or change
      end repeat -- tRec in tDoc

      -- begin scope reference tracking
      -- each rec gets a line in scopeRef for each role
      -- 0 means it doesn't have a scope reference (uncased flow)
      -- 1 means it's a case node at the 0 flow level
      -- 2 means it's flow encased by a 1 case node
      -- 3 means it's a case node at the 2 flow level
      -- 4 means it's flow encased by a 3 case node, etc
      -- top means it's a case node
      -- in means it begins the flow at that reference level; out means it ends the flow
      -- thru means it's part of the flow
      -- entry also specifies the rec of the case node
      -- [scope level],[scope role],[case rec]
      -- #,top/in/thru/out,#
      --      repeat for each key tRec in sResources[tDoc]
      --         put empty into sResources[tDoc][tRec]["scopeRef"]
      --      end repeat
      --      repeat for each item tTop in tScope
      --         put "1,top" into sResources[tDoc][tTop]["scopeRef"]
      --      end repeat
      --      repeat for each item tIn in tRawStart
      --         put "0,in" into sResources[tDoc][tIn]["scopeRef"]
      --      end repeat
      --      repeat for each item tOut in tRawEnd
      --         put "0,out" into sResources[tDoc][tOut]["scopeRef"]
      --      end repeat

      -- rawEnd and rawStart are ends of the same link; shouldn't be possible for only one to not be empty
      -- need the conditional so livecode doesn't barf on an empty file with nothing to evaluate
      --      if tScope is not empty or tRawEnd is not empty or tRawStart is not empty then
      if tSpelunk is not empty then
         -- first empty out resource information
         -- call gravitySort outputs-to-inputs to figure total demand and increase supply to meet/exceed
         -- call gravitySort inputs-to-outputs to figure supply/demand mismatch
         -- keep doing that until nothing changes
         repeat for each key tFoo in sResources[tDoc]
            -- input & output used by old resource calculation
            --            if tFoo is "input" then next repeat
            --            if tFoo is "output" then next repeat
            put empty into sResources[tDoc][tFoo]["gravity"]
            if sMainShort[tDoc][tFoo]["type"] is "state" then
               put empty into sResources[tDoc][tFoo]["excess"]
               put empty into sResources[tDoc][tFoo]["totSupply"]
               put empty into sResources[tDoc][tFoo]["totDemand"]
            end if
         end repeat
         put true into sSomethingChanged
         repeat while sSomethingChanged is true
            put false into sSomethingChanged -- do this repeat at least once
            put the keys of sMainShort[tDoc] into sNotVisited[tDoc]
            replace cr with "," in sNotVisited[tDoc]
            --            get gravitySort(tDoc,tScope & tRawEnd,"bulk trim prev next") -- total demand
            get gravitySort(tDoc,tDemandSide,"bulk trim prev next") -- total demand
            put the keys of sMainShort[tDoc] into sNotVisited[tDoc]
            replace cr with "," in sNotVisited[tDoc]
            --            get gravitySort(tDoc,tScope & tRawStart,"read skim next prev") -- supply/demand mismatch
            get gravitySort(tDoc,tSupplySide,"read skim next prev") -- supply/demand mismatch
         end repeat
      end if
   end repeat -- tDoc in sMainShort
end supplyDemand

function gravitySort pDoc,pSeedList,pDirection
   -- pDoc = document number
   -- pSeedList = ordered comma delimited list of records in pDoc
   -- pDirection = "read skim next prev" or "bulk trim prev next"; easy to refer to as word 1/2/3/4
   -- doesn't return anything
   -- just walks network, edits sResources, and terminates
   -- ! gravity logic doesn't cross scope boundaries; this balances flows but not up or down scope
   -- scopeRef is assigned when a node is placed into the parameter, before being sent to gravitySort
   replace cr with "" in pSeedList -- should just be numbers and commas
   repeat for each item tStep in pSeedList
      -- ? should this be item offset of tStep
      delete item 1 of pSeedList
      if tStep is among the items of sNotVisited[pDoc] then
         -- this node has not been visited before
         -- in the seed list, and not visited yet, means it's ready to be balanced
         if sMainShort[pDoc][tStep]["type"] is "state" then
            --------- balance ---------------
            -- if undefined, gravity and skim default to 1
            -- (A) if tStep is a state
            -- (1) total supply = (skim weight * gravity) + (prev weight * gravity)
            -- (2) total demand = (trim weight * gravity) + (next weight * gravity)
            -- (3) if total supply < total demand, adjust skim & prev gravity to total equal or greater than demand
            -- ! assumes infinite supply, which will change when user can define finite resources
            -- (4) if total supply > total demand, note excess in sResources[doc][rec][excess]
            -- (B) if tStep is a change
            -- (1) highest demand gravity applied to all links in action group
            put empty into tSupply
            repeat for each word tHi in "skim prev"
               repeat for each line tBye in sMainShort[pDoc][tStep][tHi]
                  put 1 into tG
                  put 1 into tW
                  if sResources[pDoc][tBye]["gravity"] is not empty then put sResources[pDoc][tBye]["gravity"] into tG
                  if sMainShort[pDoc][tBye]["weight"] is not empty then put sMainShort[pDoc][tBye]["weight"] into tW
                  put tW & "," & tG & cr after tSupply
               end repeat
            end repeat
            -- total demand
            put empty into tDemand
            repeat for each word tHi in "trim next"
               repeat for each line tBye in sMainShort[pDoc][tStep][tHi]
                  put 1 into tG
                  put 1 into tW
                  if sResources[pDoc][tBye]["gravity"] is not empty then put sResources[pDoc][tBye]["gravity"] into tG
                  if sMainShort[pDoc][tBye]["weight"] is not empty then put sMainShort[pDoc][tBye]["weight"] into tW
                  put tW & "," & tG & cr after tDemand
               end repeat
            end repeat
            -- this way we can refer to the raw values if they need to change later
            filter tSupply without empty
            filter tDemand without empty
            put 0 into tTotSupply
            put 0 into tSupplyW
            repeat for each line tSup in tSupply
               put (item 1 of tSup) * (item 2 of tSup) + tTotSupply into tTotSupply
               put item 1 of tSup + tSupplyW into tSupplyW
            end repeat
            put 0 into tTotDemand
            put 0 into tDemandW
            repeat for each line tDem in tDemand
               put (item 1 of tDem) * (item 2 of tDem) + tTotDemand into tTotDemand
               put item 1 of tDem + tDemandW into tDemandW
            end repeat
            -- (A3) is supply < demand, so increase supply gravity to balance
            -- divide total demand by supply weight to get new gravity
            -- round up (supply always meets or exceeds demand
            -- apply gravity
            if tTotSupply < tTotDemand then
               -- ! should be improved to "solve" to create less or zero excess when multiple supply options
               -- ! in the future this should allow for the user to specify unequal gravity sharing
               if tTotSupply = 0 then
                  put 1 into tGravity
               else
                  put ceilingNum(tTotDemand / tSupplyW) into tGravity
               end if
               -- if supply needs to increase, apply gravity to supply links
               repeat for each word tDoody in "skim prev"
                  repeat for each line tPoody in sMainShort[pDoc][tStep][tDoody]
                     -- value might not need to change, if it does, make a note to run gravitySort again
                     put sResources[pDoc][tPoody]["gravity"] into tOld
                     if tGravity is not tOld then
                        put tGravity into sResources[pDoc][tPoody]["gravity"]
                        put true into sSomethingChanged
                     end if
                  end repeat
               end repeat
            end if -- supply < demand
            -- (A4) is supply > demand, so increase demand gravity to balance
            -- divide total supply by demand weight to get new gravity
            -- round down (demand always meets or disappoints supply)
            -- apply gravity
            if tTotSupply > tTotDemand then
               if tTotDemand = 0 then
                  put 1 into tGravity
               else
                  put trunc(tTotSupply / tDemandW) into tGravity
               end if
               -- if demand needs to increase, apply gravity to demand links
               repeat for each word tDoody in "trim next"
                  repeat for each line tPoody in sMainShort[pDoc][tStep][tDoody]
                     -- value might not need to change, if it does, make a note to run gravitySort again
                     put sResources[pDoc][tPoody]["gravity"] into tOld
                     if tGravity is not tOld then
                        put tGravity into sResources[pDoc][tPoody]["gravity"]
                        put true into sSomethingChanged
                     end if                  end repeat
                  end repeat
               end if -- supply > demand
               -- recalculate total supply
               put 0 into tTotSupply
               repeat for each word tHi in "skim prev"
                  repeat for each line tBye in sMainShort[pDoc][tStep][tHi]
                     put 1 into tG
                     put 1 into tW
                     if sResources[pDoc][tBye]["gravity"] is not empty then put sResources[pDoc][tBye]["gravity"] into tG
                     if sMainShort[pDoc][tBye]["weight"] is not empty then put sMainShort[pDoc][tBye]["weight"] into tW
                     put (tG * tW) + tTotSupply into tTotSupply
                  end repeat
               end repeat
               -- recalcualte total demand
               put 0 into tTotDemand
               repeat for each word tHi in "trim next"
                  repeat for each line tBye in sMainShort[pDoc][tStep][tHi]
                     put 1 into tG
                     put 1 into tW
                     if sResources[pDoc][tBye]["gravity"] is not empty then put sResources[pDoc][tBye]["gravity"] into tG
                     if sMainShort[pDoc][tBye]["weight"] is not empty then put sMainShort[pDoc][tBye]["weight"] into tW
                     put (tG * tW) + tTotDemand into tTotDemand
                  end repeat
               end repeat
               put tTotSupply into sResources[pDoc][tStep]["totSupply"]
               put tTotDemand into sResources[pDoc][tStep]["totDemand"]
               -- capture excess or shortfall (if external inventory insufficient)
               put 0 into sResources[pDoc][tStep]["excess"]
               put tTotSupply - tTotDemand into sResources[pDoc][tStep]["excess"]
               -- (B1)
            else -- tStep is not a state, must be a change
               -- determine largest gravity and distribute to all links in action group
               -- ! this is allowing for the possibility that changes have dive/rise links
               -- ! might be a bad idea, but I'll allow it for the moment
               put 1 into tGrav
               repeat for each word tDoody in "skim prev trim next"
                  repeat for each line tPoody in sMainShort[pDoc][tStep][tDoody]
                     put sResources[pDoc][tPoody]["gravity"] into tWannaBe
                     if (tWannaBe is not empty) and (tWannaBe > tGrav) then put tWannaBe into tGrav
                  end repeat
               end repeat
               repeat for each word tKind in "next prev skim trim"
                  repeat for each line tDink in sMainShort[pDoc][tStep][tKind]
                     -- value might not need to change, if it does, make a note to run gravitySort again
                     put sResources[pDoc][tDink]["gravity"] into tOld
                     if tGrav is not tOld then
                        put tGrav into sResources[pDoc][tDink]["gravity"]
                        put true into sSomethingChanged
                     end if
                  end repeat
               end repeat
            end if -- tStep state or change
            --------- balance ---------------
            --------- travel -----------------
            -- about scopeRef
            -- assume tStep's complete scopeRef was already determined
            -- so figure tNodeZ's complete scopeRef when identified as going into next seed list
            -- # = tStep's scope level
            -- one of these:
            -- #,thru = has next & prev tags
            -- #,in = has skim & next tags
            -- #,out = has trim & prev tags
            -- and maybe this:
            -- #+1,top = has read & bulk tags

            put empty into tNextList
            -- (1) mark this node visited
            -- travel scope, then flow (makes scope depth first and flow breadth first)
            -- (2) follow each link (Y) of tStep (X) in pDirection
            -- (3) remove link (Y) from notVisited
            -- if node (Z) has no unvisited links of same tag
            -- (4) then add node(Z) to nextList
            -- (5) pass pDoc and nextList to gravitySort

            -- (1)
            set the wholeMatches to true
            delete item itemOffset(tStep,sNotVisited[pDoc]) in sNotVisited[pDoc]
            set the wholeMatches to false
            ------------ scope link(s) --------------------------------------------------------------
            -- (2) both read and bulk links means this node contains other nodes --------------
            --            if sMainShort[pDoc][tStep]["read"] is not empty and sMainShort[pDoc][tStep]["bulk"] is not empty then
            if sMainShort[pDoc][tStep]["read"] is not empty or sMainShort[pDoc][tStep]["bulk"] is not empty then
               -- which direction to travel depends on pDirection
               repeat for each line tLink in sMainShort[pDoc][tStep][word 1 of pDirection]
                  replace cr with "" in tLink
                  -- (3) remove link Y from notVisited
                  set the wholeMatches to true
                  delete item itemOffset(tLink,sNotVisited[pDoc]) in sNotVisited[pDoc]
                  set the wholeMatches to false
                  put sMainShort[pDoc][tLink][word 1 of pDirection] into tNodeZ
                  replace cr with "" in tNodeZ
                  put true into tLast
                  repeat for each line tSameType in sMainShort[pDoc][tNodeZ][word 2 of pDirection]
                     replace cr with "" in tSameType
                     if tSameType is among the items of sNotVisited[pDoc] then
                        put false into tLast
                        exit repeat
                     end if
                  end repeat -- tSameType in tNodeZ
                  if tLast is true then
                     -- (4) all of the preceeding links of this type have been visited
                     put tNodeZ & "," after tNextList
                     -- scopeRef
                     -- tStep and tNodeZ are scope linked, not flow linked, so tNodeZ is encased by tStep (in or out)
                     -- research tNodeZ
                     put tagBoolean(pDoc,tNodeZ) into tTags
                     put empty into sResources[pDoc][tNodeZ]["scopeRef"]
                     -- figure out how to label tNodeZ
                     --                     put sResources[pDoc][tStep]["scopeRef"] into tLevel
                     --                     sort lines of tLevel ascending numeric by item 1 of each
                     --                     if item 1 of line one of tLevel is 0 then -- special pseudo case node for stuff not encased
                     --                        if tTags["next"] and not tTags["prev"] then put cr & "0,in" after sResources[pDoc][tNodeZ]["scopeRef"]
                     --                        if tTags["next"] and tTags["prev"] then put cr & "0,thru" after sResources[pDoc][tNodeZ]["scopeRef"]
                     --                        if not tTags["next"] and tTags["prev"] then put cr & "0,out" after sResources[pDoc][tNodeZ]["scopeRef"]
                     --                        if tTags["read"] and tTags["bulk"] then put cr & "0,top" after sResources[pDoc][tNodeZ]["scopeRef"]
                     switch
                        case not tTags["next"] and not tTags["prev"] -- solo
                           put tStep & ",solo" into sResources[pDoc][tNodeZ]["scopeRef"]
                           if tNodeZ is not among the items of sScopeSketch[pDoc][tStep]["solo"] then \
                                 put tNodeZ & "," after sScopeSketch[pDoc][tStep]["solo"]
                           break
                        case tTags["skim"] and tTags["next"] and not tTags["prev"] -- in
                           put tStep & ",in" into sResources[pDoc][tNodeZ]["scopeRef"]
                           if tNodeZ is not among the items of sScopeSketch[pDoc][tStep]["in"] then \
                                 put tNodeZ & "," after sScopeSketch[pDoc][tStep]["in"]
                           break
                        case tTags["next"] and tTags["prev"] and not tTags["skim"] and not tTags["trim"] -- thru
                           -- can't be thru at the moment, but whatevs
                           put tStep & ",thru" into sResources[pDoc][tNodeZ]["scopeRef"]
                           if tNodeZ is not among the items of sScopeSketch[pDoc][tStep]["thru"] then \
                                 put tNodeZ & "," after sScopeSketch[pDoc][tStep]["thru"]
                           break
                        case tTags["trim"] and tTags["prev"] and not tTags["next"] -- out
                           put tStep & ",out" into sResources[pDoc][tNodeZ]["scopeRef"]
                           if tNodeZ is not among the items of sScopeSketch[pDoc][tStep]["out"] then \
                                 put tNodeZ & "," after sScopeSketch[pDoc][tStep]["out"]
                           break
                     end switch
                     -- can be a top, in addition to solo/in/thru/out
                     if tTags["bulk"] or tTags["read"] then -- top
                        put cr & tStep & ",top" after sResources[pDoc][tNodeZ]["scopeRef"]
                        if tNodeZ is not among the items of sScopeSketch[pDoc][tStep]["top"] then \
                              put tNodeZ & "," after sScopeSketch[pDoc][tStep]["top"]
                     end if
                     filter sResources[pDoc][tNodeZ]["scopeRef"] without empty
                     --                  else -- not 0
                     --                     put item 1 of line (lineOffset("top",tLevel)) of tLevel into tLevel -- top labels lower scope level
                     --                     -- if scoped properly (not 0) tNodeZ can't be thru, at least not yet
                     --                     --                        if tTags["next"] and tTags["skim"] and not tTags["prev"] then put cr & tLevel & ",in" after sResources[pDoc][tNodeZ]["scopeRef"]
                     --                     --                        if not tNext and tPrev and tTrim then put cr & tLevel & ",out" after sResources[pDoc][tNodeZ]["scopeRef"]
                     --                     --                        if tTags["read"] and tTags["bulk"] then put cr & (tLevel+1) & ",top" after sResources[pDoc][tNodeZ]["scopeRef"]

                     --                     filter sResources[pDoc][tNodeZ]["scopeRef"] without empty
                     --                  end if -- tStep scope 0/n
                  end if -- tLast true/false
               end repeat -- tLink in tStep
            end if -- both read and bulk links
            ------------- flow link(s) ----------------------------------------------------------------
            -- (2) follow follow next or prev
            repeat for each line tLink in sMainShort[pDoc][tStep][word 3 of pDirection]
               replace cr with "" in tLink
               -- (3) remove link Y from notVisited
               set the wholeMatches to true
               delete item itemOffset(tLink,sNotVisited[pDoc]) in sNotVisited[pDoc]
               set the wholeMatches to false
               put sMainShort[pDoc][tLink][word 3 of pDirection] into tNodeZ
               replace cr with "" in tNodeZ
               put true into tLast
               repeat for each line tSameType in sMainShort[pDoc][tNodeZ][word 4 of pDirection]
                  replace cr with "" in tSameType
                  if tSameType is among the items of sNotVisited[pDoc] then
                     put false into tLast
                     exit repeat
                  end if
               end repeat -- tSameType in tNodeZ
               if tLast is true then
                  -- (4) all of the preceeding links of this type have been visited
                  put tNodeZ & "," after tNextList
                  -- scopeRef
                  -- tStep and tNodeZ are flow linked, not scope linked, so same scope level
                  -- research tNodeZ
                  put tagBoolean(pDoc,tNodeZ) into tTags
                  put empty into sResources[pDoc][tNodeZ]["scopeRef"]
                  put item 1 of line 1 of sResources[pDoc][tStep]["scopeRef"] into tCase
                  -- figure out how to label tNodeZ
                  --                  put sResources[pDoc][tStep]["scopeRef"] into tLevel
                  --                  sort lines of tLevel ascending numeric by item 1 of each
                  --                  if item 1 of line one of tLevel is 0 then -- special case for everything not properly scoped
                  --                     if tTags["next"] and not tTags["prev"] then put cr & "0,in" after sResources[pDoc][tNodeZ]["scopeRef"]
                  --                     if tTags["next"] and tTags["prev"] then put cr & "0,thru" after sResources[pDoc][tNodeZ]["scopeRef"]
                  --                     if not tTags["next"] and tTags["prev"] then put cr & "0,out" after sResources[pDoc][tNodeZ]["scopeRef"]
                  --                     if tTags["read"] and tTags["bulk"] then put cr & "0,top" after sResources[pDoc][tNodeZ]["scopeRef"]
                  --                     filter sResources[pDoc][tNodeZ]["scopeRef"] without empty
                  --                  else -- not 0
                  --                     put item 1 of line 1 of tLevel into tLevel -- same scope level
                  --                     if tTags["next"] and tTags["skim"] and not tTags["prev"] then put cr & tLevel & ",in" after sResources[pDoc][tNodeZ]["scopeRef"]
                  --                     if tTags["next"] and tTags["prev"] and not tTags["trim"] and not tTags["skim"] then put cr & tLevel & ",thru" after sResources[pDoc][tNodeZ]["scopeRef"]
                  --                     if not tTags["next"] and tTags["prev"] and tTags["trim"] then put cr & tLevel & ",out" after sResources[pDoc][tNodeZ]["scopeRef"]
                  --                     if tTags["read"] and tTags["bulk"] then put cr & (tLevel+1) & ",top" after sResources[pDoc][tNodeZ]["scopeRef"]
                  --                     filter sResources[pDoc][tNodeZ]["scopeRef"] without empty
                  --                  end if -- tStep scope 0/n
                  switch
                     case not tTags["next"] and not tTags["prev"] -- solo
                        put tCase & ",solo" into sResources[pDoc][tNodeZ]["scopeRef"]
                        if tNodeZ is not among the items of sScopeSketch[pDoc][tCase]["solo"] then \
                              put tNodeZ & "," after sScopeSketch[pDoc][tCase]["solo"]
                        break
                     case tTags["skim"] and tTags["next"] and not tTags["prev"] -- in
                        put tCase & ",in" into sResources[pDoc][tNodeZ]["scopeRef"]
                        if tNodeZ is not among the items of sScopeSketch[pDoc][tCase]["in"] then \
                              put tNodeZ & "," after sScopeSketch[pDoc][tCase]["in"]
                        break
                     case tTags["next"] and tTags["prev"] and not tTags["skim"] and not tTags["trim"] -- thru
                        -- can't be thru at the moment, but whatevs
                        put tCase & ",thru" into sResources[pDoc][tNodeZ]["scopeRef"]
                        if tNodeZ is not among the items of sScopeSketch[pDoc][tCase]["thru"] then \
                              put tNodeZ & "," after sScopeSketch[pDoc][tCase]["thru"]
                        break
                     case tTags["trim"] and tTags["prev"] and not tTags["next"] -- out
                        put tCase & ",out" into sResources[pDoc][tNodeZ]["scopeRef"]
                        if tNodeZ is not among the items of sScopeSketch[pDoc][tCase]["out"] then \
                              put tNodeZ & "," after sScopeSketch[pDoc][tCase]["out"]
                        break
                  end switch
                  -- can be a top, in addition to solo/in/thru/out
                  if tTags["bulk"] or tTags["read"] then -- top
                     put cr & tCase & ",top" after sResources[pDoc][tNodeZ]["scopeRef"]
                     if tNodeZ is not among the items of sScopeSketch[pDoc][tCase]["top"] then \
                           put tNodeZ & "," after sScopeSketch[pDoc][tCase]["top"]
                  end if
                  filter sResources[pDoc][tNodeZ]["scopeRef"] without empty
               end if -- if tLast is true
            end repeat -- tLink in tStep, "next"
         end if -- tStep is in sNotVisited[pDoc]
         -- (5)
         if tNextList is not empty then
            get gravitySort(pDoc,tNextList,pDirection)
         end if
         --------- travel -----------------
      end repeat -- each tStep in pSeedList
end gravitySort

function ceilingNum pNumber
   -- got this from the interwebs because apparently livecode doesn't have a ceilingNum function
   ## Check we have been passed a number
   if pNumber is not a number then
      return "Error: not a number"
   end if
   ## Check if the number is already an integer or is negative
   if pNumber < zero or pNumber is an integer then
      ## truncating gives the ceilingNum
      return trunc(pNumber)
   else
      ## truncate the number and add 1 to get the ceilingNum
      return trunc(pNumber) + 1
   end if
end ceilingNum

command render
   adjList
   topoSort
   ------------------------------------ instructions -------------------------
   -- notes
   --   set the imageSource of char -1 of line 9 of fld "textInstr" to the short id of img "testImg"
   --   set the textShift of char -1 of line 9 of fld "textInstr" to 100
   -- end notes
   -- adjList creates a simple adjacency list
   -- kahn sort
   --   put empty into field "textInstr" stack "primary"
   --   put empty into tInstructions
   --   put empty into tFootnotes -- array[tDoc]=1,2,3,n note rec in footnote order
   --   put empty into tIndent
   --   put empty into tScope
   repeat for each key tDoc in sTopoSort
      put empty into tInstructions
      put empty into tFootnotes -- array[tDoc]=1,2,3,n note rec in footnote order
      put empty into tIndent
      put empty into tScope
      repeat for each item tRec in sTopoSort[tDoc]
         put empty into tTheNotes
         -- use OPEN label if this is the first reference to a particular container node, and increase indent
         -- use CLOSE label if this is the second reference, and decrease indent
         if sMainShort[tDoc][tRec]["read"] is not empty and sMainShort[tDoc][tRec]["bulk"] is not empty then
            if tRec is among the items of tScope then
               -- container node, and second time listed
               put cr & tIndent && "CLOSE" && stepString(tDoc,tRec) after tInstructions
               delete char -1 of tIndent
            else -- container node, first time listed
               put cr & tIndent && itemOffset(tRec,sTopoSort[tDoc]) && "OPEN" && stepString(tDoc,tRec) after tInstructions
               put tRec & "," after tScope
               put "-" after tIndent
            end if -- tRec among tScope
         else -- not a container node
            put cr & tIndent && itemOffset(tRec,sTopoSort[tDoc]) && stepString(tDoc,tRec) after tInstructions
         end if -- read and bulk not empty
         -- build the footnote list
         if tRec is among the keys of sNoteList[tDoc] then
            -- this step has one or more notes
            repeat for each item tNote in sNoteList[tDoc][tRec]
               if tNote is among the items of tFootnotes[tDoc] then
                  -- this note, bonded to tRec, already has a footnote position
                  put itemOffset(tNote,tFootnotes[tDoc]) & "," after tTheNotes
               else
                  -- this note, bonded to tRec, does not yet have a footnote position
                  put tNote & "," after tFootnotes[tDoc]
                  put itemOffset(tNote,tFootnotes[tDoc]) & "," after tTheNotes
               end if
            end repeat
            if char -1 of tTheNotes is "," then delete char -1 in tTheNotes
            put " *" & tTheNotes & cr after tInstructions
         end if
      end repeat -- tRec in sTopoSort[tDoc]
      put cr & "NOTES" after tInstructions
      repeat for each item tFoot in tFootnotes[tDoc]
         put cr & itemOffset(tFoot,tFootnotes[tDoc]) && stepString(tDoc,tFoot) after tInstructions
      end repeat -- tFoot in tFootnotes
      -------- orphans ------------------
      if sNotVisited[tDoc] is not empty then
         put empty into tRollCall
         repeat for each item tOrphan in sNotVisited[tDoc]
            if sMainShort[tDoc][tOrphan]["type"] is among the words of "state change" then
               put cr & stepString(tDoc,tOrphan) after tRollCall
            end if
         end repeat
         if tRollCall is not empty then
            put cr & "ORPHANS" after tInstructions
            put tRollCall after tInstructions
         end if
      end if
   end repeat -- tDoc in sTopoSort
   filter tInstructions without empty
   put tInstructions into field "textInstr" stack "primary"
   if tInstructions is empty then put \
         "Network unclear. At least one node must have both dive and rise links." into field "textInstr" stack "primary"
   ------------------------------------ instructions ------------------------------
   ------------------------------------ resources ---------------------------------
   supplyDemand -- calls gravitySort, which calls gravitySort, which calls gravitySort...
   --   put empty into tScope
   --   repeat for each key tKey in sResources[sNowDoc]
   --      repeat for each line tLine in sResources[sNowDoc][tKey]["scopeRef"]
   --         put tKey & "," after tScope[item 1 of tLine][item 2 of tLine]
   --      end repeat
   --   end repeat
   --   put empty into sScope[sNowDoc]
   --   repeat for each key tKey in sResources[sNowDoc]
   --      repeat for each line tLine in sResources[sNowDoc][tKey]["scopeRef"]
   --         put tKey & "," after sScope[sNowDoc][item 1 of tLine][item 2 of tLine]
   --      end repeat
   --   end repeat

   --   put empty into field "resourceField" stack "primary"
   --   put empty into tList
   -- for each key in sScopeSketch[sNowDoc]
   -- build summary string, put in tArray[blerg]
   -- for each key in sScopeSketch[sNowDoc]
   -- replace top with relevant summary string
   -- string
   -- OPEN whatever
   -- IN
   -- THRU
   -- OUT
   -- MISC
   -- second time
   -- repeat until all recs in tStrings visited
   -- start with "rec" 0
   -- replace a number alone on a line with it's string and some dashes based on counter
   -- next cycle will have new text from the string added, so replace numbers alone on lines

   --   build a string to summarize each case node
   put empty into tStrings
   repeat for each key tCase in sScopeSketch[sNowDoc]
      if tCase = 0 then
         -- maybe just don't print anything
      else
         put "OPEN" && stepString(sNowDoc,tCase) & cr into tStrings[tCase]
      end if
      put "IN-PUT" & cr after tStrings[tCase]
      repeat for each item tN in sScopeSketch[sNowDoc][tCase]["in"]
         -- if this also has role top, just put its rec alone on a line
         if tN is among the keys of sScopeSketch[sNowDoc] then
            put tN & cr after tStrings[tCase]
         else
            put sResources[sNowDoc][tN]["totDemand"] && "x" && stepString(sNowDoc,tN) & cr after tStrings[tCase]
         end if
      end repeat
      put "THRU-PUT" & cr after tStrings[tCase]
      put empty into tData
      repeat for each item tH in sScopeSketch[sNowDoc][tCase]["thru"]
         put sResources[sNowDoc][tH]["excess"] into tMuch
         if tMuch is not 0 and tMuch is not empty then
            if tH is among the keys of sScopeSketch[sNowDoc] then
               put tH & cr after tData
            else
               put tMuch && "x" && stepString(sNowDoc,tH) & cr after tData
            end if
         end if
      end repeat
      if tData is empty then
         put "supply=demand" & cr after tStrings[tCase]
      else
         put tData after tStrings[tCase]
      end if
      put "OUT-PUT" & cr after tStrings[tCase]
      repeat for each item tU in sScopeSketch[sNowDoc][tCase]["out"]
         if tU is among the keys of sScopeSketch[sNowDoc] then
            put tU & cr after tStrings[tCase]
         else
            put sResources[sNowDoc][tU]["totSupply"] && "x" && stepString(sNowDoc,tU) & cr after tStrings[tCase]
         end if
      end repeat
      put "NOT-PUT" & cr after tStrings[tCase]
      repeat for each item tS in sScopeSketch[sNowDoc][tCase]["solo"]
         if tS is among the keys of sScopeSketch[sNowDoc] then
            put tS & cr after tStrings[tCase]
         else
            put sResources[sNowDoc][tS]["totSupply"] && "x" && stepString(sNowDoc,tS) & cr after tStrings[tCase]
         end if
      end repeat
   end repeat -- tCase in sScopeSketch[sNowDoc]
   -- build a bigger string with the case node summaries nested appropriately
   --   repeat for each key tKey in tStrings
   --      filter tStrings[tKey] without empty
   --   end repeat
   --   put tStrings[0] into tSummary -- 0 is a pseudo case to encase absolutely everything
   -- embed one string in another
   put " " into tIndent
   put the keys of sScopeSketch[sNowDoc] into tAll
   replace cr with "," in tAll -- items instead of lines
   put tStrings[0] into tDisplay
   filter tDisplay without empty -- remove any trailing cr
   put tDisplay into tWorking
   put true into tAgain
   repeat while tAgain is true
      put false into tAgain
      put empty into tInserts
      put "-" before tIndent
      repeat with tJ = 1 to the number of lines of tWorking
         put line tJ of tWorking into tWorkIt
         replace " " with "" in tWorkIt
         replace "-" with "" in tWorkIt
         replace cr with "" in tWorkIt
         -- if tWorkIt has a rec then it should be just the clean rec now
         if tWorkIt is among the items of tAll then
            put tStrings[tWorkIt] into tInserts[tJ]["string"] -- so now array[line offset][string]=new string
            --            replace cr with (cr & tIndent) in tInserts[tJ]["string"]
            repeat with tJJ = 1 to the number of lines of tInserts[tJ]["string"]
               put tIndent before line tJJ of tInserts[tJ]["string"]
            end repeat
            put tWorkIt into tInserts[tJ]["rec"] -- so now array[line offset][rec]=num to replace
         end if
         if tJ = the number of lines of tWorking then
            -- the last line was just checked to see if it needed replacing
            put the keys of tInserts into tOrder
            sort tOrder numeric descending -- highest line offset to lowest
            repeat for each line tNext in tOrder
               put true into tAgain
               -- insert replacement text starting at the highest line offset to preserve place
               --               replace tInserts[tNext]["rec"] with tInserts[tNext]["string"] in line tNext of tWorking
               -- delete line
               -- insert new string before line
               delete line tNext of tWorking
               put tInserts[tNext]["string"] before line tNext of tWorking
            end repeat
         end if
      end repeat -- tJ
      put tWorking into tDisplay
   end repeat -- tAgain

   put tDisplay into field "resourceField" stack "primary"

   ------------------------------------ resources ---------------------------------
   ------------------------------------ graphical network -----------------------
   -- coordinates are added/changed elsewhere
   put the keys of sMain[sNowDoc] into tDoc
   sort tDoc numeric ascending
   delete line 1 of tDoc -- rec 0, metadata
   -- go through each rec in the active doc
   repeat for each line tRec in tDoc
      -- only worry about displaying steps (nodes and links)
      if "step" is among the keys of sMain[sNowDoc][tRec] then
         -- positive T/F
         put clearNegPairs(sMain[sNowDoc][tRec]["step"]) into tRecPtrs
         if tRecPtrs is empty then
            put false into tPos
         else
            put true into tPos
         end if
         -- graphic T/F
         if sGraphics[sNowDoc][tRec]["longID"] is empty then
            put false into tGraph
         else
            put true into tGraph
         end if
         -- node T/F
         put isAnode(sNowDoc,tRec) into tFacts
         if tFacts is "false" then
            put false into tNode
         else
            put true into tNode
         end if

         -- case: positive & node & no graphic - create field -----------------------
         if tPos and tNode then
            put listOfLinks(tRec) into sGraphics[sNowDoc][tRec]["links"]
            -- if no graphic exists, create it, since this node should be rendered
            if not tGraph then
               put getTagData(tRec,"coord",sNowDoc) into tXY
               -- just in case
               if tXY is empty and tRec is 2 then put "500,100" into tXY
               if tXY is empty then put the loc of group "graphicNetwork" into tXY
               set the loc of the templateField to netToWinCoord(tXY)
               set the textAlign of the templateField to center
               set the margins of the templateField to 5
               set the opaque of the templateField to true
               set the lockText of the templateField to true
               set the threeD of the templateField to false
               set the borderWidth of the templateField to 1
               set the autoHilite of the templateField to false
               -- the object has to already exist for some things to work
               create field in group "graphicNetwork" of stack "primary"
               put the long name of it into sGraphics[sNowDoc][tRec]["longID"]
               set the cRecKey of sGraphics[sNowDoc][tRec]["longID"] to tRec
               set the cHilited of sGraphics[sNowDoc][tRec]["longID"] to false
               set the text of sGraphics[sNowDoc][tRec]["longID"] to stepString(sNowDoc,tRec)
               set the width of sGraphics[sNowDoc][tRec]["longID"] to the formattedWidth of sGraphics[sNowDoc][tRec]["longID"]
               set the height of sGraphics[sNowDoc][tRec]["longID"] to the formattedHeight of char 1 to - 1 of sGraphics[sNowDoc][tRec]["longID"]
               set the behavior of sGraphics[sNowDoc][tRec]["longID"] to the long id of button "graphNetNodeBehave" stack "primary"
            end if
         end if
         -- case: positive & node & yes graphic - show graphic -----------------------
         if tPos and tNode and tGraph then
            put getTagData(tRec,"coord",sNowDoc) into tDoubleCheck
            put tDoubleCheck into sGraphics[sNowDoc][tRec]["coord"]
            set the text of sGraphics[sNowDoc][tRec]["longID"] to stepString(sNowDoc,tRec)
            set the width of sGraphics[sNowDoc][tRec]["longID"] to the formattedWidth of sGraphics[sNowDoc][tRec]["longID"]
            set the height of sGraphics[sNowDoc][tRec]["longID"] to the formattedHeight of char 1 to - 1 of sGraphics[sNowDoc][tRec]["longID"]
            set the loc of sGraphics[sNowDoc][tRec]["longID"] to netToWinCoord(tDoubleCheck)
            set the visible of sGraphics[sNowDoc][tRec]["longID"] to true
         end if
         -- case: negative & node & yes graphic - hide graphic -----------------------
         if not tPos and tNode and tGraph then
            set the visible of sGraphics[sNowDoc][tRec]["longID"] to false
         end if
         -- case: positive & link & no graphic - create line -----------------------
         if tPos and not tNode and not tGraph then
            set the style of the templateGraphic to "line"
            set the endArrow of the templateGraphic to false
            set the startArrow of the templateGraphic to false
            -- create graphic
            create graphic in group "graphicNetwork" of stack "primary"
            put the long name of it into sGraphics[sNowDoc][tRec]["longID"]
            set the cRecKey of sGraphics[sNowDoc][tRec]["longID"] to tRec
            set the cHilited of sGraphics[sNowDoc][tRec]["longID"] to false
            put isAlink(sNowDoc,tRec) into tFacts
            put tFacts["X"] into sGraphics[sNowDoc][tRec]["Xnode"] -- record
            put tFacts["Z"] into sGraphics[sNowDoc][tRec]["Znode"] -- record
            put tFacts["type"] into sGraphics[sNowDoc][tRec]["type"]
            put getTagData(tFacts["X"],"coord",sNowDoc) into tXcoord -- coordinates
            put getTagData(tFacts["Z"],"coord",sNowDoc) into tZcoord -- coordinates
            put calcLinkCoord(tXcoord,tZcoord,tFacts["type"]) into tTheCoord
            set the behavior of sGraphics[sNowDoc][tRec]["longID"] to the long id of button "graphNetLinkBehave" stack "primary"
            -- set points
            set the points of sGraphics[sNowDoc][tRec]["longID"] to netToWinCoord(tTheCoord)
         end if
         -- case: positive & link & yes graphic - show graphic -----------------------
         if tPos and not tNode and tGraph then
            -- ! if the nodes this link connects were changed this might not work
            put getTagData(sGraphics[sNowDoc][tRec]["Xnode"],"coord",sNowDoc) into tTheX
            put getTagData(sGraphics[sNowDoc][tRec]["Znode"],"coord",sNowDoc) into tTheZ
            put sGraphics[sNowDoc][tRec]["type"] into tTheType
            put calcLinkCoord(tTheX,tTheZ,tTheType) into tThePoints
            set the points of sGraphics[sNowDoc][tRec]["longID"] to netToWinCoord(tThePoints)
            set the visible of sGraphics[sNowDoc][tRec]["longID"] to true
         end if
         -- case: negative & link & yes graphic - hide graphic -----------------------
         if not tPos and not tNode and tGraph then
            set the visible of sGraphics[sNowDoc][tRec]["longID"] to false
         end if
         -- no action in case where step is negated and has no graphic
      end if -- tRec
   end repeat -- tDoc
   -- fill the graphic tooltips
   repeat for each key tDoc in sGraphics
      repeat for each key tRec in sGraphics[tDoc]
         put sGraphics[tDoc][tRec]["longID"] into tGraphic
         set the tooltip of tGraphic to empty
         repeat for each word tInfo in "weight material duration whole series"
            put getTagData(tRec,tInfo,tDoc) into tData
            if tData is not empty then
               put the tooltip of tGraphic into tTip
               put cr & tInfo & ": " & tData after tTip
               filter tTip without empty
               set the tooltip of tGraphic to tTip
            end if
         end repeat -- tInfo (tag word)
      end repeat -- tRec
   end repeat -- tDoc
   ------------------------------------ graphical network -----------------------
   --------------------------------------- rTree ------------------------------------
   -- setup the array for display in rTree
   put empty into tForTree
   put "Doc " & sNowDoc into tDoc
   put false into tForTree["0"]["useContextMenu"] -- We do not want a contextmenu
   put true into tForTree["0"]["useConnectionLines"] -- We want connection lines between the nodes
   --      put false into tForTree["0"]["useThirdIcon"] -- we do not want to display a thirdIcon in this case
   --   put "Rootnode" into tForTree["0"]["rootNodeIds"] -- this creates the first rootNode
   put tDoc into tForTree["0"]["rootNodeIds"] -- this creates the first rootNode
   -- put cr & "Rootnode 2" after tForTree["0"]["rootNodeIds"]

   put the keys of sMain[sNowDoc] into tDocKeys
   sort tDocKeys numeric ascending
   delete line 1 of tDocKeys -- ignore rec 0
   if sDevEyes is true then
      -------------- show everything for development -------------------
      repeat for each line tRec in tDocKeys
         put cr & tRec after tForTree[tDoc]["children"]
         put the keys of sMain[sNowDoc][tRec] into tTags
         sort tTags descending
         repeat for each line tLine in tTags
            put cr & tRec && tLine after tForTree[tRec]["nodeText"]["text"]
            put sMain[sNowDoc][tRec][tLine] into tData
            replace cr with ";" in tData
            put " " & tData after tForTree[tRec]["nodeText"]["text"]
            filter tForTree[tRec]["nodeText"]["text"] without empty
         end repeat
         if "step" is among the keys of sMain[sNowDoc][tRec] then put sMain[sNowDoc][tRec]["step"] into tPointers
         if "turn" is among the keys of sMain[sNowDoc][tRec] then put sMain[sNowDoc][tRec]["turn"] into tPointers
      end repeat
   else
      ----------- show only what users need to see --------------------
      put "type title coord myStep myTurn" into tNoShow
      repeat for each line tRec in tDocKeys
         -- make sure it's a step
         if "step" is among the keys of sMain[sNowDoc][tRec] then
            put clearNegPairs(sMain[sNowDoc][tRec]["step"]) into tPointers
            -- make sure it has at least one positive pointer
            if tPointers is not empty then
               put cr & tRec after tForTree[tDoc]["children"]
               -- title the step
               put stepString(sNowDoc,tRec) into tForTree[tRec]["nodeText"]["text"]
               -- build children
               repeat for each line tPtr in tPointers
                  put item 1 of tPtr into tPtr
                  repeat for each key tTag in sMain[sNowDoc][tPtr]
                     if tTag is not among the words of tNoShow then
                        put cr & tPtr after tForTree[tRec]["children"]
                        ----------- what kind of tag -----------------
                        if tTag is not among the words of "bond next prev skim read bulk trim" then
                           ---------- random informational tag ------------
                           put tTag & ":" && sMain[sNowDoc][tPtr][tTag] into tForTree[tPtr]["nodeText"]["text"]
                        else
                           --------- link tag ----------------------
                           put tTag & ":" into tForTree[tPtr]["nodeText"]["text"]
                           put sMain[sNowDoc][tPtr][tTag] into tLinkPointers
                           repeat for each line tLinkPtr in tLinkPointers
                              put item 1 of tLinkPtr into tLinkPtr
                              put sMain[sNowDoc][tLinkPtr]["myStep"] into tStep
                              put item 1 of tStep into tStep
                              put stepString(sNowDoc,tStep) after tForTree[tPtr]["nodeText"]["text"]
                           end repeat
                        end if
                     end if
                  end repeat
               end repeat
            end if
         end if
      end repeat
   end if
   -- ! this needs to make rTree look like it did before
   repeat for each key tNode in tForTree
      if tNode is among the lines of sExpanded or tNode is ("doc " & sNowDoc) then
         put true into tForTree[tNode]["expanded"]
      else
         put false into tForTree[tNode]["expanded"]
      end if
   end repeat
   dispatch "nodeData" to grp "treeList" with tForTree
   dispatch "renderTree" to grp "treeList"
   ------------------------------------ rTree ---------------------------------------
   ------------------------------------ buttons -----------------------------------
   -- toggle undoButt/redoButt availability
   -- undoButt is available if a single turn has a single positive pointer
   -- redoButt is available if the youngest turn has no positive pointers
   -- the following counts backwards through the records
   -- it ignores any record that's not a turn (also ignores undo turns)
   -- when it gets to the youngest turn it checks for positive pointers
   -- if no positive pointers in the youngest turn, enable redoButt & repeat again
   -- if youngest turn has positive pointers, enable undoButt & exit (can't redo)
   -- if redoButt was enabled, continues counting back to next turn
   -- continues to record 1
   -- if no turns have a positive pointer undoButt stays disabled
   -- exits repeat as soon as undoButt enabled
   set the disabled of button "undoButt" stack "primary" to true
   set the disabled of button "redoButt" stack "primary" to true
   put the keys of sMain[sNowDoc] into tRecords
   sort tRecords numeric descending
   repeat for each line tRec in tRecords
      if "turn" is among the keys of sMain[sNowDoc][tRec] then
         --         if sMain[sNowDoc][tRec]["act"] is "userUndo" then next repeat
         if sMain[sNowDoc][tRec]["act"] contains "do" then next repeat
         if clearNegPairs(sMain[sNowDoc][tRec]["turn"]) is empty then
            set the disabled of button "redoButt" stack "primary" to false
         else
            set the disabled of button "undoButt" stack "primary" to false
            exit repeat
         end if
      end if
   end repeat
   ------------------------------------ buttons -----------------------------------
   relayerGraphics
   UIcheck
end render

command relayerGraphics
   put the layer of graphic "floorRect" of group "graphicNetwork" stack "primary" into tLowest
   repeat for each key tRec in sGraphics[sNowDoc]
      -- check if this rec is for a link
      -- push all links to the bottom
      if "type" is among the keys of sGraphics[sNowDoc][tRec] then
         set the relayerGroupedControls to true
         set the layer of sGraphics[sNowDoc][tRec]["longID"] to tLowest + 1
         set the relayerGroupedControls to false
      end if
   end repeat
end relayerGraphics

function calcLinkCoord startNode,endNode,theType
   -- use network coordinates, not window coordinates
   -- startNode (X)= x,y start of the line
   -- endNode (Z)= x,y end of the line
   -- theType = string

   -- ! this is a weird exception for the beginning and ending dive/rise links
   -- ! it really shouldn't be here, but this is a convenient place to do it
   put getTagData(1,"coord",sNowDoc) into tTitleCoord
   if theType is "dive" then
      if startNode is tTitleCoord then put (item 1 of endNode)-50 & "," & item 2 of endNode into startNode
   end if
   if theType is "rise" then
      if endNode is tTitleCoord then put (item 1 of startNode)+50 & "," & item 2 of startNode into endNode
   end if

   -- ! these control what the links look like------------------------------------------------
   put "-8,0" & cr & "0,0" & \
         cr & cr & "-4,-4" & cr & "0,0" & cr & "-4,4" into flowArrow
   put "-9,9" & cr & "0,0" & cr & "-9,-9" & \
         cr & cr & "0,4" & cr & "0,-4" & \
         cr & cr & "-4,0" & cr & "0,0" into diveArrow
   put "9,9" & cr & "0,0" & cr & "9,-9" & \
         cr & cr & "5,9" & cr & "9,9" & cr & "9,5" & \
         cr & cr & "5,-9" & cr & "9,-9" & cr & "9,-5" into riseArrow
      put 22 into arrowSpacing

   -- tSimpleLine is the set of coords that define the start and end of the link
   -- find coord of X and Z step
   --   put getTagData(startNode,"coord") into tStartCoord
   --   put getTagData(endNode,"coord") into tEndCoord
   put startNode & cr & endNode into tSimpleLine
   filter tSimpleLine without empty
   switch
      case theType is "bond"
         -- bond is easy, just a line
         put tSimpleLine into tFinalLine
         break
      default
         -- draw based on theType
         put divideLine(tSimpleLine,arrowSpacing) into tChoppedUp
         put empty into tListOfMids
         repeat for each line tLine in tChoppedUp
            if not (tLine is in tListOfMids) then
               put tLine & return after tListOfMids
            end if
         end repeat
         filter tListOfMids without empty
         -- figure out which arrow shape to pass
         switch theType
            case "flow"
               put rotateCoord(flowArrow,tSimpleLine) into tPointedArrow
               break
            case "dive"
               put rotateCoord(diveArrow,tSimpleLine) into tPointedArrow
               break
            case "rise"
               put rotateCoord(riseArrow,tSimpleLine) into tPointedArrow
               break
         end switch
         -- now I have the offset for the arrow's points from each midpoint
         -- create a new list of points
         -- make a copy of the now rotated arrow's coordinates
         -- translate based on list of mid points
         repeat for each line tLine in tListOfMids
            put translateCoord(tPointedArrow,tLine) into tMovedArrow
            put tMovedArrow & cr & cr after tAllMovedArrows
         end repeat
         put batchRoundCoord(tAllMovedArrows) into tFinalLine
   end switch
   return tFinalLine
end calcLinkCoord

function divideLine coordinates,distance
   -- coordinates = a list of two pairs of coordinates (x,y cr x,y)
   -- distance = maximum length of each subdivision
   put coordinates into tNewCoord
   -- calculate distance between coordinate pairs
   put (item 1 of line 2 of coordinates) - (item 1 of line 1 of coordinates) into tDistX
   put (item 2 of line 2 of coordinates) - (item 2 of line 1 of coordinates) into tDistY
   put sqrt(tDistX^2 + tDistY^2) into tHypot
   if distance < tHypot then
      -- divide distance in half
      put (tDistX / 2) + item 1 of line 1 of coordinates into tMidX
      put (tDistY / 2) + item 2 of line 1 of coordinates into tMidY
      -- coordinates for first half
      put line 1 of coordinates into tFirstCoord
      put return & tMidX & "," & tMidY after tFirstCoord
      -- coordinates for second half
      put tMidX & "," & tMidY into tNextCoord
      put return & line 2 of coordinates after tNextCoord
      -- call this function on each half
      put return & divideLine(tFirstCoord,distance) after tNewCoord
      put return & divideLine(tNextCoord,distance) after tNewCoord
   else
      return tNewCoord
   end if
   filter tNewCoord without empty
   sort tNewCoord ascending
   return tNewCoord
end divideLine

function rotateCoord coordinates,bearing
   -- coordinates = list of coordinates (x,y cr x,y cr x,y etc)
   -- bearing = a list of two pairs of coordinates for orientation (x,y cr x,y)
   -- tested this, it's not the problem
   put (item 1 of line 2 of bearing) - (item 1 of line 1 of bearing) into tDistX
   put (item 2 of line 2 of bearing) - (item 2 of line 1 of bearing) into tDistY

   -- tested this, it's not the problem
   put atan2(tDistX,tDistY) into tBearingAngle

   repeat for each line tLine in coordinates
      if tLine is empty then
         put return after tNewCoord
      else
         -- calculate angle of coordinates
         -- tested this, it's not the problem
         put atan2(item 1 of tLine,item 2 of tLine) into tAngle
         -- calculate coordinates' distance from origin
         put sqrt((item 1 of tLine)^2 + (item 2 of tLine)^2) into tHypot
         -- calculate new x coordinate
         put tHypot * cos(tAngle - tBearingAngle) into tNewX
         -- calculate new y coordinate
         put tHypot * sin(tAngle - tBearingAngle) into tNewY
         put return & tNewX & "," & tNewY after tNewCoord
      end if
   end repeat
   return tNewCoord
end rotateCoord

function translateCoord coordinates,newOrigin
   -- coordinates = a list of coordinates (x,y cr x,y cr x,y etc)
   -- newOrigin = a coordinate (x,y)
   repeat for each line tLine in coordinates
      if tLine is empty then put return after tNewCoord
      else
         -- translate along x axis
         put item 1 of tLine + item 1 of newOrigin into tNewX
         -- translate along y axis
         put item 2 of tLine + item 2 of newOrigin into tNewY
         put return & tNewX & "," & tNewY after tNewCoord
      end if
   end repeat
   return tNewCoord
end translateCoord

function batchRoundCoord coordinates
   -- coordinates = a list of coordinates (x,y cr x,y cr x,y etc)
   repeat for each line tLine in coordinates
      if tLine is empty then
         put return after tNewCoord
      else
         -- round the number off so it can be a point
         put the round of item 1 of tLine into tNewX
         put the round of item 2 of tLine into tNewY
         put return & tNewX & "," & tNewY after tNewCoord
      end if
   end repeat
   return tNewCoord
end batchRoundCoord

function netToWinCoord coordinates
   -- can accept two coordinate formats
   -- coordinates = #,# cr #,# cr #,# etc then assume x,y
   -- coordinates = x/y,# cr x/y,# cr x/y,# etc then the numbers are processed as x or y
   put field "scaleField" stack "primary" into tScale
   put hScroll of group "graphicNetwork" stack "primary" into tHscroll
   put vScroll of group "graphicNetwork" stack "primary" into tVscroll
   put item 1 of rect of group "graphicNetwork" stack "primary" into tHoffset
   put item 2 of rect of group "graphicNetwork" stack "primary" into tVoffset
   repeat for each line tLine in coordinates
      --      if tLine is not empty then
      --         put (item 1 of tLine * tScale * .01) - tHscroll + tHoffset into tNewX
      --         put (item 2 of tLine * tScale * .01) - tVscroll + tVoffset into tNewY
      --         put tNewX & "," & tNewY & return after tNewCoord
      --      else
      --         put return after tNewCoord
      --      end if
      if tLine is empty then
         put return after tNewCoord
      else
         if item 1 of tLine is "x" then put (item 2 of tLine * tScale * .01) - tHscroll + tHoffset after tNewCoord
         if item 1 of tLine is "y" then put (item 2 of tLine * tScale * .01) - tVscroll + tVoffset after tNewCoord
         if item 1 of tLine is a number then
            put (item 1 of tLine * tScale * .01) - tHscroll + tHoffset into tNewX
            put (item 2 of tLine * tScale * .01) - tVscroll + tVoffset into tNewY
            put tNewX & "," & tNewY & return after tNewCoord
         end if
      end if
   end repeat
   --   filter tNewCoord without empty
   return tNewCoord
end netToWinCoord

function winToNetCoord coordinates
   -- can accept two coordinate formats
   -- coordinates = #,# cr #,# cr #,# etc then assume x,y
   -- coordinates = x/y,# cr x/y,# cr x/y,# etc then the numbers are processed as x or y   put field "scaleField" stack "platyvue" into tScale
   put field "scaleField" stack "primary" into tScale
   put hScroll of group "graphicNetwork" stack "primary" into tHscroll
   put vScroll of group "graphicNetwork" stack "primary" into tVscroll
   put item 1 of rect of group "graphicNetwork" stack "primary" into tHoffset
   put item 2 of rect of group "graphicNetwork" stack "primary" into tVoffset
   repeat for each line tLine in coordinates
      --      if tLine is not empty then
      --         put (item 1 of tLine + tHscroll - tHoffset)/(tScale * .01) into tNewX
      --         put (item 2 of tLine + tVscroll - tVoffset)/(tScale * .01) into tNewY
      --         put tNewX & "," & tNewY & return after tNewCoord
      --      else
      --         put return after tNewCoord
      --      end if
      if tLine is empty then
         put return after tNewCoord
      else
         if item 1 of tLine is "x" then put (item 2 of tLine + tHscroll - tHoffset)/(tScale * .01) after tNewCoord
         if item 1 of tLine is "y" then put (item 2 of tLine + tVscroll - tVoffset)/(tScale * .01) after tNewCoord
         if item 1 of tLine is a number then
            put (item 1 of tLine + tHscroll - tHoffset)/(tScale * .01) into tNewX
            put (item 2 of tLine + tVscroll - tVoffset)/(tScale * .01) into tNewY
            put tNewX & "," & tNewY & return after tNewCoord
         end if
      end if
   end repeat
   --   filter tNewCoord without empty
   return tNewCoord
end winToNetCoord

command userDrag arguments
   -- arguments = long name of field, new x, new y, node's key in array
   -- these are in window coordinates
   --   lock screen
   -------- the node --------------------------
   put item 2 to 3 of arguments into tTheseCoords
   put item 4 of arguments into tNodeKey
   -- userDrag updates the loc of the graphic
   -- when dragging is done, userMoveNode will record the final loc
   put winToNetCoord(tTheseCoords) into sGraphics[sNowDoc][tNodeKey]["coord"]
   set the loc of (item 1 of arguments) to tTheseCoords

   ---------- links ------------------------------
   -- node can be connected to many links
   -- recalculate the points for each link
   repeat for each item tRec in sGraphics[sNowDoc][tNodeKey]["links"]
      -- ? which end of the link is X and which is Z ?
      put sGraphics[sNowDoc][tRec]["Xnode"] into tX
      put sGraphics[sNowDoc][tRec]["Znode"] into tZ
      -- has to be one or the other, so only have to test for one
      if tNodeKey = tX then
         put winToNetCoord(tTheseCoords) into tX
         put getTagData(tZ,"coord",sNowDoc) into tZ
      else
         put winToNetCoord(tTheseCoords) into tZ
         put getTagData(tX,"coord",sNowDoc) into tX
      end if
      put sGraphics[sNowDoc][tRec]["type"] into tType
      put calcLinkCoord(tX,tZ,tType) into tTheCoord
      set the points of sGraphics[sNowDoc][tRec]["longID"] to netToWinCoord(tTheCoord)
   end repeat
end userDrag

command userMoveNode nodeAndCoord
   -- ! I don't remember why there's userFinishDrag and userMoveNode
   -- nodeAndCoord (the cRecKey of me, the loc of me)
   -- drag is done, node has new location
   put item 1 of nodeAndCoord into tArgs["rec"]
   --   put item 2 to 3 of nodeAndCoord into tArgs["data"]
   put winToNetCoord(item 2 to 3 of nodeAndCoord) into tArgs["data"]
   put "coord" into tArgs["tag"]
   changeInfo(tArgs)
   render
end userMoveNode

command userFinishDrag
   -- ! I don't remember why there's userFinishDrag and userMoveNode
   -- ! maybe do this
   --   relayerLinkGraphics
end userFinishDrag

command userDeveloper pCheck
   -- sent when the user checks/unchecks the "developer" radio button
   -- pCheck is true or false based on button hilite
   put pCheck into sDevEyes
   render
end userDeveloper

command changeInfo pBlerg
   -- pBlerg is an array
   -- pBlerg["rec"] = step's record key
   -- pBlerg["tag"] = tag string (this will be in a rec different from the step's rec)
   -- pBlerg["data"] = new data

   -- if the change is identical to existing data, don't do anything
   if getTagData(pBlerg["rec"],pBlerg["tag"],sNowDoc) = pBlerg["data"] then exit changeInfo

   put sMain[sNowDoc][0][lastKey] into tRec
   -- create turn
   put tRec+2 & "," & tRec+1 into sMain[sNowDoc][tRec+1]["turn"]
   put "changeInfo" into sMain[sNowDoc][tRec+1]["act"]
   -- create new tag with new data
   put pBlerg["data"] into sMain[sNowDoc][tRec+2][pBlerg["tag"]]
   put tRec+1 & "," & tRec+1 into sMain[sNowDoc][tRec+2]["myTurn"]
   put pBlerg["rec"] & "," & tRec+1 into sMain[sNowDoc][tRec+2]["myStep"]
   put tRec+2 into sMain[sNowDoc][0][lastKey]
   -- negate node's old tag
   put getTagKey(pBlerg["rec"],pBlerg["tag"],sNowDoc) into tOldTag
   put cr & "-" & tOldTag & "," & tRec+1 after sMain[sNowDoc][pBlerg["rec"]]["step"]
   -- point to new tag
   put cr & tRec+2 & "," & tRec+1 after sMain[sNowDoc][pBlerg["rec"]]["step"]

   put "Unsaved" into field "savedField" stack "primary"
end changeInfo

function stepString tDaDoc,tEyeDee
   if tDaDoc is empty or tEyeDee is empty then break
   --takes in a step record and returns a string (type & id/title)
   put isAnode(tDaDoc,tEyeDee) into tType
   --   if tType is false then return "not a node"
   if tType is false then
      -- it's a link
      -- # type [x] to [z]
      put isAlink(tDaDoc,tEyeDee) into tLinkFacts
      put stepString(tDaDoc,tLinkFacts["X"]) into tX
      put stepString(tDaDoc,tLinkFacts["Z"]) into tZ
      put tEyeDee && tLinkFacts["type"] && "[" & tX & "]" && "to" && "[" & tZ & "]" into tTitle
      if tTitle is empty then put "(link)" && tEyeDee into tTitle
      return tTitle
   else
      -- it's a node
      put getTagData(tEyeDee,"title",tDaDoc) into tTitle
      if tTitle is empty then put tEyeDee && "blank" into tTitle
      put symbolLookup(tType) && tTitle into tThisString
      return tThisString
   end if
end stepString

function symbolLookup tArg --a lookup table for display symbols
   switch tArg
      case "state"
         return numtocodepoint(0x25A0) --box
      case "change"
         return numtocodepoint(0x25B2) --triangle
   end switch
   return "not found in symbolLookup function"
end symbolLookup
