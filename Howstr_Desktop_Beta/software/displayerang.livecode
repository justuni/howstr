script "displayerang"
function tempNodeDetails @pShort,tDo
   put "function TempNodeDetails" into xX["write"];    devLog xX
   -- pShort = sMainShort
   put tDo["info"] into tNodeRec
   put tDo["doc"] into tDoc
   put tNodeRec into tList["rec"] -- 4MAY2017 added so it's easy to specify the step record for this node
   -- build a cr separated string to put into a list field
   -- in links&node, then this node's title, then out links&node
   put pShort[tDoc][tNodeRec]["title"] into tTitle -- may or may not actually have a title
   put pShort[tDoc][tNodeRec]["type"] into tList["type"] -- 4MAY2017 added so node details can distinguish state/change
   -- pass onlyone along if required
   if tNodeRec is among the items of pShort[tDoc][0]["onlyone"] then
      put "true" into tList["onlyone"]
   end if
   put "prev skim" into tInTags
   put "next trim" into tOutTags
   put 0 into tLineCount
   -- in links&node
   -- ! I don't think [master] is necessary anymore, but it might be, I dunno 18JAN2016
   repeat for each word tTag in tInTags
      put pShort[tDoc][tNodeRec][tTag] into tLinks
      repeat for each line tLinkRec in tLinks
         put tLineCount + 1 into tLineCount
         put pShort[tDoc][tLinkRec]["weight"] into tLinkWeight
         if tLinkWeight is empty then put "1" into tLinkWeight
         put pShort[tDoc][tLinkRec][tTag] into tOtherNode
         put pShort[tDoc][tOtherNode]["title"] into tOtherTitle
         if tOtherTitle is empty then put tOtherNode into tOtherTitle
         put pShort[tDoc][tOtherNode]["type"] into tOtherType
         put tOtherNode into tList[tLineCount]["node"]
         put tLinkRec into tList[tLineCount]["link"]
         put tLinkWeight into tList[tLineCount]["weight"]
         put "weight" into tList[tLineCount]["label"]
         put cr & symbolLookup(tOtherType) && tOtherTitle && "[" & tTag & "]" &&  tLinkWeight && "IN>" after tList["string"]
      end repeat
   end repeat
   -- divider
   put tLineCount + 1 into tLineCount
   put "divider" into tList[tLineCount]["label"]
   put cr & "==========" after tList["string"]
   -- main body of tag:data pairs for the node   
   put "title memo figure" into tDefaults
   repeat for each key tKey in pShort[tDoc][tNodeRec] -- ? this one might only actually catch "title"
      --       if tKey is not among the words of "type next prev skim trim read bulk info" then
      if tKey is not among the words of "type next prev skim trim read bulk info onlyone" then
         put tLineCount + 1 into tLineCount
         put tNodeRec into tList[tLineCount]["rec"]
         put tKey into tList[tLineCount]["label"]
         put pShort[tDoc][tNodeRec][tKey] into tList[tLineCount][tKey]
         if tList[tLineCount][tKey] is empty then put "[empty]" into tList[tLineCount][tKey]
         put pShort[tDoc][tNodeRec]["type"] into tThisNodeType
         if tKey is "title" then put tLineCount into tList["master"]
         if tKey is "figure" and tList[tLineCount][tKey] is not "[empty]" then
            put tList[tLineCount][tKey] into tPath
            set itemdelimiter to slash
            put the last item of tPath into tPath
            put cr & "[" & tKey & "]"  && tPath after tList["string"]
            put tLineCount into tList["displayImage"]
         else if tKey is "title" and tList[tLineCount][tKey] is not "[empty]" then
            put cr & "[" & tKey & "]" && symbolLookup(tThisNodeType) && tList[tLineCount][tKey] after tList["string"]
         else
            put cr & "[" & tKey & "]" && tList[tLineCount][tKey] after tList["string"]
         end if
         if tKey is among the words of tDefaults then delete word wordoffset(tKey, tDefaults) in tDefaults
      end if
   end repeat
   repeat for each key tKey in pShort[tDoc][tNodeRec]["info"]
      put tLineCount + 1 into tLineCount
      put tNodeRec into tList[tLineCount]["rec"]
      put tKey into tList[tLineCount]["label"]
      put pShort[tDoc][tNodeRec]["info"][tKey] into tList[tLineCount][tKey]
      if tList[tLineCount][tKey] is empty then put "[empty]" into tList[tLineCount][tKey]
      put pShort[tDoc][tNodeRec]["type"] into tThisNodeType
      put cr & "[" & tKey & "]" && symbolLookup(tThisNodeType) && tList[tLineCount][tKey] after tList["string"]
      if tKey is among the words of tDefaults then delete word wordoffset(tKey, tDefaults) in tDefaults
   end repeat
   -- insert presets so that user can give them a value if they're empty
   repeat for each word tPreset in tDefaults
      put tLineCount + 1 into tLineCount
      put tNodeRec into tList[tLineCount]["rec"]
      put tPreset into tList[tLineCount]["label"]
      put "[empty]" into tList[tLineCount][tPreset]
      if tPreset is "title" then put tLineCount into tList["master"]
      put pShort[tDoc][tNodeRec]["type"] into tThisNodeType
      put cr & "[" & tPreset & "]" && symbolLookup(tThisNodeType) && tList[tLineCount][tPreset] after tList["string"]
   end repeat
   -- divider
   put tLineCount + 1 into tLineCount
   put "divider" into tList[tLineCount]["label"]
   put cr & "==========" after tList["string"]
   -- out links&node
   repeat for each word tTag in tOutTags
      put pShort[tDoc][tNodeRec][tTag] into tLinks
      repeat for each line tLinkRec in tLinks
         put tLineCount + 1 into tLineCount
         put pShort[tDoc][tLinkRec]["weight"] into tLinkWeight
         if tLinkWeight is empty then put "1" into tLinkWeight
         put pShort[tDoc][tLinkRec][tTag] into tOtherNode
         put pShort[tDoc][tOtherNode]["title"] into tOtherTitle
         if tOtherTitle is empty then put tOtherNode into tOtherTitle
         put pShort[tDoc][tOtherNode]["type"] into tOtherType
         put tOtherNode into tList[tLineCount]["node"]
         put tLinkRec into tList[tLineCount]["link"]
         put tLinkWeight into tList[tLineCount]["weight"]
         put "weight" into tList[tLineCount]["label"]
         put cr & ">OUT" && tLinkWeight && "[" & tTag & "]" && symbolLookup(tOtherType) && tOtherTitle after tList["string"]
      end repeat
   end repeat
   filter tList["string"] without empty
   return tList
end tempNodeDetails

function stepString @pMain,pStuff
   put "function stepString" into xX["write"];    devLog xX
   put pStuff["rec"] into tEyeDee
   put pStuff["doc"] into tDaDoc
   if tDaDoc is empty or tEyeDee is empty then break
   --takes in a step record and returns a string (type & id/title)
   put isAnode(pMain,tDaDoc,tEyeDee) into tType
   --   if tType is false then return "not a node"
   if tType is false then 
      -- it's a link
      -- # type [x] to [z]
      put isAlink(pMain,tDaDoc,tEyeDee) into tLinkFacts
      put tDaDoc into tStuff["doc"]
      put tLinkFacts["X"] into tStuff["rec"]
      put stepString(pMain,tStuff) into tX
      put tLinkFacts["Z"] into tStuff["rec"]
      put stepString(pMain,tStuff) into tZ
      put tEyeDee && tLinkFacts["type"] && "[" & tX & "]" && "to" && "[" & tZ & "]" into tTitle
      if tTitle is empty then put "(link)" && tEyeDee into tTitle
      return tTitle
   else
      -- it's a node
      put tEyeDee into tStuff["rec"]
      put "title" into tStuff["tag"]
      put tDaDoc into tStuff["doc"]
      put getTagData(pMain,tStuff) into tTitle
      if tTitle is empty then put tEyeDee && "blank" into tTitle
      put symbolLookup(tType) && tTitle into tThisString
      return tThisString
   end if
end stepString

function symbolLookup tArg --a lookup table for display symbols
   put "function symbolLookup" into xX["write"];    devLog xX
   switch tArg
      case "state"
         return numtocodepoint(0x25A0) --box
      case "change"
         return numtocodepoint(0x25B2) --triangle
   end switch
   return "not found in symbolLookup function"
end symbolLookup

function symbolLookupHTML tArg --a lookup table for display symbols
   put "function symbolLookup" into xX["write"];    devLog xX
   switch tArg
      case "state"
         return "&#9632;"--box
      case "change"
         return "&#9650;" --triangle
   end switch
   return "not found in symbolLookup function"
end symbolLookupHTML

on tempConvertData pShort,@pData,pDoc
   put "on tempConvertData" into xX["write"];    devLog xX
   -- sMainShort to sGraphData
   -- sMainShort[doc][rec][next/prev]
   -- sGraphData[nodes/links][rec][next/prev/displayString]
   
   repeat for each key tRec in pShort[pDoc]
      if pShort[pDoc][tRec]["type"] is among the words of "state change" then
         -- node...probably !
         put pShort[pDoc][tRec] into pData["nodes"][tRec]
      else if tRec is not 0 then
         -- link...probably !
         put pShort[pDoc][tRec] into pData["links"][tRec]
      end if
   end repeat
   -- node neighbors
   -- this is important for preview and change logic
   -- link,node
   repeat for each key tRec in pData["nodes"]
      repeat for each word tDir in "next prev trim skim"
         --         repeat for each item tLink in pData["nodes"][tRec][tDir]
         repeat for each line tLink in pData["nodes"][tRec][tDir]
            if tDir is "next" or tDir is "prev" then
               put cr & tLink & "," & pData["links"][tLink][tDir] after pData["abutFlow"][tRec]
               filter pData["abutFlow"][tRec] without empty
            else if tDir is "trim" then
               put cr & tLink & "," & pData["links"][tLink][tDir] after pData["abutRise"][tRec]
               filter pData["abutRise"][tRec] without empty
            else if tDir is "skim" then
               put cr & tLink & "," & pData["links"][tLink][tDir] after pData["abutDive"][tRec]
               filter pData["abutDive"][tRec] without empty
            end if
         end repeat
      end repeat
   end repeat
   -- find the case node
   -- needed to request certain changes
   repeat for each key tRec in pData["nodes"]
      if "bulk" is among the keys of pData["nodes"][tRec] and "read" is among the keys of pData["nodes"][tRec] then
         put tRec into pData["case"]
      end if
   end repeat
   -- undo/redo
   put pShort[pDoc][0]["undo"] into pData["undo"]
   put pShort[pDoc][0]["redo"] into pData["redo"]
   -- metatdata
   put pShort[pDoc][0]["pointerTags"] into pData["pointerTags"]
   -- node display label ----------------
   repeat for each key tRec in pData["nodes"]
      put pShort[pDoc][tRec]["title"] into tForShow
      if tForShow is empty then
         --         put symbolLookup(pShort[pDoc][tRec]["type"]) && tRec into tForShow
         put "<p>" & symbolLookupHTML(pShort[pDoc][tRec]["type"]) && tRec & "</p>" into tForShow
      else
         --         put symbolLookup(pShort[pDoc][tRec]["type"]) & " " before tForShow
         put symbolLookupHTML(pShort[pDoc][tRec]["type"]) into tSymbol
         put "<p>" & tSymbol & space before tForShow
         put "</p>" after tForShow
      end if
      put tForShow into pData["nodes"][tRec]["displayString"]
      put tForShow into pData["nodes"][tRec]["displayStringExtended"]
      -- pass forward the memo & figure if they're present
      put pShort[pDoc][tRec]["memo"] into tForShow
      if tForShow is not empty then put cr & "<p>" & tForShow & "</p>" after pData["nodes"][tRec]["displayStringExtended"]
      put pShort[pDoc][tRec]["figure"] into tForShow
      -- set all of the <img> tags to the same image object
      -- later, if this figure needs to be shown in a field (like tooltip), that image object's filename will be set to the figure's path
      -- the field's image won't care what's in the image object
      -- 17624 is the ID of image "figureSource"
      if tForShow is not empty then 
         put cr & "<p><img src=17624></p>" after pData["nodes"][tRec]["displayStringExtended"]
         
      end if
   end repeat
end tempConvertData

on middleOut pData,@pDraw,@pFocus -- ! a hacky way to draw the provided graph, calls assignLayers
   -- ! as of 10JAN2016 middleOut only follows flow links, so it won't visit or follow dive/rise links
   put "on middleOut" into xX["write"];    devLog xX
   -- pData ! just sGraphData at the moment, maybe this should be an adjacency list ?
   -- setup variables --------------------------------------------------------------------------------
   put empty into pData["layers"]
   put empty into pData["visited"]
   -- make sure the focus node is actually focusable
   put the keys of pData["nodes"] into tKeys
   put empty into tRecs
   repeat for each line tLine in tKeys
      if tLine is a number then put tLine into line (the number of lines of tRecs)+1 of tRecs
   end repeat
   if pFocus is not among the lines of tRecs then
      sort tRecs numeric descending
      put line 1 of tRecs into pFocus
   end if
   -- recursively assign layers ------------------------------------------------------------------------
   -- pass pData by reference, and focus node, and initial layer
   -- add layer and visited info to pData
   assignLayers pData,pFocus,0
   -- remove duplicates in layers ------------------------------------------------------------------
   repeat for each key tLayer in pData["layers"]
      put pData["layers"][tLayer] into tOneLayer
      split tOneLayer by comma
      combine tOneLayer using comma
      if char -1 of tOneLayer is not "," then put "," after tOneLayer
      put tOneLayer into pData["layers"][tLayer]
   end repeat
   -- shuffle nodes so links point left-to-right ----------------------------------------------------
   -- when a pair of linked nodes are misaligned...
   --- if on the pos side (layers >0), shift end more pos
   --- if on the neg side (layers <0), shift start more neg
   --- making a link vertical is okay, but not backwards
   --- don't move the focused node out of layer 0
   put empty into tShuffles -- cr delimited list; node and direction shuffled; kill infinite loop
   put true into tAgain -- keep repeating until nothing changes
   repeat while tAgain is true
      put false into tAgain
      repeat for each item tLink in pData["visited"]["links"]
         put item 1 of pData["links"][tLink]["prev"] into tStart
         put item 1 of pData["links"][tLink]["next"] into tEnd
         put pData["nodes"][tStart]["layer"] into tStartLayer
         put pData["nodes"][tEnd]["layer"] into tEndLayer
         set the wholeMatches to true
         if not (tStartLayer < tEndLayer) then
            if tEnd is pFocus then
               -- shuffle start more negative
               put true into tAgain
               --               delete item itemOffset(tStart,pData["layers"][tStartLayer]) of pData["layers"][tStartLayer]
               --               set the wholeMatches to true
               put itemOffset(tStart,pData["layers"][tStartLayer]) into tNum
               delete item tNum of pData["layers"][tStartLayer]
               put tStart & "," after pData["layers"][tStartLayer -1]
               put tStartLayer -1 into pData["nodes"][tStart]["layer"]
               put cr & tStart & "-" after tShuffles
               --               filter tShuffles without empty
            else if tEnd & "-" is among the lines of tShuffles then
               -- have to catch a situation where a node just shuffles back and forth
               -- shuffle start more negative
               put true into tAgain
               delete item itemOffset(tStart,pData["layers"][tStartLayer]) of pData["layers"][tStartLayer]
               put tStart & "," after pData["layers"][tStartLayer -1]
               put tStartLayer -1 into pData["nodes"][tStart]["layer"]
               put cr & tStart & "-" after tShuffles
               --               filter tShuffles without empty
            else
               -- shuffle end more positive
               put true into tAgain
               delete item itemOffset(tEnd,pData["layers"][tEndLayer]) of pData["layers"][tEndLayer]
               put tEnd & "," after pData["layers"][tEndLayer +1]
               put tEndLayer +1 into pData["nodes"][tEnd]["layer"]
               put cr & tEnd & "+" after tShuffles
               --               filter tShuffles without empty
            end if
         end if -- is tStart < tEnd?
         filter tShuffles without empty
         set the wholeMatches to false
      end repeat -- tLink in sLinksVisited
   end repeat -- tAgain
   -- order in layer by node #, ascending ----------------------------------------------------------
   repeat for each key tLayer in pData["layers"]
      sort items of pData["layers"][tLayer] ascending numeric
      if char 1 of pData["layers"][tLayer] is "," then delete char 1 of pData["layers"][tLayer]
   end repeat
   -- ! deal with elements that are visible but weren't discovered by middleOut
   repeat for each word tKind in "nodes links"
      repeat for each line tRec in the keys of pData[tKind]
         if tRec is not among the items of pData["visited"][tKind] then
            put tRec into item (the number of items of pData["unvisited"][tKind])+1 of pData["unvisited"][tKind]
         end if
      end repeat
   end repeat
   put pData into pDraw
end middleOut

on assignLayers @pAll,pSeed,pTheLayer -- ! the recursive part of middleOut
   put "on assignLayers" into xX["write"];    devLog xX
   -- pAll = pData (just a copy of sGraphData at the moment); this adds display info to it
   -- pSeed = the node to find neighbors of
   -- pTheLayer = the layer pSeed was assigned before this function was called
   --- list all next & prev links
   --- format as links
   --- don't add if already on list of visited links
   --- add node to layer; prev -1; next +1
   --- call this function again on this node
   --- terminal case is when this node has no unvisited links
   if pSeed is not among the items of pAll["visited"]["nodes"] then
      put pSeed & "," after pAll["visited"]["nodes"]
      put pSeed & "," after pAll["layers"][pTheLayer]
      put pTheLayer into pAll["nodes"][pSeed]["layer"]
      repeat for each word tDir in "next prev"
         --         repeat for each item tLink in pAll["nodes"][pSeed][tDir]
         repeat for each line tLink in pAll["nodes"][pSeed][tDir]
            if tLink is not among the items of pAll["visited"]["links"] then
               put tLink & "," after pAll["visited"]["links"]
               filter pAll["visited"]["links"] without empty
               put item 1 of pAll["links"][tLink][tDir] into tNode
               switch tDir
                  case "next"
                     assignLayers pAll,tNode,(pTheLayer +1)
                     break
                  case "prev"
                     assignLayers pAll,tNode,(pTheLayer - 1)
                     break
               end switch
            end if
         end repeat
      end repeat 
   end if
end assignLayers

on displayManager pInfo,@pGUI,pSizes,pNow,@pHist -- ! creates/changes/deletes controls
   put "on displayManager" into xX["write"];    devLog xX
   -- sGraphDrawing,sGUIstuff,tSizes,sNowFocus,sMouseHistory
   --pSizes[width/height/layer/node]
   lock messages
   lock screen
   -- delete old node graphics; brute force but not much to draw at the moment   
   if pGUI is not empty then
      repeat for each word tKind in "nodes links"
         repeat for each key tNum in pGUI[tKind]
            put pGUI[tKind][tNum]["graphic"] into tID
            if exists(tID) then delete tID
         end repeat
      end repeat
   end if
   put 70 into tMenuReserve -- try to reserve some space at the top of the window for the controls
   put pSizes["width"] into tWinWidth
   put pSizes["height"] into tWinHeight
   put tWinWidth/2 into tCenterH
   put empty into pGUI
   -- specify case node
   put pInfo["case"] into pGUI["case"]
   put pInfo["abutFlow"] into pGUI["abutFlow"]
   put pInfo["abutDive"] into pGUI["abutDive"]
   put pInfo["abutRise"] into pGUI["abutRise"]
   -- calculate node coordinates and draw graphic
   repeat for each key tLayer in pInfo["layers"]
      put ((pSizes["node"] + pSizes["layer"]) * tLayer) + tCenterH into tNodeH
      put the number of items of pInfo["layers"][tLayer] into tStack
      --       put tWinHeight/(tStack + 1) into tStackV
      put (tWinHeight-tMenuReserve-pSizes["node"])/(tStack + 1) into tStackV
      
      put 1 into tCount
      repeat for each item tNode in pInfo["layers"][tLayer]
         -- start positioning from top of window
         --          put tStackV * tCount into tNodeV
         put (tStackV * tCount) + tMenuReserve into tNodeV
         
         -- node coordinates
         put tNodeH into pGUI["nodes"][tNode]["horz"]
         put tNodeV into pGUI["nodes"][tNode]["vert"]
         put tNode into tStuff["node"]
         put tNodeH & "," & tNodeV into tStuff["coord"]
         put pSizes["node"] into tStuff["size"]
         put pInfo["nodes"][tNode]["type"] into tStuff["type"]
         -- node type
         put tStuff["type"] into pGUI["nodes"][tNode]["type"]
         -- node's display string & figure
         put pInfo["nodes"][tNode]["displayString"] into pGUI["nodes"][tNode]["displayString"]
         put pInfo["nodes"][tNode]["displayString"] into tStuff["displayString"]
         put pInfo["nodes"][tNode]["displayStringExtended"] into pGUI["nodes"][tNode]["displayStringExtended"]
         put pInfo["nodes"][tNode]["displayStringExtended"] into tStuff["displayStringExtended"]
         put pInfo["nodes"][tNode]["figure"] into pGUI["nodes"][tNode]["figure"]
         -- node's graphic ID
         put makeNode(tStuff) into pGUI["nodes"][tNode]["graphic"]
         -- node's neighbors
         put pInfo["abutFlow"][tNode] into pGUI["nodes"][tNode]["abutFlow"]
         if tNode is among the keys of pInfo["abutDive"] then put pInfo["abutDive"][tNode] into pGUI["nodes"][tNode]["abutDive"]
         if tNode is among the keys of pInfo["abutRise"] then put pInfo["abutRise"][tNode] into pGUI["nodes"][tNode]["abutRise"]
         put tCount + 1 into tCount
      end repeat
   end repeat
   -- put miscellaneous nodes into the pool, or whatever ---------------------
   -- not the case node cuz technically the whole window is the case node
   put false into tMisc
   put 0 into tCountThis
   repeat for each item tNode in pInfo["unvisited"]["nodes"]
      if tNode is not among the items of pInfo["case"] then
         put true into tMisc
         -- node coordinates
         put (pSizes["node"]/2) + (tCountThis * (pSizes["node"] + pSizes["layer"])) into pGUI["nodes"][tNode]["horz"]
         put tWinHeight-(pSizes["node"]/2) into pGUI["nodes"][tNode]["vert"]
         -- build request
         put tNode into tStuff["node"]
         put pGUI["nodes"][tNode]["horz"] & "," & pGUI["nodes"][tNode]["vert"] into tStuff["coord"]
         put pSizes["node"] into tStuff["size"]
         put pInfo["nodes"][tNode]["type"] into tStuff["type"]
         -- node type
         put tStuff["type"] into pGUI["nodes"][tNode]["type"]
         -- node's display string
         put pInfo["nodes"][tNode]["displayString"] into pGUI["nodes"][tNode]["displayString"]
         put pInfo["nodes"][tNode]["displayString"] into tStuff["displayString"]
         put pInfo["nodes"][tNode]["displayStringExtended"] into pGUI["nodes"][tNode]["displayStringExtended"]
         put pInfo["nodes"][tNode]["displayStringExtended"] into tStuff["displayStringExtended"]
         put pInfo["nodes"][tNode]["figure"] into pGUI["nodes"][tNode]["figure"]
         -- node's graphic ID
         put makeNode(tStuff) into pGUI["nodes"][tNode]["graphic"]      
         put true into pGUI["nodes"][tNode]["misc"]
         put tCountThis + 1 into tCountThis
      end if
   end repeat
   -- draw flow links...crudly --------------------------
   repeat for each key tLink in pInfo["links"]
      if tLink is 0 then next repeat -- ! probably don't need this as of 11JAN2016
      -- if this link is attached to a misc node, don't draw it
      put false into tMoveOn
      repeat for each key tSomething in pInfo["links"][tLink]
         if tSomething is among the words of "next prev read skim bulk trim" then
            put pInfo["links"][tLink][tSomething] into tTag
            if pGUI["nodes"][tTag]["misc"] is true then 
               put true into tMoveOn
               exit repeat -- exit this small repeat test
            end if
         end if
      end repeat
      if tMoveOn is true then next repeat -- next tLink
      -- okay, so go ahead and draw the link tLink
      if pInfo["links"][tLInk]["type"] is not "dive" and pInfo["links"][tLInk]["type"] is not "rise" then -- FLOW
         put item 1 of pInfo["links"][tLink]["prev"] into tStart
         put item 1 of pInfo["links"][tLink]["next"] into tEnd
         put pSizes["node"] / 2 into tClean
         put (pGUI["nodes"][tStart]["horz"]+tClean) & "," & pGUI["nodes"][tStart]["vert"] into tStartCoord
         put (pGUI["nodes"][tEnd]["horz"]-tClean) & "," & pGUI["nodes"][tEnd]["vert"] into tEndCoord
         put tLink into tBox["link"]
         put tStartCoord & cr & tEndCoord into tBox["line"]
         put pSizes["link"] into tBox["size"]
         put pInfo["links"][tLink]["type"] into tBox["type"]
         put pInfo["links"][tLink]["weight"] into tWeight
         if tWeight is empty then
            put 1 into pGUI["links"][tLink]["weight"]
         else
            put tWeight into pGUI["links"][tLink]["weight"]
         end if
         put tBox["type"] into pGUI["links"][tLink]["type"]
         put makeLink(tBox) into pGUI["links"][tLink]["graphic"]
      else if pInfo["links"][tLInk]["type"] is "dive" then -- DIVE 
         -- what node diving into
         --- pInfo link>read=#
         --- pGUI node>#>graphic
         -- rect of that control
         -- points = L-10,top cr L,T+10
         put pInfo["links"][tLink]["read"] into tTheNode
         put pGUI["nodes"][tTheNode]["graphic"] into tTheNodeName
         put the rect of tTheNodeName into tTheNodeRect
         put item 1 of tTheNodeRect into tL
         put item 2 of tTheNodeRect into tT
         put (tL-10) & "," & tT & cr & tL & "," & (tT+10) into tStuff["line"]
         put tLink into tStuff["link"]
         put 2 into tStuff["size"]
         put makeScopeLink(tStuff) into pGUI["links"][tLink]["graphic"]
      else if pInfo["links"][tLInk]["type"] is "rise" then -- RISE
         -- what node rising out of
         --- pInfo link>trim=#
         --- pGUI node>#>graphic
         -- rect of that control 
         -- points = right,T+10 cr R+10,top
         put pInfo["links"][tLink]["bulk"] into tTheNode
         put pGUI["nodes"][tTheNode]["graphic"] into tTheNodeName
         put the rect of tTheNodeName into tTheNodeRect
         put item 3 of tTheNodeRect into tR
         put item 2 of tTheNodeRect into tT
         put tR  & "," & (tT+10) & cr & (tR+10) & "," & tT into tStuff["line"]
         put tLink into tStuff["link"]
         put 2 into tStuff["size"]
         put makeScopeLink(tStuff) into pGUI["links"][tLink]["graphic"]
      end if
   end repeat
   -- draw scope links...also crudly -------------------
   
   -- make sure the node graphics are on top
   repeat for each key tNode in pGUI["nodes"]
      set the layer of pGUI["nodes"][tNode]["graphic"] to top
   end repeat
   -- then make sure the preview graphics are on top of that
   set the layer of graphic "preFlow1" stack "HowstrBeta" to top
   set the layer of graphic "preFlow2" stack "HowstrBeta" to top
   set the layer of field "preState" stack "HowstrBeta" to top
   set the layer of field "preChange" stack "HowstrBeta" to top
   -- highlight focused node (since all nodes new, old highlighted one was deleted)
   put pGUI["nodes"][pNow]["graphic"] into tBlerg
   set the backgroundColor of tBlerg to "0,100,100"
   -- undo/redo icons
   -- for quick mode, don't allow user to undo the graph smaller than the minimum action group
   -- ! 15DEC2015 hide can take graph down to 4 nodes with undo still being acceptable
   -- what I really want to prevent is undoing back through the initialization steps
   --   if the number of lines of the keys of pInfo["nodes"] is 4 then
   --      set the visible of widget "iconUndo" to false
   --   else
   --      set the visible of widget "iconUndo" to pInfo["undo"]
   --   end if
   set the visible of widget "iconUndo" stack "howstrBeta" to pInfo["undo"]
   set the visible of widget "iconRedo" stack "howstrBeta" to pInfo["redo"]
   -- empty out selection and hide hide button
   put empty into pHist["nodeSelected"]
   put empty into pHist["linkSelected"]
   set the visible of button "hideButt" stack "howstrBeta" to false
   -- set misc nodes navigation buttons
   set the visible of button "miscRightButt" stack "howstrBeta" to tMisc
   set the visible of button "miscLeftButt" stack "howstrBeta" to tMisc
   unlock screen
   unlock messages
   put "end displayManager --------------" into xX["write"];    devLog xX
end displayManager

function makeNode pDetails
   put "function makeNode" into xX["write"];    devLog xX
   --   breakpoint
   -- pDetails[node/coord/size/type/displayString/displayStringExtended]
   -- ! assume doc is 1
   put 1 into tDoc
   set the margins of the templateField to 3
   set the locked of the templateField to true
   set the lockText of the templateField to true
   set the dontwrap of the templateField to false
   set the height of the templateField to pDetails["size"]
   set the width of the templateField to pDetails["size"]
   set the name of the templateField to pDetails["node"] & "NodeGraphicDeleteMe"
   set the location of the templateField to pDetails["coord"]
   set the threeD of the templatefield to false
   set the showborder of the templatefield to false
   set the bordercolor of the templatefield to white
   set the backgroundcolor of the templatefield to "0,220,220"
   set the textSize of the templatefield to 14
   set the outerglow["color"] of the templatefield to "40,40,40"
   --   set the behavior of the templatefield to the long id of button "graphBehave"
   set the defaultstack to "HowstrBeta"
   put the defaultstack into tTemp
   --   put the defaultstack into field "filenameLabel" stack "HowstrBeta" -- ! just for troubleshooting !!!
   --   create field (the long ID of stack "HowstrBeta")
   create field
   put it into tID
   set the cGraphKey of (tID) to pDetails["node"]
   set the htmltext of (tID) to pDetails["displayString"]   
   -- size the node to fit the displayString, within limits
   put the formattedHeight of word 1 to -1 of (tID) into tFormHigh
   put the height of (tID) into tHigh
   put 1 into tCounter
   repeat while tFormHigh > tHigh
      switch tCounter
         case 1
            set the width of (tID) to pDetails["size"] * 1.25
            break
         case 2
            set the height of (tID) to pDetails["size"] * 1.5
            break
         case 3
            set the textsize of (tID) to 12
            break
         case 4
            set the textsize of (tID) to 10
            break
         default
            exit repeat -- just finish
      end switch
      put tCounter + 1 into tCounter
      put the formattedHeight of word 1 to -1 of (tID) into tFormHigh
      put the height of (tID) into tHigh
   end repeat
   --   if the height of (tID) > pDetails["size"] then set the height of (tID) to the formattedHeight of word 1 to -1 of (tID)
   return tID
end makeNode

function makeLink pThis
   put "function makeLink" into xX["write"];    devLog xX
   -- pThis[link/line/type]
   set the style of the templateGraphic to "line"
   set the endArrow of the templateGraphic to true
   set the foregroundColor of the templategraphic to "0,220,220"
   set the points of the templateGraphic to pThis["line"]
   set the name of the templateGraphic to pThis["link"] & "LinkGraphicDeleteMe"
   set the filled of the templateGraphic to false
   set the linesize of the templateGraphic to pThis["size"]
   set the outerglow["color"] of the templateGraphic to "40,40,40"
   --   set the behavior of the templateGraphic to the long id of button "graphBehave"
   --   create graphic (the long ID of stack "howstrBeta")
   set the defaultstack to "HowstrBeta"
   create graphic
   set the cGraphKey of it to pThis["link"]
   return it
end makeLink

function makeScopeLink pThis
   set the style of the templateGraphic to "line"
   set the endArrow of the templateGraphic to true
   set the foregroundColor of the templategraphic to "0,220,220"
   set the points of the templateGraphic to pThis["line"]
   set the name of the templateGraphic to pThis["link"] & "LinkGraphicDeleteMe"
   set the filled of the templateGraphic to false
   set the linesize of the templateGraphic to pThis["size"]
   set the outerglow["color"] of the templateGraphic to "40,40,40"
   --   set the behavior of the templateGraphic to the long id of button "graphBehave"
   --   create graphic (the long ID of stack "howstrBeta")
   set the defaultstack to "HowstrBeta"
   create graphic
   set the cGraphKey of it to pThis["link"]
   return it
end makeScopeLink

function mouseTracker @pGUI,@pHist,@p1Down,@p1Enter,pFocus,pNode,pPath
   --   put "function mouseTracker" into xX["write"];    devLog xX
   -- sGUIstuff,sMouseHistory,s1Down,s1Enter,sNowFocus,sNodeSize
   -- this mostly replaces Livecode's built in mouse handlers because they couldn't reliably do what I wanted
   -- this gets called for almost all mouse messages and compares current status to prior status
   -- (1) research the state of the mouse
   -- (1a) record the location of the mouse and selections
   -- (1b) compare old mouse button states to new
   -- (1c) if an anchor, track new areas entered
   -- (2) build preview based on research
   -- tNow[1down]=true/false
   -- tNow[3down]=true/false
   -- tNow[inside]=empty/#
   -- tNow[moving]=X,Y
   -- tNow[fixed]=X,Y/empty
   -- tNow[nodeSelected]=#,#,# (cuz they're organized first by node/link in GUIstuff)
   -- tNow[linkSelected]=#,#,#
   -- tNow[tooltip]=true/false
   
   -- (1) state of controls
   put the hilite of button "tooltipSwitch" stack "HowstrBeta" into tNow["tooltip"]
   put "false" into tNow["1down"]
   -- ! Jeremy's using Ubuntu 15.04 and the mouse() function returns a different number for button down
   if the hilite of button "jeremyBugButt" stack "HowstrBeta" is true then 
      put 0 into mouseLeft
      put 2 into mouseRight
   else
      put 1 into mouseLeft
      put 3 into mouseRight
   end if
   if mouse(mouseLeft) is "down" then put "true" into tNow["1down"] -- for preview logic
   put "false" into tNow["3down"]
   if mouse(mouseRight) is "down" then put "true" into tNow["3down"] -- for selection logic
   -- (1a) location of mouse & selection indicators (since we're here)
   put empty into tNow["inside"]
   if pHist["3down"] is false and tNow["3down"] is true then -- reset selection when button down, otherwise retain
      put empty into tNow["nodeSelected"]
      put empty into tNow["linkSelected"]
      set the visible of button "hideButt" stack "HowstrBeta" to false
   else
      put pHist["nodeSelected"] into tNow["nodeSelected"]
      put pHist["linkSelected"] into tNow["linkSelected"]
   end if
   repeat for each word tType in "nodes links"
      repeat for each key tNum in pGUI[tType]
         -- find out if the mouse is inside of a graph element
         -- within() doesn't depend on the rect, so how it treats negative space is more intuitive
         if within(pGUI[tType][tNum]["graphic"],the mouseloc) then
            put tNum into tNow["inside"]
         end if
         -- clear hilite; will be reapplied later if element still selected
         if tType is "nodes" and tNum is not among the items of pHist["nodeSelected"] then set the showborder of pGUI[tType][tNum]["graphic"] to false
         if tType is "links" and tNum is not among the items of pHist["linkSelected"] then  set the foregroundColor of pGUI[tType][tNum]["graphic"] to "0,220,220"
         -- selection box
         if tNow["3down"] and intersect(pGUI[tType][tNum]["graphic"],graphic "selectBox" stack "HowstrBeta","pixels") then
            -- add any new selection to lists
            if tType is "nodes" and tNum is not among the items of tNow["nodeSelected"] and tNum is not pFocus then 
               put tNum into item (the number of items of tNow["nodeSelected"])+1 of tNow["nodeSelected"]
               set the visible of button "hideButt" stack "HowstrBeta" to true
            end if
            if tType is "links" and tNum is not among the items of tNow["linkSelected"] then 
               put tNum into item (the number of items of tNow["linkSelected"])+1 of tNow["linkSelected"]
               set the visible of button "hideButt" stack "HowstrBeta" to true
            end if
         end if-- if 3down is true & intersection
      end repeat
   end repeat
   -- auto-select any links attached to a selected node
   repeat for each item tNode in tNow["nodeSelected"]
      --      put listOfLinks(tNode) into tLinks -- ! this is a pain with the current organization, but it's short and easy to replicate
      -- pGUI[nodes][#][abutFlow/Dive/Rise]=#,# cr #,# (link rec),(node rec)
      repeat for each word tKind in "abutFlow abutDive abutRise"
         repeat for each line tConnection in pGUI["nodes"][tNode][tKind]
            put item 1 of tConnection into tCon
            if tCon is not among the items of tNow["linkSelected"] then
               put tCon into item (the number of items of tNow["linkSelected"])+1 of tNow["linkSelected"]
            end if
         end repeat
      end repeat
   end repeat
   -- hilite selected elements
   repeat for each item tNum in tNow["nodeSelected"]
      set the showborder of pGUI["nodes"][tNum]["graphic"] to true
   end repeat
   repeat for each item tNum in tNow["linkSelected"]
      set the foregroundColor of pGUI["links"][tNum]["graphic"] to white
   end repeat
   --   put tNow["nodeSelected"] & cr & tNow["linkSelected"] into field "showMe" stack "HowstrBeta" -- ! for development
   -- selection box calculation
   put the mouseLoc into tNow["moving"]
   put pHist["fixed"] into tNow["fixed"]
   
   
   -- (1b) compare old to new
   if pHist["1down"] is false and tNow["1down"] is true then
      -- button 1 just transitioned from up to down 
      put tNow["inside"] into p1Down -- becomes "anchor"
   end if
   if pHist["3down"] is false and tNow["3down"] is true then
      -- button 3 just transitioned from up to down
      put the mouseLoc into tNow["fixed"] -- becomes fixed point for selectBox
      set the layer of graphic "selectBox" stack "HowstrBeta" to top
      set the visible of graphic "selectBox" stack "HowstrBeta" to true
   end if
   if pHist["3down"] is true and tNow["3down"] is false then
      -- button 3 just transitioned from down to up
      put empty into tNow["fixed"] -- no more selectBox
      set the visible of graphic "selectBox" stack "HowstrBeta" to false
   end if
   put pHist["fixed"] into tStuff["point1"]
   put tNow["moving"] into tStuff["point2"]
   -- ! there was an error where fixed would be empty the first time or something like that
   if tStuff["point1"] is not empty then set the rect of graphic "selectBox" stack "HowstrBeta" to twoPointBox(tStuff)
   if tNow["3down"] is not true then set the rect of graphic "selectBox" stack "HowstrBeta" to "0,0,0,0" -- otherwise it's still there messing with stuff like a ghost
   ---------------------------- tooltip --------------------------------------
   if tNow["tooltip"] is true and tNow["inside"] is a number and tNow["1down"] is false and tNow["3down"] is false then
      lock screen      
      -- size the tooltip field
      if pHist["tooltipRect"] is not empty and (tNow["inside"] is pHist["inside"]) then
         put pHist["tooltipRect"] into tNow["tooltipRect"]
      else
         if tNow["inside"] is among the keys of pGUI["nodes"] then
            put pGUI["nodes"][tNow["inside"]]["figure"] into tReq["targetMedia"]
            put pPath into tReq["projectFile"]
            set the filename of image "figureSource" stack "howstrBeta" to correctAbsoluteMediaPath(tReq)
            set the rect of image "figureSource" stack "howstrBeta" to 0,0,50,50
            set the htmlText of field "tooltipField" stack "HowstrBeta" to pGUI["nodes"][tNow["inside"]]["displayStringExtended"]       
         else if tNow["inside"] is among the keys of pGUI["links"] then
            put pGUI["links"][tNow["inside"]]["weight"] into field "tooltipField" stack "HowstrBeta" 
         end if -- inside a node
         -- set to 200x200; if formattedheight is <200, shrink height
         set the rect of field "tooltipField" stack "howstrBeta" to 0,0,200,200
         put the formattedHeight of char 1 to -1 of field "tooltipField" stack "HowstrBeta" into tHeight
         if tHeight <200 then       
            set the height of field "tooltipField" stack "HowstrBeta" to tHeight
         end if
         put the formattedWidth of char 1 to -1 of field "tooltipField" stack "HowstrBeta" into tWidth
         if tWidth < 200 then
            set the width of field "tooltipField" stack "HowstrBeta" to tWidth+10
         end if
         put the rect of field "tooltipField" stack "HowstrBeta" into tNow["tooltipRect"]
      end if -- pHist tooltipRect not empty
      
      -- position the tooltip field
      set the bottomright of field "tooltipField" stack "HowstrBeta" to tNow["moving"]
      put the rect of field "tooltipField" stack "HowstrBeta" into tNow["tooltipRect"]
      put item 1 of tNow["tooltipRect"] into tL
      put item 2 of tNow["tooltipRect"] into tT
      put item 3 of tNow["tooltipRect"] into tR
      put item 4 of tNow["tooltipRect"] into tB
      put item 1 of tNow["moving"] into tX
      put item 2 of tNow["moving"] into tY
      put the width of stack "HowstrBeta" into tW
      put the height of stack "HowstrBeta" into tH
      -- horizontal
      if tL < 0 then
         -- adjust to right side of mouse
         put tR-tL into tSize
         put tX+10 into tL
         put tX+tSize+10 into tR
      else if tR > tW then
         put tR-tL into tSize
         put tX-5 into tR
         put tX-5-tSize into tL
         -- adjust to left side of mouse
      end if
      -- vertical
      if tT < 50 then
         -- adjust below mouse
         put tB-tT into tSize
         put tY+10 into tT
         put tY+tSize+10 into tB
      else if tB > tH then
         -- adjust above mouse
         put tB-tT into tSize
         put tY+5 into tB
         put tY-tSize-5 into tT
      end if
      put tL,tT,tR,tB into tNow["tooltipRect"]
      set the rect of field "tooltipField" stack "HowstrBeta" to tNow["tooltipRect"]
      --      set the topleft of field "tooltipField" stack "HowstrBeta" to tNow["moving"]
      set the layer of field "tooltipField" stack "HowstrBeta" to top
      set the visible of field "tooltipField" stack "HowstrBeta" to true
      unlock screen
   else
      set the visible of field "tooltipField" stack "HowstrBeta" to false
      put empty into tNow["tooltipRect"]
   end if -- tooltip checked, and inside a graph element, and butt 1/3 not down
   -------------------------------- end tooltip -----------------------------------
   
   -- (1c) if there's an anchor node, track new areas entered
   if p1Down is empty then
      -- either not inside a node, or mouse not down, or both
      put empty into p1Enter
   else if (pHist["inside"] is not empty) and (tNow["inside"] is empty) then
      -- just entered background
      put "background" into p1Enter
   else if pHist["inside"] is not tNow["inside"] then
      -- just entered a graph element
      put tNow["inside"] into p1Enter
   end if
   
   -- (2) build preview request
   -- defaults to "nothing"
   put "nothing" into tPreview
   if p1Down is among the keys of pGUI["nodes"] then -- butt down in a node
      -- anchor and target
      if p1Enter is among the keys of pGUI["nodes"] and p1Enter is not p1Down then -- entered another node
         put p1Down & "," & p1Enter into tPreview -- preview appropriate links/nodes between anchor & target
      else if p1Enter is p1Down then -- reentered node where butt down
         --         put p1Down & "," & "info" into tPreview -- ! swap 1
         put p1Down into tPreview -- preview focus on this node
      end if
      -- link can't be target
      if p1Enter is among the keys of pGUI["links"] then put "nothing" into tPreview -- don't do anything if entered a link
      
      if p1Enter is empty then -- never left the node where butt down
         if p1Down is among the keys of pGUI["nodes"] then -- butt down in node (already checked for this in first if ?!)
            --            if p1Down is pFocus then
            --               put "nothing" into tPreview
            --            else
            --               --               put p1Down into tPreview -- ! swap 2
            --               put p1Down & "," & "info" into tPreview
            --            end if
            put p1Down & "," & "info" into tPreview -- show info preview
         else
            put "nothing" into tPreview -- down in something not a node, no info preview
         end if
      end if
      if p1Enter is "background" and p1Down is among the keys of pGUI["nodes"] then
         put "nothing" into tPreview
         if item 1 of the mouseLoc < item 1 of the rect of pGUI["nodes"][p1Down]["graphic"] then put p1Down & ",left" into tPreview
         if item 1 of the mouseLoc > item 3 of the rect of pGUI["nodes"][p1Down]["graphic"] then put p1Down & ",right" into tPreview
      end if
   end if
   
   -- ! for development
   repeat for each key tKey in tNow
      put tKey & ":" && tNow[tKey] & cr after tBlerg
   end repeat
   put "p1Down:" && p1Down & cr after tBlerg
   put "p1Enter:" && p1Enter & cr after tBlerg
   put "preview:" && tPreview after tBlerg
   put tBlerg into field "viewMouse" stack "HowstrBeta" 
   
   put false into tCommit
   -- button 1 just transitioned from down to up while there's an anchor
   if p1Down is not empty and pHist["1down"] is true and tNow["1down"] is false then 
      -- if mouse(1) never returns "down" then all the above is skipped and s1Down&s1Enter stay empty
      -- the first time mouse(1) is down, 'inside' is put into s1Down (# if in a graph part, empty otherwise)
      -- as long as s1Down stays empty nothing happens, and s1Enter is emptied out just in case
      -- when mouse(1) first shows down, and a # is in 'inside', then s1Down gets it
      -- s1Enter starts checking if 'inside' changes, but stays empty
      -- when 'inside' changes, while s1Down is not empty, then the new # goes in s1Enter
      -- if the mouse never left the anchor place, then s1Enter stayed empty
      -- if the mouse returned to the anchor place, then s1Enter has its #   
      -- therefore
      -- if s1Enter is empty, the user clicked, so change focus
      -- if s1Enter is background or #, the mouse is previewing
      -- background: above/below node = nothing
      -- background: right = new out-link-node
      -- background: left = new node-link-in
      -- #: link = nothing
      -- #: node = new series of nodes & links
      -- info: = open node info
      put true into tCommit
      put tPreview & cr before field "viewCommitments" stack "HowstrBeta"   -- ! for development
      put empty into p1Down
      put empty into p1Enter
   end if
   put tNow into pHist
   -- preview is a message to the frontend to preview a change, if appropriate
   -- previewAndChange() will return whatever the outcome of that logic is
   -- goes in: nothing OR # OR #,# OR #,left OR #,right OR #,info
   -- comes out: nothing OR a properly formatted change request array
   put previewAndChange(tPreview,pGUI,pNode) into tRequest
   if tRequest is not "nothing" and tCommit is true then 
      return tRequest
   else
      return "nothing"
   end if
end mouseTracker

function previewAndChange pToDo,pGUI,pNode -- returns "nothing" or array with change request
   put "function previewAndChange" into xX["write"];    devLog xX
   -- pToDo = nothing OR # OR #,# OR #,left OR #,right OR #,info
   -- pGUI = array of info necessary for display, preview and change
   -- pNode = display size of nodes in pixels   
   
   if pToDo is "nothing" then
      set the visible of graphic "preFlow1" stack "HowstrBeta" to false
      set the visible of field "preState" stack "HowstrBeta" to false
      set the visible of field "preChange" stack "HowstrBeta" to false
      set the visible of graphic "preFlow2" stack "HowstrBeta" to false
      set the visible of graphic "preFocus" stack "HowstrBeta" to false
      set the visible of widget "preInfo" stack "HowstrBeta" to false
      return "nothing"
   end if
   -- expand node to view/edit info
   if item 2 of pToDo is "info" then
      put pGUI["nodes"][item 1 of pToDo]["horz"] & "," & pGUI["nodes"][item 1 of pToDo]["vert"] into tSpot
      set the location of widget "preInfo" stack "HowstrBeta" to tSpot
      set the visible of widget "preInfo" stack "HowstrBeta" to true
      put item 1 of pToDo into tWhatever["info"]
      
      set the visible of graphic "preFlow1" stack "HowstrBeta" to false
      set the visible of field "preState" stack "HowstrBeta" to false
      set the visible of field "preChange" stack "HowstrBeta" to false
      set the visible of graphic "preFlow2" stack "HowstrBeta" to false
      set the visible of graphic "preFocus" stack "HowstrBeta" to false
      return tWhatever
   else
      set the visible of widget "preInfo" stack "HowstrBeta" to false
   end if
   -- shift focus to another node
   if the number of items of pToDo is 1 and pToDo is a number then
      put pGUI["nodes"][pToDo]["horz"] & "," & pGUI["nodes"][pToDo]["vert"] into tSpot
      set the location of graphic "preFocus" stack "HowstrBeta" to tSpot
      set the visible of graphic "preFocus" stack "HowstrBeta" to true
      put pToDo into tWhatever["focus"]
      -- make sure these don't show at the same time
      set the visible of graphic "preFlow1" stack "HowstrBeta" to false
      set the visible of field "preState" stack "HowstrBeta" to false
      set the visible of field "preChange" stack "HowstrBeta" to false
      set the visible of graphic "preFlow2" stack "HowstrBeta" to false
      return tWhatever
   else
      set the visible of graphic "preFocus" stack "HowstrBeta" to false
   end if
   ----------------------------------- research all conditions -------------------------
   -- tUno=# (always anchor)
   -- tDos=# left right (always target)
   -- tStartAtDos=true false
   -- adjacent=false or # (of link)
   -- unoType=state change
   -- dosType=state change
   -- sameType=true false
   put item 1 of pToDo into tUno
   put item 2 of pToDo into tDos
   -- link from uno-to-dos or dos-to-uno
   put false into tStartAtDos
   if tDos is "left" then
      put true into tStartAtDos
   else if tDos is a number then
      -- use existing drawing to figure out flow direction
      put the rect of pGUI["nodes"][tUno]["graphic"] into tUnoRect
      put the rect of pGUI["nodes"][tDos]["graphic"] into tDosRect
      if not (item 1 of tUnoRect < item 3 of tDosRect) then put true into tStartAtDos
   end if
   -- node types
   put pGUI["nodes"][tUno]["type"] into tUnoType
   put pGUI["nodes"][tDos]["type"] into tDosType
   if tUnoType is tDosType then
      put true into tSameType
   else
      put false into tSameType
   end if
   -- adjacency
   -- link,node
   put false into tAdjacent
   put false into tDownish
   put false into tUpish
   repeat for each line tLine in pGUI["nodes"][tUno]["abutFlow"]
      if tDos is item 2 of tLine then put item 1 of tLine into tAdjacent
   end repeat
   repeat for each line tLine in pGUI["nodes"][tUno]["abutDive"]
      if pGUI["case"] is item 2 of tLine then put item 1 of tLine into tDownish
   end repeat
   repeat for each line tLine in pGUI["nodes"][tUno]["abutRise"]
      if pGUI["case"] is item 2 of tLine then put item 1 of tLine into tUpish
   end repeat
   ------------------------------ end condition research -------------------------------
   ------------------------------ geometry help -----------------------------------
   put pNode / 2 into tHalfNode
   put the mouseLoc into tMoving
   put (item 2 of tMoving - pNode) into item 2 of tMoving
   if tDos is a number then
      -- two fixed nodes
      if tStartAtDos is false then
         put (pGUI["nodes"][tUno]["horz"] + tHalfNode) into tStartH
         put pGUI["nodes"][tUno]["vert"] into tStartV
         put (pGUI["nodes"][tDos]["horz"] - tHalfNode) into tEndH
         put pGUI["nodes"][tDos]["vert"] into tEndV
      else
         put (pGUI["nodes"][tDos]["horz"] + tHalfNode) into tStartH
         put pGUI["nodes"][tDos]["vert"] into tStartV
         put (pGUI["nodes"][tUno]["horz"] - tHalfNode) into tEndH
         put pGUI["nodes"][tUno]["vert"] into tEndV
      end if
   else if tStartAtDos is false then
      -- uno fixed, dos is "left" or "right", tStartAtDos has to be false if "right"
      put (pGUI["nodes"][tUno]["horz"] + tHalfNode) into tStartH
      put pGUI["nodes"][tUno]["vert"] into tStartV
      put (item 1 of tMoving - tHalfNode) into tEndH
      put item 2 of tMoving into tEndV
   else
      put (item 1 of tMoving + tHalfNode) into tStartH
      put item 2 of tMoving into tStartV
      put (pGUI["nodes"][tUno]["horz"] - tHalfNode) into tEndH
      put pGUI["nodes"][tUno]["vert"] into tEndV
   end if
   put tStartH & "," & tStartV into tStartCoord
   put tEndH & "," & tEndV into tEndCoord
   put tStartCoord & cr & tEndCoord into tLineCoord
   put lineMidpoint(tLineCoord) into tMidCoord -- mathamagics.livecode
   -- offset midpoint, normal to line, above midpoint vertical
   -- line will always be left-to-right, so offset just goes +H relative to midpoint
   put 0 & "," & pNode into tOffCoord
   put rotateCoord(tOffCoord,tLineCoord) into tOffCoord -- mathamagics.livecode
   put (item 1 of tMidCoord + item 1 of tOffCoord) into item 1 of tOffCoord
   put (item 2 of tMidCoord + item 2 of tOffCoord) into item 2 of tOffCoord
   -- room around offset midpoint for a preview node
   put (item 1 of tOffCoord - tHalfNode) & "," & (item 2 of tOffCoord) into tMidLeft
   put (item 1 of tOffCoord + tHalfNode) & "," & (item 2 of tOffCoord) into tMidRight
   -- location(s) of other node when previewing two
   -- ? not sure if I actually used these two
   put (item 1 of tOffCoord + pNode) & "," & (item 2 of tOffCoord) into tOffCoordRight
   put (item 1 of tOffCoord - pNode) & "," & (item 2 of tOffCoord) into tOffCoordLeft
   -- location when preview following the mouse
   put (item 1 of the mouseLoc) & "," & (item 2 of the mouseLoc - pNode) into tPlace
   put (item 1 of tPlace + tHalfNode) & "," & (item 2 of tPlace) into tStart
   put (pGUI["nodes"][tNode]["horz"] - tHalfNode) & "," & pGUI["nodes"][tNode]["vert"] into tEnd
   put tStart & cr & tEnd into tLine
   ------------------------------ end geometry help ------------------------------
   -- show a single flow between the nodes
   if tUno is a number and tDos is a number and tSameType is false and tAdjacent is false then
      set the points of graphic "preFlow1" stack "HowstrBeta" to tLineCoord
      set the visible of graphic "preFlow1" stack "HowstrBeta" to true
      set the visible of graphic "preFlow2" stack "HowstrBeta" to false
      set the visible of field "preState" stack "HowstrBeta" to false
      set the visible of field "preChange" stack "HowstrBeta" to false
      -- format graph change request
      -- ! don't have a return address for area yet, but will need that
      put"flow_btwn_diffType" into tTemp[0]["act"]
      put "flow" into tTemp["a"]["type"]
      if tStartAtDos is false then
         put tUno into tTemp["a"]["backward"]
         put tDos into tTemp["a"]["forward"]
      else
         put tDos into tTemp["a"]["backward"]
         put tUno into tTemp["a"]["forward"]
      end if 
      return tTemp
   end if
   -- show a single node, and two flows, between the nodes
   if tUno is a number and tDos is a number and tSameType is true then
      set the points of graphic "preFlow1" stack "HowstrBeta" to (tStartCoord & cr & tMidLeft)
      set the points of graphic "preFlow2" stack "HowstrBeta" to (tMidRight & cr & tEndCoord)
      set the visible of graphic "preFlow1" stack "HowstrBeta" to true
      set the visible of graphic "preFlow2" stack "HowstrBeta" to true
      if tUnoType is "state" then
         set the location of field "preChange" stack "HowstrBeta" to tOffCoord
         set the visible of field "preChange" stack "HowstrBeta" to true
         set the visible of field "preState" stack "HowstrBeta" to false
      else
         set the location of field "preState" stack "HowstrBeta" to tOffCoord
         set the visible of field "preChange" stack "HowstrBeta" to false
         set the visible of field "preState" stack "HowstrBeta" to true
      end if
      -- format graph change request
      -- ! don't have a return address for area yet, but will need that
      /*
      x[a][type]=state/change
      x[b][type]=flow
      x[b][backward]=#/ltr
      x[b][forward]=#/ltr
      x[c][type]=flow
      x[c][backward]=#/ltr
      x[c][forward]=#/ltr
      */
      put "span_detached_sameType" into tTemp[0]["act"]
      if tUnoType is "state" then
         put "change" into tTemp["a"]["type"]
      else
         put "state" into tTemp["a"]["type"]
      end if
      --      put "user" into tTemp["b"]["from"]
      put "flow" into tTemp["b"]["type"]
      put "flow" into tTemp["c"]["type"]
      if tStartAtDos is false then
         put tUno into tTemp["b"]["backward"]
         put "a" into tTemp["b"]["forward"]
         put "a" into tTemp["c"]["backward"]
         put tDos into tTemp["c"]["forward"]
      else
         put tDos into tTemp["b"]["backward"]
         put "a" into tTemp["b"]["forward"]
         put "a" into tTemp["c"]["backward"]
         put tUno into tTemp["c"]["forward"]
      end if 
      return tTemp
   end if
   -- from one node to neighbor, so type is different
   -- must show state and change, in correct order
   -- must show flow, on correct side
   if tUno is a number and tDos is a number and not (tAdjacent is false) then ------------------------------------------------
      -- flow preview attached to uno (anchor)
      set the visible of graphic "preFlow1" stack "HowstrBeta" to true
      set the visible of graphic "preFlow2" stack "HowstrBeta" to false
      -- format graph change request
      -- state node [a], change node [b], three flows [c][d][e]
      -- hide existing flow [#]
      put "inject_btwn_diffType" into tTemp[0]["act"]
      put "state" into tTemp["a"]["type"]
      put "change" into tTemp["b"]["type"]
      put "flow" into tTemp["c"]["type"]
      put "flow" into tTemp["d"]["type"]
      put "flow" into tTemp["e"]["type"]
      put tAdjacent into tTemp["hide"]
      if tStartAtDos is false and tUnoType is "state" then
         set the points of graphic "preFlow1" stack "HowstrBeta" to (tStartCoord & cr & tMidLeft)
         set the location of field "preChange" stack "HowstrBeta" to tOffCoord
         set the location of field "preState" stack "HowstrBeta" to ((item 1 of tOffCoord + pNode) & "," & item 2 of tOffCoord)
         set the visible of field "preChange" stack "HowstrBeta" to true
         set the visible of field "preState" stack "HowstrBeta" to true
         -- format graph change request
         -- uno > flow c > change b > flow d > state a > flow e > dos
         put tUno into tTemp["c"]["backward"]
         put "b" into tTemp["c"]["forward"]
         put "b" into tTemp["d"]["backward"]
         put "a" into tTemp["d"]["forward"]
         put "a" into tTemp["e"]["backward"]
         put tDos into tTemp["e"]["forward"]
      else if tStartAtDos is false and tUnoType is "change" then
         set the points of graphic "preFlow1" stack "HowstrBeta" to (tStartCoord & cr & tMidLeft)
         set the location of field "preState" stack "HowstrBeta" to tOffCoord
         set the location of field "preChange" stack "HowstrBeta" to ((item 1 of tOffCoord + pNode) & "," & item 2 of tOffCoord)
         set the visible of field "preChange" stack "HowstrBeta" to true
         set the visible of field "preState" stack "HowstrBeta" to true
         -- format graph change request
         -- uno > flow c > state a > flow d > change b > flow e > dos
         put tUno into tTemp["c"]["backward"]
         put "a" into tTemp["c"]["forward"]
         put "a" into tTemp["d"]["backward"]
         put "b" into tTemp["d"]["forward"]
         put "b" into tTemp["e"]["backward"]
         put tDos into tTemp["e"]["forward"]
      else if tStartAtDos is true and tDosType is "state" then
         set the points of graphic "preFlow1" stack "HowstrBeta" to (tMidRight & cr & tEndCoord)
         set the location of field "preState" stack "HowstrBeta" to tOffCoord
         set the location of field "preChange" stack "HowstrBeta" to ((item 1 of tOffCoord - pNode) & "," & item 2 of tOffCoord)
         set the visible of field "preChange" stack "HowstrBeta" to true
         set the visible of field "preState" stack "HowstrBeta" to true
         -- format graph change request
         -- dos > flow e > change b > flow d > state a > flow c > uno
         put tDos into tTemp["e"]["backward"]
         put "b" into tTemp["e"]["forward"]
         put "b" into tTemp["d"]["backward"]
         put "a" into tTemp["d"]["forward"]
         put "a" into tTemp["c"]["backward"]
         put tUno into tTemp["c"]["forward"]       
      else if tStartAtDos is true and tDosType is "change" then
         set the points of graphic "preFlow1" stack "HowstrBeta" to (tMidRight & cr & tEndCoord)
         set the location of field "preChange" stack "HowstrBeta" to tOffCoord
         set the location of field "preState" stack "HowstrBeta" to ((item 1 of tOffCoord - pNode) & "," & item 2 of tOffCoord)
         set the visible of field "preChange" stack "HowstrBeta" to true
         set the visible of field "preState" stack "HowstrBeta" to true
         -- format graph change request
         -- dos > flow e > state a > flow d > change b > flow c > uno
         put tDos into tTemp["e"]["backward"]
         put "a" into tTemp["e"]["forward"]
         put "a" into tTemp["d"]["backward"]
         put "b" into tTemp["d"]["forward"]
         put "b" into tTemp["c"]["backward"]
         put tUno into tTemp["c"]["forward"]
      end if
      return tTemp
   end if
   -- show "left" or "right" node(s), as appropriate, and flow on correct side --------------------------------
   if tDos is "left" or tDos is "right" then
      -- need a flow [a] and a state [b]
      -- need a dive/rise [c]
      -- maybe a change [d] and another flow [e]
      -- maybe hide existing dive/rise [#]
      -- tUpish will have rise if "right"
      -- tDownish will have dive if "left"
      put "flow_branch" into tTemp[0]["act"]
      put "flow" into tTemp["a"]["type"]
      put "state" into tTemp["b"]["type"]
      if tDos is "right" and tUnoType is "change" then -- can't be #,# if script got this far
         set the points of graphic "preFlow1" stack "HowstrBeta" to tLineCoord
         set the location of field "preState" stack "HowstrBeta" to tMoving
         set the visible of field "preChange" stack "HowstrBeta" to false
         set the visible of field "preState" stack "HowstrBeta" to true
         set the visible of graphic "preFlow1" stack "HowstrBeta" to true
         set the visible of graphic "preFlow2" stack "HowstrBeta" to false
         -- format graph change request
         -- uno > flow a > state b > rise c > case
         put tUno into tTemp["a"]["backward"]
         put "b" into tTemp["a"]["forward"]
         put "rise" into tTemp["c"]["type"]
         put "b" into tTemp["c"]["backward"]
         put pGUI["case"] into tTemp["c"]["forward"]
      else if tDos is "right" and tUnoType is "state" then
         set the points of graphic "preFlow1" stack "HowstrBeta" to tLineCoord
         set the location of field "preChange" stack "HowstrBeta" to tMoving
         set the location of field "preState" stack "HowstrBeta" to ((item 1 of tMoving + pNode) & "," & item 2 of tMoving)
         set the visible of field "preChange" stack "HowstrBeta" to true
         set the visible of field "preState" stack "HowstrBeta" to true
         set the visible of graphic "preFlow1" stack "HowstrBeta" to true
         set the visible of graphic "preFlow2" stack "HowstrBeta" to false
         -- format graph change request
         -- uno > flow a > change d > flow e > state b > rise c > case
         -- since this is a state, going right, it might already have a rise link
         put tUno into tTemp["a"]["backward"]
         put "d" into tTemp["a"]["forward"]
         put "change" into tTemp["d"]["type"]
         put "flow" into tTemp["e"]["type"]
         put "d" into tTemp["e"]["backward"]
         put "b" into tTemp["e"]["forward"]
         put "rise" into tTemp["c"]["type"]
         put "b" into tTemp["c"]["backward"]
         put pGUI["case"] into tTemp["c"]["forward"]
         if not (tUpish is false) then 
            put tUpish into tTemp["hide"]
         end if
      else if tDos is "left" and tUnoType is "change" then
         set the points of graphic "preFlow1" stack "HowstrBeta" to tLineCoord
         set the location of field "preState" stack "HowstrBeta" to tMoving
         set the visible of field "preChange" stack "HowstrBeta" to false
         set the visible of field "preState" stack "HowstrBeta" to true
         set the visible of graphic "preFlow1" stack "HowstrBeta" to true
         set the visible of graphic "preFlow2" stack "HowstrBeta" to false
         -- format graph change request
         -- case > dive c > state b > flow a > uno
         put "dive" into tTemp["c"]["type"]
         put pGUI["case"] into tTemp["c"]["backward"]
         put "b" into tTemp["c"]["forward"]
         put "b" into tTemp["a"]["backward"]
         put tUno into tTemp["a"]["forward"]
      else if tDos is "left" and tUnoType is "state" then
         set the points of graphic "preFlow1" stack "HowstrBeta" to tLineCoord
         set the location of field "preChange" stack "HowstrBeta" to tMoving
         set the location of field "preState" stack "HowstrBeta" to ((item 1 of tMoving - pNode) & "," & item 2 of tMoving)
         set the visible of field "preChange" stack "HowstrBeta" to true
         set the visible of field "preState" stack "HowstrBeta" to true
         set the visible of graphic "preFlow1" stack "HowstrBeta" to true
         set the visible of graphic "preFlow2" stack "HowstrBeta" to false
         -- format graph change request
         -- case > c > b > e > d > a > uno
         -- since this is a state, going left, it might already have a dive link
         if not (tDownish is false) then 
            put tDownish into tTemp["hide"]
         end if
         put "dive" into tTemp["c"]["type"]
         put pGUI["case"] into tTemp["c"]["backward"]
         put "b" into tTemp["c"]["forward"]
         put "flow" into tTemp["e"]["type"]
         put "b" into tTemp["e"]["backward"]
         put "d" into tTemp["e"]["forward"]
         put "change" into tTemp["d"]["type"]
         put "d" into tTemp["a"]["backward"]
         put tUno into tTemp["a"]["forward"]
      end if
      return tTemp
   end if
end previewAndChange

on graphManager pDo -- ! will be more complicated when not just a test
   put "on graphManager" into xX["write"];    devLog xX
   -- makes any changes, then calls draw functions, which call display functions
   -- pDo empty OR #,# OR #,left OR #,right OR #
   -- make changes if passed in parameter pDo
   if pDo is empty then
      -- whatevs
   else if pDo is a number then
      -- #
      put pDo into sNowFocus
   else if item 2 of pDo is a number then
      -- #,#
      -- check for existing link between these two nodes
      -- if there is already a link, that will dictate which way to go
      put item 1 of pDo into tAnchor
      put item 2 of pDo into tTarget
      put empty into tWas
      repeat for each word tType in "next prev"
         repeat for each item tPointer in sGraphData["nodes"][tAnchor][tType]
            put item 1 of sGraphData["links"][tPointer][tType] into tTest
            if tTest is tTarget then 
               -- tAnchor has a pointer to a link with a pointer to tTarget
               -- delete link
               delete variable sGraphData["links"][tPointer]
               -- delete pointer to link in tAnchor
               delete item itemOffset(tPointer,sGraphData["nodes"][tAnchor][tType]) of sGraphData["nodes"][tAnchor][tType]
               -- delete pointer to link in tTarget
               if tType is "next" then delete item itemOffset(tPointer,sGraphData["nodes"][tTarget]["prev"]) of sGraphData["nodes"][tTarget]["prev"]
               if tType is "prev" then delete item itemOffset(tPointer,sGraphData["nodes"][tTarget]["next"]) of sGraphData["nodes"][tTarget]["next"]
               put tType into tWas
            end if
         end repeat
      end repeat
      -- link found and deleted means tWas has the direction for the new link(s) relative to tAnchor
      -- link not found means that the correct direction has to be discovered
      if tWas is empty then
         -- assume anchor-to-target, unless their layer order prevents that 
         -- ! layer order is a proxy for actually checking if the link creates a cycle
         -- ! doing it this way will have undesirable edge cases
         put sGraphDrawing["nodes"][tAnchor]["layer"] into tAnchorLay
         put sGraphDrawing["nodes"][tTarget]["layer"] into tTargetLay
         if tTargetLay < tAnchorLay then
            put tTarget into tStart
            put tAnchor into tEnd
         else
            put tTarget into tEnd
            put tAnchor into tStart
         end if
      else -- tWas not empty
         if tWas is "next" then
            put tAnchor into tStart
            put tTarget into tEnd
         else
            put tTarget into tStart
            put tAnchor into tEnd
         end if
      end if
      -- now we know that the link(s) should go from node tStart to node tEnd
      -- and that there's no existing link in the way
      -- need new link, new node, and new link
      put sGraphData["lastRec"] into tRec      
      put tStart & "," after sGraphData["links"][tRec+1]["prev"]
      put tRec+2 & "," after sGraphData["links"][tRec+1]["next"]
      
      put tRec+1 & "," after sGraphData["nodes"][tRec+2]["prev"]
      put tRec+3 & "," after sGraphData["nodes"][tRec+2]["next"]
      
      put tRec+2 & "," after sGraphData["links"][tRec+3]["prev"]
      put tEnd & "," after sGraphData["links"][tRec+3]["next"]
      
      put tRec+3 & "," after sGraphData["nodes"][tEnd]["prev"]
      put tRec+1 & "," after sGraphData["nodes"][tStart]["next"]      
      put tRec+3 into sGraphData["lastRec"] 
   else
      -- #,left/right
      put item 1 of pDo into tNode
      put item 2 of pDo into tDir
      if tDir is "left" then
         put sGraphData["lastRec"] into tRec
         put tRec+1 & "," after sGraphData["nodes"][tNode]["prev"]
         put tNode & "," after sGraphData["links"][tRec+1]["next"]
         put tRec+2 & "," after sGraphData["links"][tRec+1]["prev"]
         put tRec+1 & "," after sGraphData["nodes"][tRec+2]["next"]
         put tRec+2 into sGraphData["lastRec"]
      else if tDir is "right" then
         put sGraphData["lastRec"] into tRec
         put tRec+1 & "," after sGraphData["nodes"][tNode]["next"]
         put tNode & "," after sGraphData["links"][tRec+1]["prev"]
         put tRec+2 & "," after sGraphData["links"][tRec+1]["next"]
         put tRec+1 & "," after sGraphData["nodes"][tRec+2]["prev"]
         put tRec+2 into sGraphData["lastRec"]
      end if
   end if
   middleOut sGraphData
end graphManager

-- ! 15FEB2016 using writeInstructionsHTML now, but this is more general so don't delete
--function writeInstructions @pMain,@pShort,pTopo,pNoVisit
--   put "function writeInstructions" into xX["write"];    devLog xX
--   repeat for each key tDoc in pTopo
--      put empty into tInstructions
--      put empty into tFootnotes -- array[tDoc]=1,2,3,n note rec in footnote order
--      put empty into tIndent
--      put empty into tScope
--      repeat for each item tRec in pTopo[tDoc]
--         put empty into tTheNotes
--         -- use OPEN label if this is the first reference to a particular container node, and increase indent
--         -- use CLOSE label if this is the second reference, and decrease indent
--         if pShort[tDoc][tRec]["read"] is not empty and pShort[tDoc][tRec]["bulk"] is not empty then
--            if tRec is among the items of tScope then
--               -- container node, and second time listed
--               put tDoc into tStuff["doc"]
--               put tRec into tStuff["rec"]
--               put cr & tIndent && "CLOSE" && stepString(pMain,tStuff) after tInstructions
--               delete char -1 of tIndent
--            else -- container node, first time listed
--               put tDoc into tStuff["doc"]
--               put tRec into tStuff["rec"]
--               put cr & tIndent && itemOffset(tRec,pTopo[tDoc]) && "OPEN" && stepString(pMain,tStuff) after tInstructions
--               put tRec & "," after tScope
--               put "-" after tIndent
--            end if -- tRec among tScope
--         else -- not a container node
--            put tDoc into tStuff["doc"]
--            put tRec into tStuff["rec"]
--            put cr & tIndent && itemOffset(tRec,pTopo[tDoc]) && stepString(pMain,tStuff) after tInstructions
--         end if -- read and bulk not empty
--         -- ! this logic isn't applicable since bond links arnen't used anymore
--         -- build the footnote list
--         --         if tRec is among the keys of sNoteList[tDoc] then
--         --            -- this step has one or more notes
--         --            repeat for each item tNote in sNoteList[tDoc][tRec]
--         --               if tNote is among the items of tFootnotes[tDoc] then
--         --                  -- this note, bonded to tRec, already has a footnote position
--         --                  put itemOffset(tNote,tFootnotes[tDoc]) & "," after tTheNotes
--         --               else
--         --                  -- this note, bonded to tRec, does not yet have a footnote position
--         --                  put tNote & "," after tFootnotes[tDoc]
--         --                  put itemOffset(tNote,tFootnotes[tDoc]) & "," after tTheNotes
--         --               end if
--         --            end repeat
--         --            if char -1 of tTheNotes is "," then delete char -1 in tTheNotes
--         --            put " *" & tTheNotes & cr after tInstructions
--         --         end if
--      end repeat -- tRec in pTopo[tDoc]
--      -- ! also not applicable anymore, since no more bond links
--      --      put cr & "NOTES" after tInstructions
--      --      repeat for each item tFoot in tFootnotes[tDoc]
--      --         put cr & itemOffset(tFoot,tFootnotes[tDoc]) && stepString(tDoc,tFoot) after tInstructions
--      --      end repeat -- tFoot in tFootnotes
--      -------- orphans ------------------
--      if pNoVisit[tDoc] is not empty then
--         put empty into tRollCall
--         repeat for each item tOrphan in pNoVisit[tDoc]
--            if pShort[tDoc][tOrphan]["type"] is among the words of "state change" then
--               put tDoc into tStuff["doc"]
--               put tOrphan into tStuff["rec"]
--               put cr & stepString(pMain,tStuff) after tRollCall
--            end if
--         end repeat
--         if tRollCall is not empty then
--            put cr & "ORPHANS" after tInstructions
--            put tRollCall after tInstructions
--         end if
--      end if
--   end repeat -- tDoc in pTopo
--   filter tInstructions without empty
--   put pMain[1][0]["filepath"] into tPath
--   set the itemdelimiter to slash
--   put "resources.html" into item -1 of tPath
--   put tInstructions into field "testHtml" stack "HowstrBeta"-- needs to be in field for following edits
--   -- add link to resources
--   put "Resources" & cr before line 1 of field "testHtml" stack "HowstrBeta"
--   set the textStyle of word 1 of line 1 of field "testHtml" stack "HowstrBeta" to link
--   set the linkText of word 1 of line 1 of field "testHtml" stack "HowstrBeta" to tPath
--   -- add an easily understood header
--   put "Sorted Steps (Instructions) as of" && the system date && the system time & cr before line 1 of field "testHtml" stack "HowstrBeta"
--   set the textStyle of line 1 of field "testHtml" stack "HowstrBeta" to "bold"
--   -- create or overwrite the instructions 
--   put "instructions.html" into item -1 of tPath
--   put the HTMLText of field "testHtml" stack "HowstrBeta" into URL ("file:" & tPath)
--end writeInstructions

function writeInstructionsHTML @pMain,@pShort,pTopo,pNoVisit
   -- writes instructions directly in html
   -- ! assumes only one doc (doc 1) and only one scope level as of 14FEB2016
   put empty into tInstructions
   -- ! pTopo has case node listed first and last, which is redundant as long as we're only allowing one scope level 15FEB2016
   -- pTopo controls in what order the steps appear
   -- tDetailOrder controls in what order each piece of information (tag) appears in each step
   --   put "stepString anchor cr memo cr figure cr prev cr next" into tDetailOrder
   put "cr weight stepString anchor cr memo cr figure" into tDetailOrder -- don't need next/prev for action table
   put pMain[1][0]["filepath"] into tPath -- absolute path to *.how file
   set the itemdelimiter to slash
   put "resources.html" into item -1 of tPath -- now absolute path to resources file adjacent to *.how file
   put "<html>" & cr after tInstructions
   -- header kind of thing ----------------------------------------
   set the itemdelimiter to comma
   put item 1 of pTopo[1] into tCase
   put pShort[1][tCase]["title"] into tCaseTitle
   put "<head>" & cr & "<title>" after tInstructions
   if tCaseTitle is not empy then 
      --      put "<p><b>" & tCaseTitle & "</b></p>" & cr after tInstructions
      put tCaseTitle after tInstructions
   else
      --      put "<p><b>Untitled</b></p>" & cr after tInstructions
      put "Untitled" into tCaseTitle
      put tCaseTitle after tInstructions
   end if
   put " - Generated by Howstr" after tInstructions
   put "</title>" & cr & "</head>" & cr & "<body>" & cr after tInstructions
   put "<p><b>" & tCaseTitle & "</b></p>" & cr after tInstructions
   set the wholematches to true
   delete item (itemoffset(tCase,pTopo[1])) of pTopo[1]
   delete item (itemoffset(tCase,pTopo[1])) of pTopo[1] -- get rid of case node at start and end of list, at least for now 15FEB2016
   put "<p><b>Sorted steps (Instructions) as of" && the system date && the system time & "</b></p>" & cr after tInstructions
   put "<p><a href=" & quote & tPath & quote & ">Resources</a></p>" & cr after tInstructions
   -- Howstr credit
   put "<p><a href=" & quote & "http://github.howstr.com" & quote & ">Generated by Howstr</a><p>" & cr after tInstructions
   -- list of only the change steps (define action groups)
   put empty into pTopoChanges
   repeat for each item tBlerg in pTopo[1]
      if pShort[1][tBlerg]["type"] is "change" then put tBlerg into item (the number of items of pTopoChanges)+1 of pTopoChanges
   end repeat
   -- start action table
   -- column header list
   -- column input states
   -- column change
   -- column output states
   -- end action table
   put 0 into tCount
   put empty into tTopoVisited
   repeat for each item tRec in pTopoChanges
      put tCount + 1 into tCount
      put empty into tStuff
      put "<p><b>Action" && tCount & ") </b>" & cr after tInstructions -- once to start the step
      put "<table border=" & quote & "1" & quote & ">" & cr after tInstructions
      put "<tr><th>In State(s)</th><th>Change</th><th>Out State(s)</th></tr>" & cr after tInstructions
      -- build a string to expand on
      put empty into tTable
      set itemdelimiter to comma
      put "rStart" into item 1 of tTable
      -- prev
      put "cStart" into item (the number of items of tTable)+1 of tTable
      repeat for each line tLine in pShort[1][tRec]["prev"]
         --         put pShort[1][tLine]["prev"] into item (the number of items of tTable)+1 of tTable
         put pShort[1][tLine]["prev"] into tNode
         put pShort[1][tLine]["weight"] into tWeight
         if tWeight is empty then put 1 into tWeight
         put tNode & "/" & tWeight into item (the number of items of tTable)+1 of tTable
      end repeat
      put "cEnd" into item (the number of items of tTable)+1 of tTable
      -- change
      put "cStart" into item (the number of items of tTable)+1 of tTable
      put tRec into item (the number of items of tTable)+1 of tTable
      put "cEnd" into item (the number of items of tTable)+1 of tTable
      -- next
      put "cStart" into item (the number of items of tTable)+1 of tTable
      repeat for each line tLine in pShort[1][tRec]["next"]
         --         put pShort[1][tLine]["next"] into item (the number of items of tTable)+1 of tTable
         put pShort[1][tLine]["next"] into tNode
         put pShort[1][tLine]["weight"] into tWeight
         if tWeight is empty then put 1 into tWeight
         put tNode & "/" & tWeight into item (the number of items of tTable)+1 of tTable
      end repeat
      put "cEnd" into item (the number of items of tTable)+1 of tTable
      put "rEnd" into item (the number of items of tTable)+1 of tTable
      
      -- step kind of things -------------------------------------------------
      repeat for each item tPiece in tTable
         switch 
            case tPiece is "rStart" -- start row
               put "<tr>" after tInstructions
               break
            case tPiece is "rEnd" -- end row
               put "</tr>" & cr after tInstructions
               break
            case tPiece is "cStart" -- start column
               put "<td valign=" & quote & "top" & quote & ">" after tInstructions
               break
            case tPiece is "cEnd" -- end column
               put "</td>" & cr after tInstructions
               break
            default 
               set the itemdelimiter to "/"
               put item 1 of tPiece into tNode
               put item 2 of tPiece into tWeight
               set the itemdelimiter to comma
               
               if tNode is among the items of tTopoVisited then -- only state recs end up in visited list, but it's okay cuz changes only appear once
                  -- just reference the previous step details
                  put pShort[1][tPrev]["prev"] into tPrev
                  put 1 into tStuff["doc"]
                  put tNode into tStuff["rec"]
                  put stepString(pMain,tStuff) into field "testHtml" stack "HowstrBeta"
                  put the htmltext of field "testHtml" stack "HowstrBeta" into tUgly
                  replace "<p>" with "" in tUgly
                  replace "</p>" with "" in tUgly
                  if tNode is tRec then -- this one is a change, so weight isn't applicable
                     put "<a href=" & quote & "#" & tNode & quote & ">" & tUgly & "</a>" after tInstructions
                  else
                     put "<a href=" & quote & "#" & tNode & quote & ">" & "(" & tWeight & "x) " & tUgly & "</a>" after tInstructions
                  end if
               else
                  put tNode into item (the number of items of tTopoVisited)+1 of tTopoVisited
                  -- since tNode hasn't been visited yet, write out all the details
                  repeat for each word tAdetail in tDetailOrder
                     switch tAdetail
                        case "weight"
                           if tNode is not tRec then put "(" & tWeight & "x) " after tInstructions
                           break
                        case "stepString"
                           put 1 into tStuff["doc"]
                           put tNode into tStuff["rec"]
                           put stepString(pMain,tStuff) into field "testHtml" stack "HowstrBeta"
                           put the htmltext of field "testHtml" stack "HowstrBeta" into tUgly
                           replace "<p>" with "<b>" in tUgly
                           replace "</p>" with "</b>" in tUgly
                           put tUgly after tInstructions
                           break
                        case "anchor"
                           put "<a name=" & quote & tNode & quote & "></a>" after tInstructions
                           break
                        case "cr"
                           put "<p></p>" & cr after tInstructions
                           break
                        case "memo"
                           put pShort[1][tNode]["memo"] into tMemo
                           if tMemo is not empty then put tMemo after tInstructions
                           break
                        case "figure"
                           put pShort[1][tNode]["figure"] into tFigure
                           if tFigure is not empty then 
                              set the itemdelimiter to slash
                              put item -1 of tFigure into tFigure
                              put "<a href=" & quote & tFigure & quote && "target=" & quote & "_blank" & quote & ">" after tInstructions
                              put "<img src=" & quote & tFigure & quote && "width=" & quote & "200" & quote & ">" after tInstructions
                              put "</a>" after tInstructions
                              set the itemdelimiter to comma
                           end if
                           break
                        case "prev"
                           put pShort[1][tNode]["prev"] into tList
                           if tList is not empty then
                              put "Previous step(s): " after tInstructions
                              repeat for each line tPrev in tList
                                 put pShort[1][tPrev]["prev"] into tPrev
                                 put 1 into tStuff["doc"]
                                 put tPrev into tStuff["rec"]
                                 put stepString(pMain,tStuff) into field "testHtml" stack "HowstrBeta"
                                 put the htmltext of field "testHtml" stack "HowstrBeta" into tUgly
                                 replace "<p>" with "" in tUgly
                                 replace "</p>" with "" in tUgly
                                 put "<a href=" & quote & "#" & tPrev & quote & ">" & tUgly & "</a>" after tInstructions
                              end repeat
                           end if
                           break
                        case "next"
                           put pShort[1][tNode]["next"] into tList
                           if tList is not empty then
                              put "Next step(s): " after tInstructions
                              repeat for each line tNext in tList
                                 put pShort[1][tNext]["next"] into tNext
                                 put 1 into tStuff["doc"]
                                 put tNext into tStuff["rec"]
                                 put stepString(pMain,tStuff) into field "testHtml" stack "HowstrBeta"
                                 put the htmltext of field "testHtml" stack "HowstrBeta" into tUgly
                                 replace "<p>" with "" in tUgly
                                 replace "</p>" with "" in tUgly
                                 put "<a href=" & quote & "#" & tNext & quote & ">" & tUgly && "</a>" after tInstructions
                              end repeat
                           end if
                           break
                     end switch -- what to do given tAdetail
                  end repeat -- word in tDetailOrder
               end if -- tNode is among tTopoVisited
         end switch -- what to do given tPiece
      end repeat -- item tPiece in tTable
      put "</table>" & cr after tInstructions
   end repeat -- item tRec in tTopoChanges
   put "</body>" & cr & "</html>" & cr after tInstructions
   return tInstructions
end writeInstructionsHTML

command arrayForBubble @pMain,@pShort,pTopo,pNoVisit,@pBubbleA ,@pSketch,@pResources  
   -- ! assumes only one doc (doc 1) and only one scope level as of 14FEB2016
   put empty into pBubbleA
   -- ! pTopo has case node listed first and last, which is redundant as long as we're only allowing one scope level 15FEB2016
   -- pTopo controls in what order the steps appear
   
   -- ! figure out how to handle the actual project folder and contents later
   -- ! maybe just zip the whole thing? there will probably be trouble with absolute/relative file paths
   -- put pMain[1][0]["filepath"] into tPath -- absolute path to *.how file
   
   ------------------------------------------------------------------- start instructions --------------------------------------------
   set the itemdelimiter to comma
   put item 1 of pTopo[1] into tCase
   put pMain[1][0]["filepath"] into pBubbleA["project"]["filepath"]
   put pMain[1][0]["UUID"] into pBubbleA["project"]["UUID"]
   
   put pShort[1][tCase]["title"] into pBubbleA["project"]["title"]
   --    if pBubbleA["project"]["title"] is empty then put "[untitled]" into pBubbleA["project"]["title"]
   put pShort[1][tCase]["memo"] into pBubbleA["project"]["memo"]
   --    if pBubbleA["project"]["memo"] is empty then put "[undescribed]" into pBubbleA["project"]["memo"]
   put pShort[1][tCase]["figure"] into pBubbleA["project"]["figure"]
   if pBubbleA["project"]["figure"] is not empty then
      put pBubbleA["project"]["figure"] into tFilename
      put pBubbleA["project"]["filepath"] into tFilepath
      set itemdelimiter to "/"
      put tFilename into item -1 of tFilepath
      put tFilepath into pBubbleA["project"]["figure"]
      set itemdelimiter to comma
   end if
   
   set the wholematches to true
   delete item (itemoffset(tCase,pTopo[1])) of pTopo[1]
   delete item (itemoffset(tCase,pTopo[1])) of pTopo[1] -- get rid of case node at start and end of list, at least for now 15FEB2016
   
   -- list of only the change steps (define action groups)
   put empty into tTopoChanges
   repeat for each item tBlerg in pTopo[1]
      if pShort[1][tBlerg]["type"] is "change" then put tBlerg into item (the number of items of tTopoChanges)+1 of tTopoChanges
   end repeat
   
   put 0 into tCount -- maintains the order the actions should be listed in
   repeat for each item tRec in tTopoChanges
      put tCount + 1 into tCount
      put tRec into pBubbleA["action"][tCount]["thruput"]
      -- this rec's node details
      put tRec into pBubbleA["node"][tRec]["record"]
      put pShort[1][tRec]["title"] into pBubbleA["node"][tRec]["title"]
      --       if pBubbleA["node"][tRec]["title"] is empty then put "[untitled]" into pBubbleA["node"][tRec]["title"]
      put pShort[1][tRec]["memo"] into pBubbleA["node"][tRec]["memo"]
      --       if pBubbleA["node"][tRec]["memo"] is empty then put "[undescribed]" into pBubbleA["node"][tRec]["memo"]
      put pShort[1][tRec]["figure"] into pBubbleA["node"][tRec]["figure"]
      if pBubbleA["node"][tRec]["figure"] is not empty then
         put pBubbleA["node"][tRec]["figure"] into tFilename
         put pBubbleA["project"]["filepath"] into tFilepath
         set itemdelimiter to "/"
         put tFilename into item -1 of tFilepath
         put tFilepath into pBubbleA["node"][tRec]["figure"]
         set itemdelimiter to comma
      end if
      
      put empty into tStuff
      -- inputs and outputs (and weights)
      repeat for each line tLine in pShort[1][tRec]["prev"] ------------------ inputs -------------------------
         put pShort[1][tLine]["prev"] into tNode
         put pShort[1][tLine]["weight"] into tWeight
         --          put tNode into item (the number of items of pBubbleA["action"][tCount]["inputs"])+1 of pBubbleA["action"][tCount]["inputs"]
         put tWeight into pBubbleA["action"][tCount]["inputs"][tNode]
         if pBubbleA["action"][tCount]["inputs"][tNode] is empty then put 1 into pBubbleA["action"][tCount]["inputs"][tNode]
         put tNode into pBubbleA["node"][tNode]["record"]
         put pShort[1][tNode]["title"] into pBubbleA["node"][tNode]["title"]
         --          if pBubbleA["node"][tNode]["title"] is empty then put "[untitled]" into pBubbleA["node"][tNode]["title"]
         put pShort[1][tNode]["memo"] into pBubbleA["node"][tNode]["memo"]
         --          if pBubbleA["node"][tNode]["memo"] is empty then put "[undescribed]" into pBubbleA["node"][tNode]["memo"]
         put pShort[1][tNode]["figure"] into pBubbleA["node"][tNode]["figure"]
         if pBubbleA["node"][tNode]["figure"] is not empty then
            put pBubbleA["node"][tNode]["figure"] into tFilename
            put pBubbleA["project"]["filepath"] into tFilepath
            set itemdelimiter to "/"
            put tFilename into item -1 of tFilepath
            put tFilepath into pBubbleA["node"][tNode]["figure"]
            set itemdelimiter to comma
         end if
         --          if tWeight > 1 then
         --             put 1 into tStuff["doc"]
         --             put tNode into tStuff["rec"]
         --             put cr & "use" && tWeight & "x" && pBubbleA["node"][tNode]["title"] after pBubbleA["action"][tCount]["weights"]
         --             filter pBubbleA["action"][tCount]["weights"] without empty
         --          end if
      end repeat
      repeat for each line tLine in pShort[1][tRec]["next"] ------------------- outputs ----------------------
         put pShort[1][tLine]["next"] into tNode
         put pShort[1][tLine]["weight"] into tWeight
         --          put tNode into item (the number of items of pBubbleA["action"][tCount]["outputs"])+1 of pBubbleA["action"][tCount]["outputs"]
         put tWeight into pBubbleA["action"][tCount]["outputs"][tNode]
         if pBubbleA["action"][tCount]["outputs"][tNode] is empty then put 1 into pBubbleA["action"][tCount]["outputs"][tNode]
         put tNode into pBubbleA["node"][tNode]["record"]
         put pShort[1][tNode]["title"] into pBubbleA["node"][tNode]["title"]
         --          if pBubbleA["node"][tNode]["title"] is empty then put "[undescribed]" into pBubbleA["node"][tNode]["title"]
         put pShort[1][tNode]["memo"] into pBubbleA["node"][tNode]["memo"]
         --          if pBubbleA["node"][tNode]["memo"] is empty then put "[undescribed]" into pBubbleA["node"][tNode]["memo"]
         put pShort[1][tNode]["figure"] into pBubbleA["node"][tNode]["figure"]
         if pBubbleA["node"][tNode]["figure"] is not empty then
            put pBubbleA["node"][tNode]["figure"] into tFilename
            put pBubbleA["project"]["filepath"] into tFilepath
            set itemdelimiter to "/"
            put tFilename into item -1 of tFilepath
            put tFilepath into pBubbleA["node"][tNode]["figure"]
            set itemdelimiter to comma
         end if
         --          if tWeight > 1 then
         --             put 1 into tStuff["doc"]
         --             put tNode into tStuff["rec"]
         --             put cr & "get" && tWeight & "x" && pBubbleA["node"][tNode]["title"] after pBubbleA["action"][tCount]["weights"]
         --             filter pBubbleA["action"][tCount]["weights"] without empty
         --          end if
      end repeat
   end repeat -- item tRec in tTopoChanges
   --------------------------------------------------------- end instructions ------------------------------------------------
   --------------------------------------------------------- start resources -------------------------------------------------
   -- assumes one doc (doc[1])
   put "in out thru" into tPutOrder
   put empty into tResources
   repeat for each key tPut in pSketch[1][2] -- keys will be in, thru, and out
      set itemdelimiter to comma
      repeat for each item tRec in pSketch[1][2][tPut]
         switch tPut
            case "in"
               --                put pBubbleA["node"][tRec]["bubble_id"] into item (the number of items of pBubbleA["project"]["resources"])+1 of pBubbleA["project"]["resources"]
               --                put tRec into item (the number of items of pBubbleA["project"]["resources_recs"])+1 of pBubbleA["project"]["resources_recs"]
               --                put "need" && pResources[1][tRec]["totDemand"] & "x total" into pBubbleA["node"][tRec]["as_resource"]
               put pResources[1][tRec]["totDemand"] into pBubbleA["project"]["resources"][tRec]
               if tRec is among the items of pShort[1][0]["onlyone"] then put 1 into pBubbleA["project"]["resources"][tRec]
               break
            case "thru"
               if pResources[1][tRec]["excess"] > 0 then
                  --                put pBubbleA["node"][tRec]["bubble_id"] into item (the number of items of pBubbleA["project"]["results"])+1 of pBubbleA["project"]["results"]
                  --                   put tRec into item (the number of items of pBubbleA["project"]["results_recs"])+1 of pBubbleA["project"]["results_recs"]
                  --                   put "have" && pResources[1][tRec]["totDemand"] & "x total (excess)" into pBubbleA["node"][tRec]["as_result"]
                  put pResources[1][tRec]["totDemand"] into pBubbleA["project"]["results"][tRec]
               end if
               break
            case "out"
               --                put pBubbleA["node"][tRec]["bubble_id"] into item (the number of items of pBubbleA["project"]["results"])+1 of pBubbleA["project"]["results"]
               --                put tRec into item (the number of items of pBubbleA["project"]["results_recs"])+1 of pBubbleA["project"]["results_recs"]
               --                put "have" && pResources[1][tRec]["totDemand"] & "x total" into pBubbleA["node"][tRec]["as_result"]
               put pResources[1][tRec]["totDemand"] into pBubbleA["project"]["results"][tRec]
               break
         end switch
      end repeat -- each item tRec in pSketch[1][2][tPut]
   end repeat -- each key tPut in pSketch[1][2]
   --------------------------------------------------------- end resources --------------------------------------------------   
end arrayForBubble

-- ! 15FEB2016 using summarizeResourcesHTML now, but this logic is more general so don't delete
--function summarizeResources @pMain,@pSketch,@pResources,pDoc
--   put "function summarizeResources" into xX["write"];    devLog xX
--   -- sMain,sScopeSketch,sResources,sNowDoc
--   -- for each key in sScopeSketch[sNowDoc]
--   -- build summary string, put in tArray[blerg]
--   -- for each key in sScopeSketch[sNowDoc]
--   -- replace top with relevant summary string
--   -- string
--   -- OPEN whatever
--   -- IN
--   -- THRU
--   -- OUT
--   -- MISC
--   -- second time
--   -- repeat until all recs in tStrings visited
--   -- start with "rec" 0
--   -- replace a number alone on a line with it's string and some dashes based on counter
--   -- next cycle will have new text from the string added, so replace numbers alone on lines

--   --   build a string to summarize each case node
--   put empty into tStrings
--   repeat for each key tCase in pSketch[pDoc]
--      if tCase = 0 then
--         -- maybe just don't print anything
--      else
--         put pDoc into tStuff["doc"]
--         put tCase into tStuff["rec"]
--         put "OPEN" && stepString(pMain,tStuff) & cr into tStrings[tCase]
--      end if
--      put "IN-PUT" & cr after tStrings[tCase]
--      repeat for each item tN in pSketch[pDoc][tCase]["in"]
--         -- if this also has role top, just put its rec alone on a line
--         if tN is among the keys of pSketch[pDoc] then
--            put tN & cr after tStrings[tCase]
--         else
--            put pDoc into tStuff["doc"]
--            put tN into tStuff["rec"]
--            put pResources[pDoc][tN]["totDemand"] && "x" && stepString(pMain,tStuff) & cr after tStrings[tCase]
--         end if
--      end repeat
--      put "THRU-PUT" & cr after tStrings[tCase]
--      put empty into tData
--      repeat for each item tH in pSketch[pDoc][tCase]["thru"]
--         put pResources[pDoc][tH]["excess"] into tMuch
--         if tMuch is not 0 and tMuch is not empty then 
--            if tH is among the keys of pSketch[pDoc] then
--               put tH & cr after tData
--            else
--               put pDoc into tStuff["doc"]
--               put tH into tStuff["rec"]
--               put tMuch && "x" && stepString(pMain,tStuff) & cr after tData
--            end if
--         end if
--      end repeat
--      if tData is empty then 
--         put "supply=demand" & cr after tStrings[tCase]
--      else
--         put tData after tStrings[tCase]
--      end if
--      put "OUT-PUT" & cr after tStrings[tCase]
--      repeat for each item tU in pSketch[pDoc][tCase]["out"]
--         if tU is among the keys of pSketch[pDoc] then
--            put tU & cr after tStrings[tCase]
--         else
--            put pDoc into tStuff["doc"]
--            put tU into tStuff["rec"]
--            put pResources[pDoc][tU]["totSupply"] && "x" && stepString(pMain,tStuff) & cr after tStrings[tCase]
--         end if
--      end repeat
--      put "NOT-PUT" & cr after tStrings[tCase]
--      repeat for each item tS in pSketch[pDoc][tCase]["solo"]
--         if tS is among the keys of pSketch[pDoc] then
--            put tS & cr after tStrings[tCase]
--         else
--            put pDoc into tStuff["doc"]
--            put tS into tStuff["rec"]
--            put pResources[pDoc][tS]["totSupply"] && "x" && stepString(pMain,tStuff) & cr after tStrings[tCase]
--         end if
--      end repeat
--   end repeat -- tCase in pSketch[pDoc]
--   -- build a bigger string with the case node summaries nested appropriately
--   --   repeat for each key tKey in tStrings
--   --      filter tStrings[tKey] without empty
--   --   end repeat
--   --   put tStrings[0] into tSummary -- 0 is a pseudo case to encase absolutely everything
--   -- embed one string in another
--   put " " into tIndent
--   put the keys of pSketch[pDoc] into tAll
--   replace cr with "," in tAll -- items instead of lines
--   put tStrings[0] into tDisplay
--   filter tDisplay without empty -- remove any trailing cr
--   put tDisplay into tWorking
--   put true into tAgain
--   repeat while tAgain is true
--      put false into tAgain
--      put empty into tInserts
--      put "-" before tIndent
--      repeat with tJ = 1 to the number of lines of tWorking
--         put line tJ of tWorking into tWorkIt
--         replace " " with "" in tWorkIt
--         replace "-" with "" in tWorkIt
--         replace cr with "" in tWorkIt
--         -- if tWorkIt has a rec then it should be just the clean rec now
--         if tWorkIt is among the items of tAll then
--            put tStrings[tWorkIt] into tInserts[tJ]["string"] -- so now array[line offset][string]=new string
--            repeat with tJJ = 1 to the number of lines of tInserts[tJ]["string"]
--               put tIndent before line tJJ of tInserts[tJ]["string"]
--            end repeat
--            put tWorkIt into tInserts[tJ]["rec"] -- so now array[line offset][rec]=num to replace
--         end if
--         if tJ = the number of lines of tWorking then
--            -- the last line was just checked to see if it needed replacing
--            put the keys of tInserts into tOrder
--            sort tOrder numeric descending -- highest line offset to lowest
--            repeat for each line tNext in tOrder
--               put true into tAgain
--               -- delete line
--               -- insert new string before line
--               delete line tNext of tWorking
--               put tInserts[tNext]["string"] before line tNext of tWorking
--            end repeat
--         end if
--      end repeat -- tJ
--      put tWorking into tDisplay
--   end repeat -- tAgain
--   --   return tDisplay
--   put empty into line 1 to 5 of tDisplay -- ! since only one scope level as of 14FEB2016, this first part isn't helping
--   put pMain[1][0]["filepath"] into tPath
--   set the itemdelimiter to slash
--   put "instructions.html" into item -1 of tPath
--   put tDisplay into field "testHtml" stack "HowstrBeta"-- needs to be in field for following edits
--   -- add link to instructions
--   put "Instructions" & cr before line 1 of field "testHtml" stack "HowstrBeta"
--   set the textStyle of word 1 of line 1 of field "testHtml" stack "HowstrBeta" to link
--   set the linkText of word 1 of line 1 of field "testHtml" stack "HowstrBeta" to tPath
--   -- add an easily understood header
--   put "Supply and Demand (bill of materials) as of" && the system date && the system time & cr before line 1 of field "testHtml" stack "HowstrBeta"
--   set the textStyle of line 1 of field "testHtml" stack "HowstrBeta" to "bold"
--   -- create or overwrite the resources 
--   put "resources.html" into item -1 of tPath
--   put the HTMLText of field "testHtml" stack "HowstrBeta" into URL ("file:" & tPath)
--end summarizeResources

function summarizeResourcesHTML @pMain,@pShort,@pSketch,@pResources,pDoc
   -- ! assumes one doc (doc[1]) and one scope level as of 15FEB2016
   put "in thru out" into tPutOrder
   put "amount stepString anchor cr memo cr figure cr prev cr next" into tDetailOrder
   put empty into tResources
   put pMain[1][0]["filepath"] into tPath
   set the itemdelimiter to slash
   put "instructions.html" into item -1 of tPath
   -- header kind of thing ----------------------------------------
   set the itemdelimiter to comma
   put item 1 of pSketch[1][0]["top"] into tCase
   put "<head>" & cr & "<title>" after tResources
   put pShort[1][tCase]["title"] into tCaseTitle
   if tCaseTitle is not empy then 
      --      put "<p><b>" & tCaseTitle & "</b></p>" & cr after tResources
      put tCaseTitle after tResources
   else
      --      put "<p><b>Untitled</b></p>" & cr after tResources
      put "Untitled" into tCaseTitle
      put tCasteTitle after tResources
   end if
   put " - Generated by Howstr" after tInstructions
   put "</title>" & cr & "</head>" & cr & "<body>" & cr after tResources
   put "<p><b>" & tCaseTitle & "</b></p>" & cr after tResources
   put "<p><b>Supply and demand (bill of materials) as of" && the system date && the system time & "</b></p>" & cr after tResources
   put "<p><a href=" & quote & tPath & quote & ">Instructions</a></p>" & cr after tResources
   put "<p><a href=" & quote & "http://github.howstr.com" & quote & ">Generated by Howstr</a><p>" & cr after tInstructions
   -- table of contents kind of thing ---------------------------------
   put "<p><a href=" & quote & "#in" & quote & ">Input</a></p>" & cr after tResources
   put "<p><a href=" & quote & "#thru" & quote & ">Thruput</a></p>" & cr after tResources
   put "<p><a href=" & quote & "#out" & quote & ">Output</a></p>" & cr after tResources
   -- in/thru/out-put kind of things ------------------------------------
   repeat for each word tPut in tPutOrder
      switch tPut
         case "in"
            put "<p><b>Required at start:</b><a name=" & quote & "in" & quote & "></a></p>" & cr after tResources
            break
         case "thru"
            put "<p><b>Excess during:</b><a name=" & quote & "thru" & quote & "></a></p>" & cr after tResources
            break
         case "out"
            put "<p><b>Result at end:</b><a name=" & quote & "out" & quote & "></a></p>" & cr after tResources
            break
      end switch
      set the itemdelimiter to comma
      repeat for each item tRec in pSketch[1][2][tPut]
         if tPut is "thru" and (pResources[1][tRec]["excess"] is empty) then next repeat
         repeat for each word tAdetail in tDetailOrder
            switch tAdetail
               case "amount"
                  if tPut is "in" then put "<p><b>" & pResources[1][tRec]["totDemand"] && "x</b>  " after tResources
                  if tPut is "thru" then put "<p><b>" & pResources[1][tRec]["excess"] && "x</b>  " after tResources
                  if tPut is "out" then put "<p><b>" & pResources[1][tRec]["totSupply"] && "x</b>  " after tResources
                  break
               case "stepString"
                  put 1 into tStuff["doc"]
                  put tRec into tStuff["rec"]
                  put stepString(pMain,tStuff) into field "testHtml" stack "HowstrBeta"
                  put the htmltext of field "testHtml" stack "HowstrBeta" into tUgly
                  replace "<p>" with "<b>" in tUgly
                  replace "</p>" with "</b>" in tUgly
                  put tUgly after tResources
                  break
               case "anchor"
                  put "<a name=" & quote & tRec & quote & "></a>" after tResources
                  break
               case "cr"
                  put "<p></p>" & cr after tResources
                  break
               case "memo"
                  put pShort[1][tRec]["memo"] into tMemo
                  if tMemo is not empty then put tMemo after tResources
                  break
               case "figure"
                  put pShort[1][tRec]["figure"] into tFigure
                  if tFigure is not empty then 
                     set the itemdelimiter to slash
                     put item -1 of tFigure into tFigure
                     --                     put "<img src=" & quote & tFigure & quote & ">" after tResources
                     put "<a href=" & quote & tFigure & quote && "target=" & quote & "_blank" & quote & ">" after tResources
                     put "<img src=" & quote & tFigure & quote && "width=" & quote & "200" & quote & ">" after tResources
                     put "</a>" after tResources
                     set the itemdelimiter to comma
                  end if
                  break
            end switch
         end repeat -- word in tDetailOrder
      end repeat -- tRec in tPut
   end repeat -- tPut in tPutOrder
   return tResources
end summarizeResourcesHTML

--on resizeStack pNewWidth, pNewHeight, pOldWidth, pOldHeight
--   put "on resizeStack" into xX["write"];    devLog xX
--   if the rect of this stack is the screenRect then
--      set the visible of widget "iconMaximize" to false
--      set the visible of widget "iconMediumsize" to true
--   else
--      set the visible of widget "iconMaximize" to true
--      set the visible of widget "iconMediumsize" to false
--   end if
--   -- all of the layer information for all of the graph data in memory is calculated by middleOut
--   -- so when the window resizes, displayManager updates the graphics based on what fits now
--   refreshDisplay
--end resizeStack
on resizeMainStack pNewWidth, pNewHeight, pOldWidth, pOldHeight
   put "on resizeStack" into xX["write"];    devLog xX
   if the rect of this stack is the screenRect then
      set the visible of widget "iconMaximize" stack "HowstrBeta" to false
      set the visible of widget "iconMediumsize" stack "HowstrBeta" to true
   else
      set the visible of widget "iconMaximize" stack "HowstrBeta" to true
      set the visible of widget "iconMediumsize" stack "HowstrBeta" to false
   end if
   -- all of the layer information for all of the graph data in memory is calculated by middleOut
   -- so when the window resizes, displayManager updates the graphics based on what fits now
   refreshDisplay
end resizeMainStack
